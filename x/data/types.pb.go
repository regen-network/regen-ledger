// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: regen/data/v1/types.proto

package data

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// DigestAlgorithm is the hash digest algorithm
type DigestAlgorithm int32

const (
	// unspecified and invalid
	DigestAlgorithm_DIGEST_ALGORITHM_UNSPECIFIED DigestAlgorithm = 0
	// BLAKE2b-256
	DigestAlgorithm_DIGEST_ALGORITHM_BLAKE2B_256 DigestAlgorithm = 1
)

var DigestAlgorithm_name = map[int32]string{
	0: "DIGEST_ALGORITHM_UNSPECIFIED",
	1: "DIGEST_ALGORITHM_BLAKE2B_256",
}

var DigestAlgorithm_value = map[string]int32{
	"DIGEST_ALGORITHM_UNSPECIFIED": 0,
	"DIGEST_ALGORITHM_BLAKE2B_256": 1,
}

func (x DigestAlgorithm) String() string {
	return proto.EnumName(DigestAlgorithm_name, int32(x))
}

func (DigestAlgorithm) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a49a7c2bdb2b2846, []int{0}
}

// Deprecated: use RawV2 instead.
// RawMediaType defines MIME media types to be used with a ContentHash.Raw hash.
type RawMediaType int32

const (
	// RAW_MEDIA_TYPE_UNSPECIFIED can be used for raw binary data
	RawMediaType_RAW_MEDIA_TYPE_UNSPECIFIED RawMediaType = 0
	// plain text
	RawMediaType_RAW_MEDIA_TYPE_TEXT_PLAIN RawMediaType = 1
	// JSON
	RawMediaType_RAW_MEDIA_TYPE_JSON RawMediaType = 2
	// CSV
	RawMediaType_RAW_MEDIA_TYPE_CSV RawMediaType = 3
	// XML
	RawMediaType_RAW_MEDIA_TYPE_XML RawMediaType = 4
	// PDF
	RawMediaType_RAW_MEDIA_TYPE_PDF RawMediaType = 5
	// TIIF
	RawMediaType_RAW_MEDIA_TYPE_TIFF RawMediaType = 16
	// JPG
	RawMediaType_RAW_MEDIA_TYPE_JPG RawMediaType = 17
	// PNG
	RawMediaType_RAW_MEDIA_TYPE_PNG RawMediaType = 18
	// SVG
	RawMediaType_RAW_MEDIA_TYPE_SVG RawMediaType = 19
	// WEBP
	RawMediaType_RAW_MEDIA_TYPE_WEBP RawMediaType = 20
	// AVIF
	RawMediaType_RAW_MEDIA_TYPE_AVIF RawMediaType = 21
	// GIF
	RawMediaType_RAW_MEDIA_TYPE_GIF RawMediaType = 22
	// APNG
	RawMediaType_RAW_MEDIA_TYPE_APNG RawMediaType = 23
	// MPEG
	RawMediaType_RAW_MEDIA_TYPE_MPEG RawMediaType = 32
	// MP4
	RawMediaType_RAW_MEDIA_TYPE_MP4 RawMediaType = 33
	// WEBM
	RawMediaType_RAW_MEDIA_TYPE_WEBM RawMediaType = 34
	// OGG
	RawMediaType_RAW_MEDIA_TYPE_OGG RawMediaType = 35
)

var RawMediaType_name = map[int32]string{
	0:  "RAW_MEDIA_TYPE_UNSPECIFIED",
	1:  "RAW_MEDIA_TYPE_TEXT_PLAIN",
	2:  "RAW_MEDIA_TYPE_JSON",
	3:  "RAW_MEDIA_TYPE_CSV",
	4:  "RAW_MEDIA_TYPE_XML",
	5:  "RAW_MEDIA_TYPE_PDF",
	16: "RAW_MEDIA_TYPE_TIFF",
	17: "RAW_MEDIA_TYPE_JPG",
	18: "RAW_MEDIA_TYPE_PNG",
	19: "RAW_MEDIA_TYPE_SVG",
	20: "RAW_MEDIA_TYPE_WEBP",
	21: "RAW_MEDIA_TYPE_AVIF",
	22: "RAW_MEDIA_TYPE_GIF",
	23: "RAW_MEDIA_TYPE_APNG",
	32: "RAW_MEDIA_TYPE_MPEG",
	33: "RAW_MEDIA_TYPE_MP4",
	34: "RAW_MEDIA_TYPE_WEBM",
	35: "RAW_MEDIA_TYPE_OGG",
}

var RawMediaType_value = map[string]int32{
	"RAW_MEDIA_TYPE_UNSPECIFIED": 0,
	"RAW_MEDIA_TYPE_TEXT_PLAIN":  1,
	"RAW_MEDIA_TYPE_JSON":        2,
	"RAW_MEDIA_TYPE_CSV":         3,
	"RAW_MEDIA_TYPE_XML":         4,
	"RAW_MEDIA_TYPE_PDF":         5,
	"RAW_MEDIA_TYPE_TIFF":        16,
	"RAW_MEDIA_TYPE_JPG":         17,
	"RAW_MEDIA_TYPE_PNG":         18,
	"RAW_MEDIA_TYPE_SVG":         19,
	"RAW_MEDIA_TYPE_WEBP":        20,
	"RAW_MEDIA_TYPE_AVIF":        21,
	"RAW_MEDIA_TYPE_GIF":         22,
	"RAW_MEDIA_TYPE_APNG":        23,
	"RAW_MEDIA_TYPE_MPEG":        32,
	"RAW_MEDIA_TYPE_MP4":         33,
	"RAW_MEDIA_TYPE_WEBM":        34,
	"RAW_MEDIA_TYPE_OGG":         35,
}

func (x RawMediaType) String() string {
	return proto.EnumName(RawMediaType_name, int32(x))
}

func (RawMediaType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a49a7c2bdb2b2846, []int{1}
}

// GraphCanonicalizationAlgorithm is the graph canonicalization algorithm
type GraphCanonicalizationAlgorithm int32

const (
	// unspecified and invalid
	GraphCanonicalizationAlgorithm_GRAPH_CANONICALIZATION_ALGORITHM_UNSPECIFIED GraphCanonicalizationAlgorithm = 0
	// URDNA2015 graph hashing
	GraphCanonicalizationAlgorithm_GRAPH_CANONICALIZATION_ALGORITHM_URDNA2015 GraphCanonicalizationAlgorithm = 1
)

var GraphCanonicalizationAlgorithm_name = map[int32]string{
	0: "GRAPH_CANONICALIZATION_ALGORITHM_UNSPECIFIED",
	1: "GRAPH_CANONICALIZATION_ALGORITHM_URDNA2015",
}

var GraphCanonicalizationAlgorithm_value = map[string]int32{
	"GRAPH_CANONICALIZATION_ALGORITHM_UNSPECIFIED": 0,
	"GRAPH_CANONICALIZATION_ALGORITHM_URDNA2015":   1,
}

func (x GraphCanonicalizationAlgorithm) String() string {
	return proto.EnumName(GraphCanonicalizationAlgorithm_name, int32(x))
}

func (GraphCanonicalizationAlgorithm) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a49a7c2bdb2b2846, []int{2}
}

// GraphMerkleTree is the graph merkle tree type used for hashing, if any
type GraphMerkleTree int32

const (
	// unspecified and valid
	GraphMerkleTree_GRAPH_MERKLE_TREE_NONE_UNSPECIFIED GraphMerkleTree = 0
)

var GraphMerkleTree_name = map[int32]string{
	0: "GRAPH_MERKLE_TREE_NONE_UNSPECIFIED",
}

var GraphMerkleTree_value = map[string]int32{
	"GRAPH_MERKLE_TREE_NONE_UNSPECIFIED": 0,
}

func (x GraphMerkleTree) String() string {
	return proto.EnumName(GraphMerkleTree_name, int32(x))
}

func (GraphMerkleTree) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a49a7c2bdb2b2846, []int{3}
}

// ContentHash specifies a hash-based content identifier for a piece of data.
// Exactly one of its fields must be set so this message behaves like a oneof.
// A protobuf oneof was not used because this caused compatibility issues with
// amino signing.
type ContentHash struct {
	// Deprecated: use RawV2 instead.
	// Raw specifies "raw" data which does not specify a deterministic, canonical
	// encoding. Users of these hashes MUST maintain a copy of the hashed data
	// which is preserved bit by bit. All other content encodings specify a
	// deterministic, canonical encoding allowing implementations to choose from a
	// variety of alternative formats for transport and encoding while maintaining
	// the guarantee that the canonical hash will not change. The media type for
	// "raw" data is defined by the MediaType enum.
	Raw *ContentHash_Raw `protobuf:"bytes,1,opt,name=raw,proto3" json:"raw,omitempty"` // Deprecated: Do not use.
	// Deprecated: use GraphV2 instead.
	// Graph specifies graph data that conforms to the RDF data model.
	// The canonicalization algorithm used for an RDF graph is specified by
	// GraphCanonicalizationAlgorithm.
	Graph *ContentHash_Graph `protobuf:"bytes,2,opt,name=graph,proto3" json:"graph,omitempty"` // Deprecated: Do not use.
	// raw_v2 specifies "raw" data which does not specify a deterministic, canonical
	// encoding. Users of these hashes MUST maintain a copy of the hashed data
	// which is preserved bit by bit. All other content encodings specify a
	// deterministic, canonical encoding allowing implementations to choose from a
	// variety of alternative formats for transport and encoding while maintaining
	// the guarantee that the canonical hash will not change. The media type for
	// "raw" data is defined by the MediaType enum.
	RawV2 *ContentHash_RawV2 `protobuf:"bytes,3,opt,name=raw_v2,json=rawV2,proto3" json:"raw_v2,omitempty"`
	// graph_v2 specifies graph data that conforms to the RDF data model.
	// The canonicalization algorithm used for an RDF graph is specified by
	// GraphCanonicalizationAlgorithm.
	GraphV2 *ContentHash_GraphV2 `protobuf:"bytes,4,opt,name=graph_v2,json=graphV2,proto3" json:"graph_v2,omitempty"`
}

func (m *ContentHash) Reset()         { *m = ContentHash{} }
func (m *ContentHash) String() string { return proto.CompactTextString(m) }
func (*ContentHash) ProtoMessage()    {}
func (*ContentHash) Descriptor() ([]byte, []int) {
	return fileDescriptor_a49a7c2bdb2b2846, []int{0}
}
func (m *ContentHash) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContentHash) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContentHash.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContentHash) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContentHash.Merge(m, src)
}
func (m *ContentHash) XXX_Size() int {
	return m.Size()
}
func (m *ContentHash) XXX_DiscardUnknown() {
	xxx_messageInfo_ContentHash.DiscardUnknown(m)
}

var xxx_messageInfo_ContentHash proto.InternalMessageInfo

// Deprecated: Do not use.
func (m *ContentHash) GetRaw() *ContentHash_Raw {
	if m != nil {
		return m.Raw
	}
	return nil
}

// Deprecated: Do not use.
func (m *ContentHash) GetGraph() *ContentHash_Graph {
	if m != nil {
		return m.Graph
	}
	return nil
}

func (m *ContentHash) GetRawV2() *ContentHash_RawV2 {
	if m != nil {
		return m.RawV2
	}
	return nil
}

func (m *ContentHash) GetGraphV2() *ContentHash_GraphV2 {
	if m != nil {
		return m.GraphV2
	}
	return nil
}

// Raw is the content hash type used for raw data.
type ContentHash_Raw struct {
	// hash represents the hash of the data based on the specified
	// digest_algorithm.
	Hash []byte `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	// digest_algorithm represents the hash digest algorithm.
	DigestAlgorithm DigestAlgorithm `protobuf:"varint,2,opt,name=digest_algorithm,json=digestAlgorithm,proto3,enum=regen.data.v1.DigestAlgorithm" json:"digest_algorithm,omitempty"`
	// media_type represents the media type for raw data.
	MediaType RawMediaType `protobuf:"varint,3,opt,name=media_type,json=mediaType,proto3,enum=regen.data.v1.RawMediaType" json:"media_type,omitempty"`
}

func (m *ContentHash_Raw) Reset()         { *m = ContentHash_Raw{} }
func (m *ContentHash_Raw) String() string { return proto.CompactTextString(m) }
func (*ContentHash_Raw) ProtoMessage()    {}
func (*ContentHash_Raw) Descriptor() ([]byte, []int) {
	return fileDescriptor_a49a7c2bdb2b2846, []int{0, 0}
}
func (m *ContentHash_Raw) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContentHash_Raw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContentHash_Raw.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContentHash_Raw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContentHash_Raw.Merge(m, src)
}
func (m *ContentHash_Raw) XXX_Size() int {
	return m.Size()
}
func (m *ContentHash_Raw) XXX_DiscardUnknown() {
	xxx_messageInfo_ContentHash_Raw.DiscardUnknown(m)
}

var xxx_messageInfo_ContentHash_Raw proto.InternalMessageInfo

func (m *ContentHash_Raw) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *ContentHash_Raw) GetDigestAlgorithm() DigestAlgorithm {
	if m != nil {
		return m.DigestAlgorithm
	}
	return DigestAlgorithm_DIGEST_ALGORITHM_UNSPECIFIED
}

func (m *ContentHash_Raw) GetMediaType() RawMediaType {
	if m != nil {
		return m.MediaType
	}
	return RawMediaType_RAW_MEDIA_TYPE_UNSPECIFIED
}

// Graph is the content hash type used for RDF graph data.
type ContentHash_Graph struct {
	// hash represents the hash of the data based on the specified
	// digest_algorithm.
	Hash []byte `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	// digest_algorithm represents the hash digest algorithm.
	DigestAlgorithm DigestAlgorithm `protobuf:"varint,2,opt,name=digest_algorithm,json=digestAlgorithm,proto3,enum=regen.data.v1.DigestAlgorithm" json:"digest_algorithm,omitempty"`
	// graph_canonicalization_algorithm represents the RDF graph
	// canonicalization algorithm.
	CanonicalizationAlgorithm GraphCanonicalizationAlgorithm `protobuf:"varint,3,opt,name=canonicalization_algorithm,json=canonicalizationAlgorithm,proto3,enum=regen.data.v1.GraphCanonicalizationAlgorithm" json:"canonicalization_algorithm,omitempty"`
	// merkle_tree is the merkle tree type used for the graph hash, if any.
	MerkleTree GraphMerkleTree `protobuf:"varint,4,opt,name=merkle_tree,json=merkleTree,proto3,enum=regen.data.v1.GraphMerkleTree" json:"merkle_tree,omitempty"`
}

func (m *ContentHash_Graph) Reset()         { *m = ContentHash_Graph{} }
func (m *ContentHash_Graph) String() string { return proto.CompactTextString(m) }
func (*ContentHash_Graph) ProtoMessage()    {}
func (*ContentHash_Graph) Descriptor() ([]byte, []int) {
	return fileDescriptor_a49a7c2bdb2b2846, []int{0, 1}
}
func (m *ContentHash_Graph) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContentHash_Graph) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContentHash_Graph.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContentHash_Graph) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContentHash_Graph.Merge(m, src)
}
func (m *ContentHash_Graph) XXX_Size() int {
	return m.Size()
}
func (m *ContentHash_Graph) XXX_DiscardUnknown() {
	xxx_messageInfo_ContentHash_Graph.DiscardUnknown(m)
}

var xxx_messageInfo_ContentHash_Graph proto.InternalMessageInfo

func (m *ContentHash_Graph) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *ContentHash_Graph) GetDigestAlgorithm() DigestAlgorithm {
	if m != nil {
		return m.DigestAlgorithm
	}
	return DigestAlgorithm_DIGEST_ALGORITHM_UNSPECIFIED
}

func (m *ContentHash_Graph) GetCanonicalizationAlgorithm() GraphCanonicalizationAlgorithm {
	if m != nil {
		return m.CanonicalizationAlgorithm
	}
	return GraphCanonicalizationAlgorithm_GRAPH_CANONICALIZATION_ALGORITHM_UNSPECIFIED
}

func (m *ContentHash_Graph) GetMerkleTree() GraphMerkleTree {
	if m != nil {
		return m.MerkleTree
	}
	return GraphMerkleTree_GRAPH_MERKLE_TREE_NONE_UNSPECIFIED
}

// RawV2 is the content hash type used for raw data.
type ContentHash_RawV2 struct {
	// hash represents the hash of the data based on the specified
	// digest_algorithm. It must be at least 20 bytes long and at most 64 bytes long.
	Hash []byte `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	// digest_algorithm represents the hash digest algorithm and should be a non-zero value from the DigestAlgorithm enum.
	DigestAlgorithm uint32 `protobuf:"varint,2,opt,name=digest_algorithm,json=digestAlgorithm,proto3" json:"digest_algorithm,omitempty"`
	// file_extension represents the file extension for raw data. It can be
	// must be between 2-6 characters long, must be all lower-case and should represent
	// the canonical extension for the media type.
	//
	// A list of canonical extensions which should be used is provided here
	// and SHOULD be used by implementations: txt, json, csv, xml, pdf, tiff,
	// jpg, png, svg, webp, avif, gif, apng, mpeg, mp4, webm, ogg, heic, raw.
	//
	// The above list should be updated as new media types come into common usage
	// especially when there are two or more possible extensions (i.e. jpg vs jpeg or tif vs tiff).
	FileExtension string `protobuf:"bytes,3,opt,name=file_extension,json=fileExtension,proto3" json:"file_extension,omitempty"`
}

func (m *ContentHash_RawV2) Reset()         { *m = ContentHash_RawV2{} }
func (m *ContentHash_RawV2) String() string { return proto.CompactTextString(m) }
func (*ContentHash_RawV2) ProtoMessage()    {}
func (*ContentHash_RawV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_a49a7c2bdb2b2846, []int{0, 2}
}
func (m *ContentHash_RawV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContentHash_RawV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContentHash_RawV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContentHash_RawV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContentHash_RawV2.Merge(m, src)
}
func (m *ContentHash_RawV2) XXX_Size() int {
	return m.Size()
}
func (m *ContentHash_RawV2) XXX_DiscardUnknown() {
	xxx_messageInfo_ContentHash_RawV2.DiscardUnknown(m)
}

var xxx_messageInfo_ContentHash_RawV2 proto.InternalMessageInfo

func (m *ContentHash_RawV2) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *ContentHash_RawV2) GetDigestAlgorithm() uint32 {
	if m != nil {
		return m.DigestAlgorithm
	}
	return 0
}

func (m *ContentHash_RawV2) GetFileExtension() string {
	if m != nil {
		return m.FileExtension
	}
	return ""
}

// GraphV2 is the content hash type used for RDF graph data.
type ContentHash_GraphV2 struct {
	// hash represents the hash of the data based on the specified
	// digest_algorithm. It must be at least 20 bytes long and at most 64 bytes long.
	Hash []byte `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	// digest_algorithm represents the hash digest algorithm and should be a non-zero value from the DigestAlgorithm enum.
	DigestAlgorithm uint32 `protobuf:"varint,2,opt,name=digest_algorithm,json=digestAlgorithm,proto3" json:"digest_algorithm,omitempty"`
	// graph_canonicalization_algorithm represents the RDF graph
	// canonicalization algorithm and should be a non-zero value from the GraphCanonicalizationAlgorithm enum.
	CanonicalizationAlgorithm uint32 `protobuf:"varint,3,opt,name=canonicalization_algorithm,json=canonicalizationAlgorithm,proto3" json:"canonicalization_algorithm,omitempty"`
	// merkle_tree is the merkle tree type used for the graph hash, if any and should be a value from the GraphMerkleTree enum
	// or left unspecified.
	MerkleTree uint32 `protobuf:"varint,4,opt,name=merkle_tree,json=merkleTree,proto3" json:"merkle_tree,omitempty"`
}

func (m *ContentHash_GraphV2) Reset()         { *m = ContentHash_GraphV2{} }
func (m *ContentHash_GraphV2) String() string { return proto.CompactTextString(m) }
func (*ContentHash_GraphV2) ProtoMessage()    {}
func (*ContentHash_GraphV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_a49a7c2bdb2b2846, []int{0, 3}
}
func (m *ContentHash_GraphV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContentHash_GraphV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContentHash_GraphV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContentHash_GraphV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContentHash_GraphV2.Merge(m, src)
}
func (m *ContentHash_GraphV2) XXX_Size() int {
	return m.Size()
}
func (m *ContentHash_GraphV2) XXX_DiscardUnknown() {
	xxx_messageInfo_ContentHash_GraphV2.DiscardUnknown(m)
}

var xxx_messageInfo_ContentHash_GraphV2 proto.InternalMessageInfo

func (m *ContentHash_GraphV2) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *ContentHash_GraphV2) GetDigestAlgorithm() uint32 {
	if m != nil {
		return m.DigestAlgorithm
	}
	return 0
}

func (m *ContentHash_GraphV2) GetCanonicalizationAlgorithm() uint32 {
	if m != nil {
		return m.CanonicalizationAlgorithm
	}
	return 0
}

func (m *ContentHash_GraphV2) GetMerkleTree() uint32 {
	if m != nil {
		return m.MerkleTree
	}
	return 0
}

// ContentHashes contains list of content ContentHash.
type ContentHashes struct {
	// data is a list of content hashes which the resolver claims to serve.
	ContentHashes []*ContentHash `protobuf:"bytes,1,rep,name=content_hashes,json=contentHashes,proto3" json:"content_hashes,omitempty"`
}

func (m *ContentHashes) Reset()         { *m = ContentHashes{} }
func (m *ContentHashes) String() string { return proto.CompactTextString(m) }
func (*ContentHashes) ProtoMessage()    {}
func (*ContentHashes) Descriptor() ([]byte, []int) {
	return fileDescriptor_a49a7c2bdb2b2846, []int{1}
}
func (m *ContentHashes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContentHashes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContentHashes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContentHashes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContentHashes.Merge(m, src)
}
func (m *ContentHashes) XXX_Size() int {
	return m.Size()
}
func (m *ContentHashes) XXX_DiscardUnknown() {
	xxx_messageInfo_ContentHashes.DiscardUnknown(m)
}

var xxx_messageInfo_ContentHashes proto.InternalMessageInfo

func (m *ContentHashes) GetContentHashes() []*ContentHash {
	if m != nil {
		return m.ContentHashes
	}
	return nil
}

func init() {
	proto.RegisterEnum("regen.data.v1.DigestAlgorithm", DigestAlgorithm_name, DigestAlgorithm_value)
	proto.RegisterEnum("regen.data.v1.RawMediaType", RawMediaType_name, RawMediaType_value)
	proto.RegisterEnum("regen.data.v1.GraphCanonicalizationAlgorithm", GraphCanonicalizationAlgorithm_name, GraphCanonicalizationAlgorithm_value)
	proto.RegisterEnum("regen.data.v1.GraphMerkleTree", GraphMerkleTree_name, GraphMerkleTree_value)
	proto.RegisterType((*ContentHash)(nil), "regen.data.v1.ContentHash")
	proto.RegisterType((*ContentHash_Raw)(nil), "regen.data.v1.ContentHash.Raw")
	proto.RegisterType((*ContentHash_Graph)(nil), "regen.data.v1.ContentHash.Graph")
	proto.RegisterType((*ContentHash_RawV2)(nil), "regen.data.v1.ContentHash.RawV2")
	proto.RegisterType((*ContentHash_GraphV2)(nil), "regen.data.v1.ContentHash.GraphV2")
	proto.RegisterType((*ContentHashes)(nil), "regen.data.v1.ContentHashes")
}

func init() { proto.RegisterFile("regen/data/v1/types.proto", fileDescriptor_a49a7c2bdb2b2846) }

var fileDescriptor_a49a7c2bdb2b2846 = []byte{
	// 787 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x55, 0xcf, 0x93, 0xda, 0x54,
	0x1c, 0x27, 0xb0, 0x74, 0xed, 0x97, 0xc2, 0x3e, 0x5f, 0xb5, 0x65, 0x51, 0x23, 0xe2, 0xe8, 0x54,
	0xa6, 0x0d, 0xdd, 0xd8, 0xea, 0xd8, 0x99, 0x8e, 0x13, 0x20, 0x64, 0xd3, 0x92, 0x90, 0x79, 0xa4,
	0xb4, 0xf6, 0x92, 0x79, 0x85, 0x27, 0x64, 0x0a, 0x09, 0x13, 0xe2, 0xd2, 0x7a, 0xf4, 0x2f, 0xf0,
	0xe2, 0xdd, 0xa3, 0x7f, 0x8a, 0x07, 0x0f, 0x3d, 0x78, 0xf0, 0xe8, 0xec, 0xfe, 0x23, 0x4e, 0x1e,
	0x5d, 0xa5, 0xe1, 0xb1, 0x1c, 0x9c, 0x9e, 0x78, 0x7c, 0x3f, 0x3f, 0xbe, 0x3f, 0xf2, 0x4d, 0x1e,
	0x1c, 0x46, 0x6c, 0xcc, 0x82, 0xc6, 0x88, 0xc6, 0xb4, 0x71, 0x72, 0xd4, 0x88, 0x5f, 0xce, 0xd9,
	0x42, 0x99, 0x47, 0x61, 0x1c, 0xe2, 0x22, 0x87, 0x94, 0x04, 0x52, 0x4e, 0x8e, 0x6a, 0x7f, 0xec,
	0x43, 0xa1, 0x15, 0x06, 0x31, 0x0b, 0xe2, 0x63, 0xba, 0x98, 0xe0, 0x3b, 0x90, 0x8b, 0xe8, 0xb2,
	0x2c, 0x55, 0xa5, 0x1b, 0x05, 0x55, 0x56, 0xde, 0x20, 0x2b, 0x6b, 0x44, 0x85, 0xd0, 0x65, 0x33,
	0x5b, 0x96, 0x48, 0x42, 0xc7, 0xf7, 0x20, 0x3f, 0x8e, 0xe8, 0x7c, 0x52, 0xce, 0x72, 0x5d, 0xf5,
	0x02, 0x9d, 0x91, 0xf0, 0xb8, 0x72, 0x25, 0xc1, 0x5f, 0xc3, 0xa5, 0x88, 0x2e, 0xbd, 0x13, 0xb5,
	0x9c, 0xdb, 0x29, 0x26, 0x74, 0x39, 0x50, 0x49, 0x3e, 0x4a, 0x7e, 0xf0, 0x7d, 0x78, 0x87, 0x3b,
	0x24, 0xd2, 0x3d, 0x2e, 0xad, 0xed, 0xca, 0x3b, 0x50, 0xc9, 0xfe, 0x78, 0x75, 0xa8, 0xfc, 0x2a,
	0x41, 0x8e, 0xd0, 0x25, 0xc6, 0xb0, 0x37, 0xa1, 0x8b, 0x09, 0x6f, 0xf9, 0x0a, 0xe1, 0x67, 0x6c,
	0x02, 0x1a, 0xf9, 0x63, 0xb6, 0x88, 0x3d, 0x3a, 0x1d, 0x87, 0x91, 0x1f, 0x4f, 0x66, 0xbc, 0xb5,
	0xd2, 0xc6, 0x48, 0xda, 0x9c, 0xa6, 0x9d, 0xb3, 0xc8, 0xc1, 0xe8, 0xcd, 0x00, 0xbe, 0x07, 0x30,
	0x63, 0x23, 0x9f, 0x7a, 0xc9, 0x43, 0xe0, 0x2d, 0x96, 0xd4, 0x0f, 0x52, 0x26, 0x84, 0x2e, 0xad,
	0x84, 0xe3, 0xbe, 0x9c, 0x33, 0x72, 0x79, 0x76, 0x7e, 0xac, 0xfc, 0x92, 0x85, 0x3c, 0xaf, 0xfb,
	0x6d, 0x17, 0x39, 0x85, 0xca, 0x90, 0x06, 0x61, 0xe0, 0x0f, 0xe9, 0xd4, 0xff, 0x91, 0xc6, 0x7e,
	0x18, 0xac, 0x99, 0xae, 0x8a, 0xbe, 0x95, 0x32, 0xe5, 0x85, 0xb5, 0x52, 0xaa, 0xff, 0x72, 0x1c,
	0x0e, 0xb7, 0x41, 0xf8, 0x5b, 0x28, 0xcc, 0x58, 0xf4, 0x7c, 0xca, 0xbc, 0x38, 0x62, 0x8c, 0x3f,
	0xbb, 0xcd, 0x9a, 0xb9, 0xbd, 0xc5, 0x69, 0x6e, 0xc4, 0x18, 0x81, 0xd9, 0xbf, 0xe7, 0xca, 0x0c,
	0xf2, 0x7c, 0x13, 0x84, 0x63, 0xf9, 0x62, 0xcb, 0x58, 0x8a, 0x9b, 0x6d, 0x7f, 0x06, 0xa5, 0xef,
	0xfd, 0x29, 0xf3, 0xd8, 0x8b, 0x98, 0x05, 0x0b, 0x3f, 0x0c, 0x78, 0xab, 0x97, 0x49, 0x31, 0x89,
	0xea, 0xe7, 0xc1, 0xca, 0x6f, 0x12, 0xec, 0xbf, 0x5e, 0x9f, 0xff, 0x9b, 0xf1, 0xfe, 0xce, 0x41,
	0x17, 0x2f, 0x9a, 0xdc, 0xc7, 0x9b, 0x93, 0x2b, 0xae, 0x4f, 0xa6, 0x46, 0xa0, 0xb8, 0xb6, 0xf4,
	0x6c, 0x81, 0x35, 0x28, 0x0d, 0x57, 0x01, 0x6f, 0xc2, 0x23, 0x65, 0xa9, 0x9a, 0xbb, 0x51, 0x50,
	0x2b, 0xdb, 0x5f, 0x15, 0x52, 0x1c, 0xae, 0x5b, 0xd4, 0x1f, 0xc1, 0x41, 0x6a, 0x81, 0x70, 0x15,
	0x3e, 0x6c, 0x9b, 0x86, 0xde, 0x77, 0x3d, 0xad, 0x6b, 0xf4, 0x88, 0xe9, 0x1e, 0x5b, 0xde, 0x23,
	0xbb, 0xef, 0xe8, 0x2d, 0xb3, 0x63, 0xea, 0x6d, 0x94, 0x11, 0x32, 0x9a, 0x5d, 0xed, 0xa1, 0xae,
	0x36, 0x3d, 0xf5, 0xee, 0x57, 0x48, 0xaa, 0xff, 0x99, 0x83, 0x2b, 0xeb, 0x8b, 0x8f, 0x65, 0xa8,
	0x10, 0xed, 0xb1, 0x67, 0xe9, 0x6d, 0x53, 0xf3, 0xdc, 0xef, 0x1c, 0x3d, 0x65, 0xf9, 0x11, 0x1c,
	0xa6, 0x70, 0x57, 0x7f, 0xe2, 0x7a, 0x4e, 0x57, 0x33, 0x6d, 0x24, 0xe1, 0xeb, 0x70, 0x35, 0x05,
	0x3f, 0xe8, 0xf7, 0x6c, 0x94, 0xc5, 0xd7, 0x00, 0xa7, 0x80, 0x56, 0x7f, 0x80, 0x72, 0x82, 0xf8,
	0x13, 0xab, 0x8b, 0xf6, 0x04, 0x71, 0xa7, 0xdd, 0x41, 0x79, 0x41, 0x02, 0xd7, 0xec, 0x74, 0x10,
	0x12, 0x08, 0x1e, 0x38, 0x06, 0x7a, 0x57, 0x64, 0x64, 0x1b, 0x08, 0x0b, 0xe2, 0xfd, 0x81, 0x81,
	0xae, 0x0a, 0x12, 0x3c, 0xd6, 0x9b, 0x0e, 0x7a, 0x4f, 0x00, 0x68, 0x03, 0xb3, 0x83, 0xde, 0x17,
	0x38, 0x19, 0x66, 0x07, 0x5d, 0x13, 0x09, 0x92, 0xd4, 0xd7, 0x05, 0x80, 0xe5, 0xe8, 0x06, 0xaa,
	0x0a, 0x9c, 0x2c, 0xe7, 0x0e, 0xfa, 0x44, 0x5c, 0x93, 0x85, 0x6a, 0x02, 0x41, 0xcf, 0x30, 0xd0,
	0xa7, 0xf5, 0x9f, 0x24, 0x90, 0x2f, 0xfe, 0x34, 0xe0, 0xdb, 0x70, 0xd3, 0x20, 0x9a, 0x73, 0xec,
	0xb5, 0x34, 0xbb, 0x67, 0x9b, 0x2d, 0xad, 0x6b, 0x3e, 0xd5, 0x5c, 0xb3, 0x67, 0x6f, 0xdd, 0x26,
	0x05, 0xea, 0xbb, 0x15, 0xa4, 0x6d, 0x6b, 0xea, 0xed, 0xa3, 0xbb, 0x48, 0xaa, 0x7f, 0x03, 0x07,
	0xa9, 0xef, 0x07, 0xfe, 0x1c, 0x6a, 0x2b, 0x0b, 0x4b, 0x27, 0x0f, 0xbb, 0xba, 0xe7, 0x12, 0x5d,
	0xf7, 0xec, 0x9e, 0x9d, 0xda, 0xb2, 0x66, 0xe7, 0xf7, 0x53, 0x59, 0x7a, 0x75, 0x2a, 0x4b, 0x7f,
	0x9f, 0xca, 0xd2, 0xcf, 0x67, 0x72, 0xe6, 0xd5, 0x99, 0x9c, 0xf9, 0xeb, 0x4c, 0xce, 0x3c, 0xbd,
	0x39, 0xf6, 0xe3, 0xc9, 0x0f, 0xcf, 0x94, 0x61, 0x38, 0x6b, 0xf0, 0x97, 0xe7, 0x56, 0xc0, 0xe2,
	0x65, 0x18, 0x3d, 0x7f, 0xfd, 0x6f, 0xca, 0x46, 0x63, 0x16, 0x35, 0x5e, 0xf0, 0x6b, 0xf7, 0xd9,
	0x25, 0x7e, 0xdd, 0x7e, 0xf9, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xce, 0x99, 0x58, 0xe9, 0x8b,
	0x07, 0x00, 0x00,
}

func (m *ContentHash) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContentHash) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContentHash) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GraphV2 != nil {
		{
			size, err := m.GraphV2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.RawV2 != nil {
		{
			size, err := m.RawV2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Graph != nil {
		{
			size, err := m.Graph.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Raw != nil {
		{
			size, err := m.Raw.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ContentHash_Raw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContentHash_Raw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContentHash_Raw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MediaType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MediaType))
		i--
		dAtA[i] = 0x18
	}
	if m.DigestAlgorithm != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DigestAlgorithm))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ContentHash_Graph) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContentHash_Graph) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContentHash_Graph) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MerkleTree != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MerkleTree))
		i--
		dAtA[i] = 0x20
	}
	if m.CanonicalizationAlgorithm != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CanonicalizationAlgorithm))
		i--
		dAtA[i] = 0x18
	}
	if m.DigestAlgorithm != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DigestAlgorithm))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ContentHash_RawV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContentHash_RawV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContentHash_RawV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FileExtension) > 0 {
		i -= len(m.FileExtension)
		copy(dAtA[i:], m.FileExtension)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.FileExtension)))
		i--
		dAtA[i] = 0x1a
	}
	if m.DigestAlgorithm != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DigestAlgorithm))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ContentHash_GraphV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContentHash_GraphV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContentHash_GraphV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MerkleTree != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MerkleTree))
		i--
		dAtA[i] = 0x20
	}
	if m.CanonicalizationAlgorithm != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CanonicalizationAlgorithm))
		i--
		dAtA[i] = 0x18
	}
	if m.DigestAlgorithm != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DigestAlgorithm))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ContentHashes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContentHashes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContentHashes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ContentHashes) > 0 {
		for iNdEx := len(m.ContentHashes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ContentHashes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ContentHash) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Raw != nil {
		l = m.Raw.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Graph != nil {
		l = m.Graph.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RawV2 != nil {
		l = m.RawV2.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.GraphV2 != nil {
		l = m.GraphV2.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ContentHash_Raw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DigestAlgorithm != 0 {
		n += 1 + sovTypes(uint64(m.DigestAlgorithm))
	}
	if m.MediaType != 0 {
		n += 1 + sovTypes(uint64(m.MediaType))
	}
	return n
}

func (m *ContentHash_Graph) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DigestAlgorithm != 0 {
		n += 1 + sovTypes(uint64(m.DigestAlgorithm))
	}
	if m.CanonicalizationAlgorithm != 0 {
		n += 1 + sovTypes(uint64(m.CanonicalizationAlgorithm))
	}
	if m.MerkleTree != 0 {
		n += 1 + sovTypes(uint64(m.MerkleTree))
	}
	return n
}

func (m *ContentHash_RawV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DigestAlgorithm != 0 {
		n += 1 + sovTypes(uint64(m.DigestAlgorithm))
	}
	l = len(m.FileExtension)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ContentHash_GraphV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DigestAlgorithm != 0 {
		n += 1 + sovTypes(uint64(m.DigestAlgorithm))
	}
	if m.CanonicalizationAlgorithm != 0 {
		n += 1 + sovTypes(uint64(m.CanonicalizationAlgorithm))
	}
	if m.MerkleTree != 0 {
		n += 1 + sovTypes(uint64(m.MerkleTree))
	}
	return n
}

func (m *ContentHashes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ContentHashes) > 0 {
		for _, e := range m.ContentHashes {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ContentHash) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContentHash: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContentHash: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Raw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Raw == nil {
				m.Raw = &ContentHash_Raw{}
			}
			if err := m.Raw.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Graph", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Graph == nil {
				m.Graph = &ContentHash_Graph{}
			}
			if err := m.Graph.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawV2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RawV2 == nil {
				m.RawV2 = &ContentHash_RawV2{}
			}
			if err := m.RawV2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GraphV2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GraphV2 == nil {
				m.GraphV2 = &ContentHash_GraphV2{}
			}
			if err := m.GraphV2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContentHash_Raw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Raw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Raw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = append(m.Hash[:0], dAtA[iNdEx:postIndex]...)
			if m.Hash == nil {
				m.Hash = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DigestAlgorithm", wireType)
			}
			m.DigestAlgorithm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DigestAlgorithm |= DigestAlgorithm(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaType", wireType)
			}
			m.MediaType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MediaType |= RawMediaType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContentHash_Graph) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Graph: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Graph: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = append(m.Hash[:0], dAtA[iNdEx:postIndex]...)
			if m.Hash == nil {
				m.Hash = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DigestAlgorithm", wireType)
			}
			m.DigestAlgorithm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DigestAlgorithm |= DigestAlgorithm(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanonicalizationAlgorithm", wireType)
			}
			m.CanonicalizationAlgorithm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CanonicalizationAlgorithm |= GraphCanonicalizationAlgorithm(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerkleTree", wireType)
			}
			m.MerkleTree = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MerkleTree |= GraphMerkleTree(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContentHash_RawV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = append(m.Hash[:0], dAtA[iNdEx:postIndex]...)
			if m.Hash == nil {
				m.Hash = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DigestAlgorithm", wireType)
			}
			m.DigestAlgorithm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DigestAlgorithm |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileExtension", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileExtension = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContentHash_GraphV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GraphV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GraphV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = append(m.Hash[:0], dAtA[iNdEx:postIndex]...)
			if m.Hash == nil {
				m.Hash = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DigestAlgorithm", wireType)
			}
			m.DigestAlgorithm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DigestAlgorithm |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanonicalizationAlgorithm", wireType)
			}
			m.CanonicalizationAlgorithm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CanonicalizationAlgorithm |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerkleTree", wireType)
			}
			m.MerkleTree = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MerkleTree |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContentHashes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContentHashes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContentHashes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentHashes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentHashes = append(m.ContentHashes, &ContentHash{})
			if err := m.ContentHashes[len(m.ContentHashes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
