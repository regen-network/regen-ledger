// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: regen/data/v1/query.proto

package data

import (
	context "context"
	fmt "fmt"
	query "github.com/cosmos/cosmos-sdk/types/query"
	grpc1 "github.com/gogo/protobuf/grpc"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// QueryAnchorByIRIRequest is the Query/AnchorByIRI request type.
type QueryAnchorByIRIRequest struct {
	// iri is the IRI of the anchored data.
	Iri string `protobuf:"bytes,1,opt,name=iri,proto3" json:"iri,omitempty"`
}

func (m *QueryAnchorByIRIRequest) Reset()         { *m = QueryAnchorByIRIRequest{} }
func (m *QueryAnchorByIRIRequest) String() string { return proto.CompactTextString(m) }
func (*QueryAnchorByIRIRequest) ProtoMessage()    {}
func (*QueryAnchorByIRIRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{0}
}
func (m *QueryAnchorByIRIRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryAnchorByIRIRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryAnchorByIRIRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryAnchorByIRIRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryAnchorByIRIRequest.Merge(m, src)
}
func (m *QueryAnchorByIRIRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryAnchorByIRIRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryAnchorByIRIRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryAnchorByIRIRequest proto.InternalMessageInfo

func (m *QueryAnchorByIRIRequest) GetIri() string {
	if m != nil {
		return m.Iri
	}
	return ""
}

// QueryAnchorByIRIResponse is the Query/AnchorByIRI response type.
type QueryAnchorByIRIResponse struct {
	// anchor is the anchored data entry.
	Anchor *AnchorEntry `protobuf:"bytes,1,opt,name=anchor,proto3" json:"anchor,omitempty"`
}

func (m *QueryAnchorByIRIResponse) Reset()         { *m = QueryAnchorByIRIResponse{} }
func (m *QueryAnchorByIRIResponse) String() string { return proto.CompactTextString(m) }
func (*QueryAnchorByIRIResponse) ProtoMessage()    {}
func (*QueryAnchorByIRIResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{1}
}
func (m *QueryAnchorByIRIResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryAnchorByIRIResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryAnchorByIRIResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryAnchorByIRIResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryAnchorByIRIResponse.Merge(m, src)
}
func (m *QueryAnchorByIRIResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryAnchorByIRIResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryAnchorByIRIResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryAnchorByIRIResponse proto.InternalMessageInfo

func (m *QueryAnchorByIRIResponse) GetAnchor() *AnchorEntry {
	if m != nil {
		return m.Anchor
	}
	return nil
}

// QueryAnchorByHashRequest is the Query/AnchorByHash request type.
type QueryAnchorByHashRequest struct {
	// content_hash is the ContentHash of the anchored data.
	ContentHash *ContentHash `protobuf:"bytes,1,opt,name=content_hash,json=contentHash,proto3" json:"content_hash,omitempty"`
}

func (m *QueryAnchorByHashRequest) Reset()         { *m = QueryAnchorByHashRequest{} }
func (m *QueryAnchorByHashRequest) String() string { return proto.CompactTextString(m) }
func (*QueryAnchorByHashRequest) ProtoMessage()    {}
func (*QueryAnchorByHashRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{2}
}
func (m *QueryAnchorByHashRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryAnchorByHashRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryAnchorByHashRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryAnchorByHashRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryAnchorByHashRequest.Merge(m, src)
}
func (m *QueryAnchorByHashRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryAnchorByHashRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryAnchorByHashRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryAnchorByHashRequest proto.InternalMessageInfo

func (m *QueryAnchorByHashRequest) GetContentHash() *ContentHash {
	if m != nil {
		return m.ContentHash
	}
	return nil
}

// QueryAnchorByHashResponse is the Query/AnchorByHash response type.
type QueryAnchorByHashResponse struct {
	// anchor is the anchored data entry.
	Anchor *AnchorEntry `protobuf:"bytes,1,opt,name=anchor,proto3" json:"anchor,omitempty"`
}

func (m *QueryAnchorByHashResponse) Reset()         { *m = QueryAnchorByHashResponse{} }
func (m *QueryAnchorByHashResponse) String() string { return proto.CompactTextString(m) }
func (*QueryAnchorByHashResponse) ProtoMessage()    {}
func (*QueryAnchorByHashResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{3}
}
func (m *QueryAnchorByHashResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryAnchorByHashResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryAnchorByHashResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryAnchorByHashResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryAnchorByHashResponse.Merge(m, src)
}
func (m *QueryAnchorByHashResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryAnchorByHashResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryAnchorByHashResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryAnchorByHashResponse proto.InternalMessageInfo

func (m *QueryAnchorByHashResponse) GetAnchor() *AnchorEntry {
	if m != nil {
		return m.Anchor
	}
	return nil
}

// QueryAnchorsByAttestorRequest is the Query/AnchorsByAttestor request type.
type QueryAnchorsByAttestorRequest struct {
	// attestor is the address of the attestor.
	Attestor string `protobuf:"bytes,1,opt,name=attestor,proto3" json:"attestor,omitempty"`
	// pagination is the PageRequest to use for pagination.
	Pagination *query.PageRequest `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryAnchorsByAttestorRequest) Reset()         { *m = QueryAnchorsByAttestorRequest{} }
func (m *QueryAnchorsByAttestorRequest) String() string { return proto.CompactTextString(m) }
func (*QueryAnchorsByAttestorRequest) ProtoMessage()    {}
func (*QueryAnchorsByAttestorRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{4}
}
func (m *QueryAnchorsByAttestorRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryAnchorsByAttestorRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryAnchorsByAttestorRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryAnchorsByAttestorRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryAnchorsByAttestorRequest.Merge(m, src)
}
func (m *QueryAnchorsByAttestorRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryAnchorsByAttestorRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryAnchorsByAttestorRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryAnchorsByAttestorRequest proto.InternalMessageInfo

func (m *QueryAnchorsByAttestorRequest) GetAttestor() string {
	if m != nil {
		return m.Attestor
	}
	return ""
}

func (m *QueryAnchorsByAttestorRequest) GetPagination() *query.PageRequest {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QueryAnchorsByAttestorResponse is the Query/AnchorsByAttestor response type.
type QueryAnchorsByAttestorResponse struct {
	// anchors are the anchored data entries.
	Anchors []*AnchorEntry `protobuf:"bytes,1,rep,name=anchors,proto3" json:"anchors,omitempty"`
	// pagination is the pagination PageResponse.
	Pagination *query.PageResponse `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryAnchorsByAttestorResponse) Reset()         { *m = QueryAnchorsByAttestorResponse{} }
func (m *QueryAnchorsByAttestorResponse) String() string { return proto.CompactTextString(m) }
func (*QueryAnchorsByAttestorResponse) ProtoMessage()    {}
func (*QueryAnchorsByAttestorResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{5}
}
func (m *QueryAnchorsByAttestorResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryAnchorsByAttestorResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryAnchorsByAttestorResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryAnchorsByAttestorResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryAnchorsByAttestorResponse.Merge(m, src)
}
func (m *QueryAnchorsByAttestorResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryAnchorsByAttestorResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryAnchorsByAttestorResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryAnchorsByAttestorResponse proto.InternalMessageInfo

func (m *QueryAnchorsByAttestorResponse) GetAnchors() []*AnchorEntry {
	if m != nil {
		return m.Anchors
	}
	return nil
}

func (m *QueryAnchorsByAttestorResponse) GetPagination() *query.PageResponse {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QueryAttestorsByIRIRequest is the Query/AttestorsByIRI request type.
type QueryAttestorsByIRIRequest struct {
	// iri is the IRI of the anchored data.
	Iri string `protobuf:"bytes,1,opt,name=iri,proto3" json:"iri,omitempty"`
	// pagination is the PageRequest to use for pagination.
	Pagination *query.PageRequest `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryAttestorsByIRIRequest) Reset()         { *m = QueryAttestorsByIRIRequest{} }
func (m *QueryAttestorsByIRIRequest) String() string { return proto.CompactTextString(m) }
func (*QueryAttestorsByIRIRequest) ProtoMessage()    {}
func (*QueryAttestorsByIRIRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{6}
}
func (m *QueryAttestorsByIRIRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryAttestorsByIRIRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryAttestorsByIRIRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryAttestorsByIRIRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryAttestorsByIRIRequest.Merge(m, src)
}
func (m *QueryAttestorsByIRIRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryAttestorsByIRIRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryAttestorsByIRIRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryAttestorsByIRIRequest proto.InternalMessageInfo

func (m *QueryAttestorsByIRIRequest) GetIri() string {
	if m != nil {
		return m.Iri
	}
	return ""
}

func (m *QueryAttestorsByIRIRequest) GetPagination() *query.PageRequest {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QueryAttestorsByIRIResponse is the Query/AttestorsByIRI response type.
type QueryAttestorsByIRIResponse struct {
	// attestors are the attestor entries.
	Attestors []*AttestorEntry `protobuf:"bytes,1,rep,name=attestors,proto3" json:"attestors,omitempty"`
	// pagination is the pagination PageResponse.
	Pagination *query.PageResponse `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryAttestorsByIRIResponse) Reset()         { *m = QueryAttestorsByIRIResponse{} }
func (m *QueryAttestorsByIRIResponse) String() string { return proto.CompactTextString(m) }
func (*QueryAttestorsByIRIResponse) ProtoMessage()    {}
func (*QueryAttestorsByIRIResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{7}
}
func (m *QueryAttestorsByIRIResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryAttestorsByIRIResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryAttestorsByIRIResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryAttestorsByIRIResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryAttestorsByIRIResponse.Merge(m, src)
}
func (m *QueryAttestorsByIRIResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryAttestorsByIRIResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryAttestorsByIRIResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryAttestorsByIRIResponse proto.InternalMessageInfo

func (m *QueryAttestorsByIRIResponse) GetAttestors() []*AttestorEntry {
	if m != nil {
		return m.Attestors
	}
	return nil
}

func (m *QueryAttestorsByIRIResponse) GetPagination() *query.PageResponse {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QueryAttestorsByHashRequest is the Query/AttestorsByHash request type.
type QueryAttestorsByHashRequest struct {
	// content_hash is the ContentHash of the anchored data.
	ContentHash *ContentHash `protobuf:"bytes,1,opt,name=content_hash,json=contentHash,proto3" json:"content_hash,omitempty"`
	// pagination is the PageRequest to use for pagination.
	Pagination *query.PageRequest `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryAttestorsByHashRequest) Reset()         { *m = QueryAttestorsByHashRequest{} }
func (m *QueryAttestorsByHashRequest) String() string { return proto.CompactTextString(m) }
func (*QueryAttestorsByHashRequest) ProtoMessage()    {}
func (*QueryAttestorsByHashRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{8}
}
func (m *QueryAttestorsByHashRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryAttestorsByHashRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryAttestorsByHashRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryAttestorsByHashRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryAttestorsByHashRequest.Merge(m, src)
}
func (m *QueryAttestorsByHashRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryAttestorsByHashRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryAttestorsByHashRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryAttestorsByHashRequest proto.InternalMessageInfo

func (m *QueryAttestorsByHashRequest) GetContentHash() *ContentHash {
	if m != nil {
		return m.ContentHash
	}
	return nil
}

func (m *QueryAttestorsByHashRequest) GetPagination() *query.PageRequest {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QueryAttestorsByHashResponse is the Query/AttestorsByHash response type.
type QueryAttestorsByHashResponse struct {
	// attestors are the attestor entries.
	Attestors []*AttestorEntry `protobuf:"bytes,1,rep,name=attestors,proto3" json:"attestors,omitempty"`
	// pagination is the pagination PageResponse.
	Pagination *query.PageResponse `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryAttestorsByHashResponse) Reset()         { *m = QueryAttestorsByHashResponse{} }
func (m *QueryAttestorsByHashResponse) String() string { return proto.CompactTextString(m) }
func (*QueryAttestorsByHashResponse) ProtoMessage()    {}
func (*QueryAttestorsByHashResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{9}
}
func (m *QueryAttestorsByHashResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryAttestorsByHashResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryAttestorsByHashResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryAttestorsByHashResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryAttestorsByHashResponse.Merge(m, src)
}
func (m *QueryAttestorsByHashResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryAttestorsByHashResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryAttestorsByHashResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryAttestorsByHashResponse proto.InternalMessageInfo

func (m *QueryAttestorsByHashResponse) GetAttestors() []*AttestorEntry {
	if m != nil {
		return m.Attestors
	}
	return nil
}

func (m *QueryAttestorsByHashResponse) GetPagination() *query.PageResponse {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QueryResolverRequest is the Query/Resolver request type.
type QueryResolverRequest struct {
	// id is the ID of the resolver.
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *QueryResolverRequest) Reset()         { *m = QueryResolverRequest{} }
func (m *QueryResolverRequest) String() string { return proto.CompactTextString(m) }
func (*QueryResolverRequest) ProtoMessage()    {}
func (*QueryResolverRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{10}
}
func (m *QueryResolverRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryResolverRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryResolverRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryResolverRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryResolverRequest.Merge(m, src)
}
func (m *QueryResolverRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryResolverRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryResolverRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryResolverRequest proto.InternalMessageInfo

func (m *QueryResolverRequest) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

// QueryResolverResponse is the Query/Resolver response type.
type QueryResolverResponse struct {
	// resolver is the fetched resolver.
	Resolver *ResolverInfo `protobuf:"bytes,1,opt,name=resolver,proto3" json:"resolver,omitempty"`
}

func (m *QueryResolverResponse) Reset()         { *m = QueryResolverResponse{} }
func (m *QueryResolverResponse) String() string { return proto.CompactTextString(m) }
func (*QueryResolverResponse) ProtoMessage()    {}
func (*QueryResolverResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{11}
}
func (m *QueryResolverResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryResolverResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryResolverResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryResolverResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryResolverResponse.Merge(m, src)
}
func (m *QueryResolverResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryResolverResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryResolverResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryResolverResponse proto.InternalMessageInfo

func (m *QueryResolverResponse) GetResolver() *ResolverInfo {
	if m != nil {
		return m.Resolver
	}
	return nil
}

// QueryResolversByIRIRequest is the Query/ResolversByIRI request type.
type QueryResolversByIRIRequest struct {
	// iri is the IRI of the anchored data.
	Iri string `protobuf:"bytes,1,opt,name=iri,proto3" json:"iri,omitempty"`
	// pagination is the PageRequest to use for pagination.
	Pagination *query.PageRequest `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryResolversByIRIRequest) Reset()         { *m = QueryResolversByIRIRequest{} }
func (m *QueryResolversByIRIRequest) String() string { return proto.CompactTextString(m) }
func (*QueryResolversByIRIRequest) ProtoMessage()    {}
func (*QueryResolversByIRIRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{12}
}
func (m *QueryResolversByIRIRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryResolversByIRIRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryResolversByIRIRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryResolversByIRIRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryResolversByIRIRequest.Merge(m, src)
}
func (m *QueryResolversByIRIRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryResolversByIRIRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryResolversByIRIRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryResolversByIRIRequest proto.InternalMessageInfo

func (m *QueryResolversByIRIRequest) GetIri() string {
	if m != nil {
		return m.Iri
	}
	return ""
}

func (m *QueryResolversByIRIRequest) GetPagination() *query.PageRequest {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QueryResolversByIRIResponse is the Query/ResolversByIRI response type.
type QueryResolversByIRIResponse struct {
	// resolvers are the resolvers that have registered the anchored data.
	Resolvers []*ResolverInfo `protobuf:"bytes,1,rep,name=resolvers,proto3" json:"resolvers,omitempty"`
	// pagination is the PageResponse to use for pagination.
	Pagination *query.PageResponse `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryResolversByIRIResponse) Reset()         { *m = QueryResolversByIRIResponse{} }
func (m *QueryResolversByIRIResponse) String() string { return proto.CompactTextString(m) }
func (*QueryResolversByIRIResponse) ProtoMessage()    {}
func (*QueryResolversByIRIResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{13}
}
func (m *QueryResolversByIRIResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryResolversByIRIResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryResolversByIRIResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryResolversByIRIResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryResolversByIRIResponse.Merge(m, src)
}
func (m *QueryResolversByIRIResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryResolversByIRIResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryResolversByIRIResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryResolversByIRIResponse proto.InternalMessageInfo

func (m *QueryResolversByIRIResponse) GetResolvers() []*ResolverInfo {
	if m != nil {
		return m.Resolvers
	}
	return nil
}

func (m *QueryResolversByIRIResponse) GetPagination() *query.PageResponse {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QueryResolversByHashRequest is the Query/ResolversByHash request type.
type QueryResolversByHashRequest struct {
	// content_hash is the ContentHash of the anchored data.
	ContentHash *ContentHash `protobuf:"bytes,1,opt,name=content_hash,json=contentHash,proto3" json:"content_hash,omitempty"`
	// pagination is the PageRequest to use for pagination.
	Pagination *query.PageRequest `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryResolversByHashRequest) Reset()         { *m = QueryResolversByHashRequest{} }
func (m *QueryResolversByHashRequest) String() string { return proto.CompactTextString(m) }
func (*QueryResolversByHashRequest) ProtoMessage()    {}
func (*QueryResolversByHashRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{14}
}
func (m *QueryResolversByHashRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryResolversByHashRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryResolversByHashRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryResolversByHashRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryResolversByHashRequest.Merge(m, src)
}
func (m *QueryResolversByHashRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryResolversByHashRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryResolversByHashRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryResolversByHashRequest proto.InternalMessageInfo

func (m *QueryResolversByHashRequest) GetContentHash() *ContentHash {
	if m != nil {
		return m.ContentHash
	}
	return nil
}

func (m *QueryResolversByHashRequest) GetPagination() *query.PageRequest {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QueryResolversByHashResponse is the Query/ResolversByHash response type.
type QueryResolversByHashResponse struct {
	// resolvers are the resolvers that have registered the data.
	Resolvers []*ResolverInfo `protobuf:"bytes,1,rep,name=resolvers,proto3" json:"resolvers,omitempty"`
	// pagination is the PageResponse to use for pagination.
	Pagination *query.PageResponse `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryResolversByHashResponse) Reset()         { *m = QueryResolversByHashResponse{} }
func (m *QueryResolversByHashResponse) String() string { return proto.CompactTextString(m) }
func (*QueryResolversByHashResponse) ProtoMessage()    {}
func (*QueryResolversByHashResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{15}
}
func (m *QueryResolversByHashResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryResolversByHashResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryResolversByHashResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryResolversByHashResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryResolversByHashResponse.Merge(m, src)
}
func (m *QueryResolversByHashResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryResolversByHashResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryResolversByHashResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryResolversByHashResponse proto.InternalMessageInfo

func (m *QueryResolversByHashResponse) GetResolvers() []*ResolverInfo {
	if m != nil {
		return m.Resolvers
	}
	return nil
}

func (m *QueryResolversByHashResponse) GetPagination() *query.PageResponse {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QueryResolversByURLRequest is the Query/Resolver request type.
type QueryResolversByURLRequest struct {
	// url is the URL of the resolver.
	Url string `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	// pagination is the PageRequest to use for pagination.
	Pagination *query.PageRequest `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryResolversByURLRequest) Reset()         { *m = QueryResolversByURLRequest{} }
func (m *QueryResolversByURLRequest) String() string { return proto.CompactTextString(m) }
func (*QueryResolversByURLRequest) ProtoMessage()    {}
func (*QueryResolversByURLRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{16}
}
func (m *QueryResolversByURLRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryResolversByURLRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryResolversByURLRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryResolversByURLRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryResolversByURLRequest.Merge(m, src)
}
func (m *QueryResolversByURLRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryResolversByURLRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryResolversByURLRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryResolversByURLRequest proto.InternalMessageInfo

func (m *QueryResolversByURLRequest) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *QueryResolversByURLRequest) GetPagination() *query.PageRequest {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QueryResolversByURLResponse is the Query/Resolver response type.
type QueryResolversByURLResponse struct {
	// resolvers are the fetched resolvers.
	Resolvers []*ResolverInfo `protobuf:"bytes,1,rep,name=resolvers,proto3" json:"resolvers,omitempty"`
	// pagination is the PageResponse to use for pagination.
	Pagination *query.PageResponse `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryResolversByURLResponse) Reset()         { *m = QueryResolversByURLResponse{} }
func (m *QueryResolversByURLResponse) String() string { return proto.CompactTextString(m) }
func (*QueryResolversByURLResponse) ProtoMessage()    {}
func (*QueryResolversByURLResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{17}
}
func (m *QueryResolversByURLResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryResolversByURLResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryResolversByURLResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryResolversByURLResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryResolversByURLResponse.Merge(m, src)
}
func (m *QueryResolversByURLResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryResolversByURLResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryResolversByURLResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryResolversByURLResponse proto.InternalMessageInfo

func (m *QueryResolversByURLResponse) GetResolvers() []*ResolverInfo {
	if m != nil {
		return m.Resolvers
	}
	return nil
}

func (m *QueryResolversByURLResponse) GetPagination() *query.PageResponse {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// ConvertIRIToHashRequest is the Query/ConvertIRIToHash request type.
type ConvertIRIToHashRequest struct {
	// iri is the IRI to convert to a ContentHash.
	Iri string `protobuf:"bytes,1,opt,name=iri,proto3" json:"iri,omitempty"`
}

func (m *ConvertIRIToHashRequest) Reset()         { *m = ConvertIRIToHashRequest{} }
func (m *ConvertIRIToHashRequest) String() string { return proto.CompactTextString(m) }
func (*ConvertIRIToHashRequest) ProtoMessage()    {}
func (*ConvertIRIToHashRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{18}
}
func (m *ConvertIRIToHashRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConvertIRIToHashRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConvertIRIToHashRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConvertIRIToHashRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConvertIRIToHashRequest.Merge(m, src)
}
func (m *ConvertIRIToHashRequest) XXX_Size() int {
	return m.Size()
}
func (m *ConvertIRIToHashRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ConvertIRIToHashRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ConvertIRIToHashRequest proto.InternalMessageInfo

func (m *ConvertIRIToHashRequest) GetIri() string {
	if m != nil {
		return m.Iri
	}
	return ""
}

// ConvertIRIToHashResponse is the Query/ConvertIRIToHash response type.
type ConvertIRIToHashResponse struct {
	// content_hash is the ContentHash converted from the IRI.
	ContentHash *ContentHash `protobuf:"bytes,1,opt,name=content_hash,json=contentHash,proto3" json:"content_hash,omitempty"`
}

func (m *ConvertIRIToHashResponse) Reset()         { *m = ConvertIRIToHashResponse{} }
func (m *ConvertIRIToHashResponse) String() string { return proto.CompactTextString(m) }
func (*ConvertIRIToHashResponse) ProtoMessage()    {}
func (*ConvertIRIToHashResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{19}
}
func (m *ConvertIRIToHashResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConvertIRIToHashResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConvertIRIToHashResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConvertIRIToHashResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConvertIRIToHashResponse.Merge(m, src)
}
func (m *ConvertIRIToHashResponse) XXX_Size() int {
	return m.Size()
}
func (m *ConvertIRIToHashResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ConvertIRIToHashResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ConvertIRIToHashResponse proto.InternalMessageInfo

func (m *ConvertIRIToHashResponse) GetContentHash() *ContentHash {
	if m != nil {
		return m.ContentHash
	}
	return nil
}

// ConvertHashToIRIRequest is the Query/ConvertHashToIRI request type.
type ConvertHashToIRIRequest struct {
	// content_hash is the ContentHash to convert to an IRI.
	ContentHash *ContentHash `protobuf:"bytes,1,opt,name=content_hash,json=contentHash,proto3" json:"content_hash,omitempty"`
}

func (m *ConvertHashToIRIRequest) Reset()         { *m = ConvertHashToIRIRequest{} }
func (m *ConvertHashToIRIRequest) String() string { return proto.CompactTextString(m) }
func (*ConvertHashToIRIRequest) ProtoMessage()    {}
func (*ConvertHashToIRIRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{20}
}
func (m *ConvertHashToIRIRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConvertHashToIRIRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConvertHashToIRIRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConvertHashToIRIRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConvertHashToIRIRequest.Merge(m, src)
}
func (m *ConvertHashToIRIRequest) XXX_Size() int {
	return m.Size()
}
func (m *ConvertHashToIRIRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ConvertHashToIRIRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ConvertHashToIRIRequest proto.InternalMessageInfo

func (m *ConvertHashToIRIRequest) GetContentHash() *ContentHash {
	if m != nil {
		return m.ContentHash
	}
	return nil
}

// ConvertHashToIRIResponse is the Query/ConvertHashToIRI response type.
type ConvertHashToIRIResponse struct {
	// iri is the IRI converted from the ContentHash.
	Iri string `protobuf:"bytes,1,opt,name=iri,proto3" json:"iri,omitempty"`
}

func (m *ConvertHashToIRIResponse) Reset()         { *m = ConvertHashToIRIResponse{} }
func (m *ConvertHashToIRIResponse) String() string { return proto.CompactTextString(m) }
func (*ConvertHashToIRIResponse) ProtoMessage()    {}
func (*ConvertHashToIRIResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{21}
}
func (m *ConvertHashToIRIResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConvertHashToIRIResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConvertHashToIRIResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConvertHashToIRIResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConvertHashToIRIResponse.Merge(m, src)
}
func (m *ConvertHashToIRIResponse) XXX_Size() int {
	return m.Size()
}
func (m *ConvertHashToIRIResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ConvertHashToIRIResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ConvertHashToIRIResponse proto.InternalMessageInfo

func (m *ConvertHashToIRIResponse) GetIri() string {
	if m != nil {
		return m.Iri
	}
	return ""
}

// ConvertRawHashToIRIRequest is the Query/ConvertRawHashToIRI request type.
type ConvertRawHashToIRIRequest struct {
	// hash represents the hash of the data based on the digest_algorithm and must
	// be encoded as a base64 string. When hash is provided as a URL parameter,
	// all instances of "+" should also be replaced with "%2b".
	Hash string `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	// digest_algorithm represents the hash digest algorithm.
	DigestAlgorithm DigestAlgorithm `protobuf:"varint,2,opt,name=digest_algorithm,json=digestAlgorithm,proto3,enum=regen.data.v1.DigestAlgorithm" json:"digest_algorithm,omitempty"`
	// media_type represents the media type for raw data.
	MediaType RawMediaType `protobuf:"varint,3,opt,name=media_type,json=mediaType,proto3,enum=regen.data.v1.RawMediaType" json:"media_type,omitempty"`
}

func (m *ConvertRawHashToIRIRequest) Reset()         { *m = ConvertRawHashToIRIRequest{} }
func (m *ConvertRawHashToIRIRequest) String() string { return proto.CompactTextString(m) }
func (*ConvertRawHashToIRIRequest) ProtoMessage()    {}
func (*ConvertRawHashToIRIRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{22}
}
func (m *ConvertRawHashToIRIRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConvertRawHashToIRIRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConvertRawHashToIRIRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConvertRawHashToIRIRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConvertRawHashToIRIRequest.Merge(m, src)
}
func (m *ConvertRawHashToIRIRequest) XXX_Size() int {
	return m.Size()
}
func (m *ConvertRawHashToIRIRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ConvertRawHashToIRIRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ConvertRawHashToIRIRequest proto.InternalMessageInfo

func (m *ConvertRawHashToIRIRequest) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *ConvertRawHashToIRIRequest) GetDigestAlgorithm() DigestAlgorithm {
	if m != nil {
		return m.DigestAlgorithm
	}
	return DigestAlgorithm_DIGEST_ALGORITHM_UNSPECIFIED
}

func (m *ConvertRawHashToIRIRequest) GetMediaType() RawMediaType {
	if m != nil {
		return m.MediaType
	}
	return RawMediaType_RAW_MEDIA_TYPE_UNSPECIFIED
}

// ConvertRawHashToIRIResponse is the Query/ConvertRawHashToIRI response type.
type ConvertRawHashToIRIResponse struct {
	// iri is the IRI converted from ContentHash_Raw.
	Iri string `protobuf:"bytes,1,opt,name=iri,proto3" json:"iri,omitempty"`
}

func (m *ConvertRawHashToIRIResponse) Reset()         { *m = ConvertRawHashToIRIResponse{} }
func (m *ConvertRawHashToIRIResponse) String() string { return proto.CompactTextString(m) }
func (*ConvertRawHashToIRIResponse) ProtoMessage()    {}
func (*ConvertRawHashToIRIResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{23}
}
func (m *ConvertRawHashToIRIResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConvertRawHashToIRIResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConvertRawHashToIRIResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConvertRawHashToIRIResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConvertRawHashToIRIResponse.Merge(m, src)
}
func (m *ConvertRawHashToIRIResponse) XXX_Size() int {
	return m.Size()
}
func (m *ConvertRawHashToIRIResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ConvertRawHashToIRIResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ConvertRawHashToIRIResponse proto.InternalMessageInfo

func (m *ConvertRawHashToIRIResponse) GetIri() string {
	if m != nil {
		return m.Iri
	}
	return ""
}

// ConvertGraphHashToIRIRequest is the Query/ConvertGraphHashToIRI request type.
type ConvertGraphHashToIRIRequest struct {
	// hash represents the hash of the data based on the digest_algorithm and must
	// be encoded as a base64 string. When hash is provided as a URL parameter,
	// all instances of "+" should also be replaced with "%2b".
	Hash string `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	// digest_algorithm represents the hash digest algorithm.
	DigestAlgorithm DigestAlgorithm `protobuf:"varint,2,opt,name=digest_algorithm,json=digestAlgorithm,proto3,enum=regen.data.v1.DigestAlgorithm" json:"digest_algorithm,omitempty"`
	// graph_canonicalization_algorithm represents the RDF graph
	// canonicalization algorithm.
	CanonicalizationAlgorithm GraphCanonicalizationAlgorithm `protobuf:"varint,3,opt,name=canonicalization_algorithm,json=canonicalizationAlgorithm,proto3,enum=regen.data.v1.GraphCanonicalizationAlgorithm" json:"canonicalization_algorithm,omitempty"`
	// merkle_tree is the merkle tree type used for the graph hash, if any.
	MerkleTree GraphMerkleTree `protobuf:"varint,4,opt,name=merkle_tree,json=merkleTree,proto3,enum=regen.data.v1.GraphMerkleTree" json:"merkle_tree,omitempty"`
}

func (m *ConvertGraphHashToIRIRequest) Reset()         { *m = ConvertGraphHashToIRIRequest{} }
func (m *ConvertGraphHashToIRIRequest) String() string { return proto.CompactTextString(m) }
func (*ConvertGraphHashToIRIRequest) ProtoMessage()    {}
func (*ConvertGraphHashToIRIRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{24}
}
func (m *ConvertGraphHashToIRIRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConvertGraphHashToIRIRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConvertGraphHashToIRIRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConvertGraphHashToIRIRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConvertGraphHashToIRIRequest.Merge(m, src)
}
func (m *ConvertGraphHashToIRIRequest) XXX_Size() int {
	return m.Size()
}
func (m *ConvertGraphHashToIRIRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ConvertGraphHashToIRIRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ConvertGraphHashToIRIRequest proto.InternalMessageInfo

func (m *ConvertGraphHashToIRIRequest) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *ConvertGraphHashToIRIRequest) GetDigestAlgorithm() DigestAlgorithm {
	if m != nil {
		return m.DigestAlgorithm
	}
	return DigestAlgorithm_DIGEST_ALGORITHM_UNSPECIFIED
}

func (m *ConvertGraphHashToIRIRequest) GetCanonicalizationAlgorithm() GraphCanonicalizationAlgorithm {
	if m != nil {
		return m.CanonicalizationAlgorithm
	}
	return GraphCanonicalizationAlgorithm_GRAPH_CANONICALIZATION_ALGORITHM_UNSPECIFIED
}

func (m *ConvertGraphHashToIRIRequest) GetMerkleTree() GraphMerkleTree {
	if m != nil {
		return m.MerkleTree
	}
	return GraphMerkleTree_GRAPH_MERKLE_TREE_NONE_UNSPECIFIED
}

// ConvertGraphHashToIRIResponse is the Query/ConvertGraphHashToIRI response
// type.
type ConvertGraphHashToIRIResponse struct {
	// iri is the IRI converted from ContentHash_Graph.
	Iri string `protobuf:"bytes,1,opt,name=iri,proto3" json:"iri,omitempty"`
}

func (m *ConvertGraphHashToIRIResponse) Reset()         { *m = ConvertGraphHashToIRIResponse{} }
func (m *ConvertGraphHashToIRIResponse) String() string { return proto.CompactTextString(m) }
func (*ConvertGraphHashToIRIResponse) ProtoMessage()    {}
func (*ConvertGraphHashToIRIResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{25}
}
func (m *ConvertGraphHashToIRIResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConvertGraphHashToIRIResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConvertGraphHashToIRIResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConvertGraphHashToIRIResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConvertGraphHashToIRIResponse.Merge(m, src)
}
func (m *ConvertGraphHashToIRIResponse) XXX_Size() int {
	return m.Size()
}
func (m *ConvertGraphHashToIRIResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ConvertGraphHashToIRIResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ConvertGraphHashToIRIResponse proto.InternalMessageInfo

func (m *ConvertGraphHashToIRIResponse) GetIri() string {
	if m != nil {
		return m.Iri
	}
	return ""
}

// AnchorEntry is an anchor entry.
type AnchorEntry struct {
	// iri is the IRI of the anchored data.
	Iri string `protobuf:"bytes,1,opt,name=iri,proto3" json:"iri,omitempty"`
	// timestamp is the time at which the data was anchored.
	Timestamp *types.Timestamp `protobuf:"bytes,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *AnchorEntry) Reset()         { *m = AnchorEntry{} }
func (m *AnchorEntry) String() string { return proto.CompactTextString(m) }
func (*AnchorEntry) ProtoMessage()    {}
func (*AnchorEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{26}
}
func (m *AnchorEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AnchorEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AnchorEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AnchorEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnchorEntry.Merge(m, src)
}
func (m *AnchorEntry) XXX_Size() int {
	return m.Size()
}
func (m *AnchorEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_AnchorEntry.DiscardUnknown(m)
}

var xxx_messageInfo_AnchorEntry proto.InternalMessageInfo

func (m *AnchorEntry) GetIri() string {
	if m != nil {
		return m.Iri
	}
	return ""
}

func (m *AnchorEntry) GetTimestamp() *types.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

// AttestorEntry is an attestor entry.
type AttestorEntry struct {
	// attestor is the address of the account that attested to the anchored data.
	Attestor string `protobuf:"bytes,1,opt,name=attestor,proto3" json:"attestor,omitempty"`
	// timestamp is the time at which the data was attested to.
	Timestamp *types.Timestamp `protobuf:"bytes,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *AttestorEntry) Reset()         { *m = AttestorEntry{} }
func (m *AttestorEntry) String() string { return proto.CompactTextString(m) }
func (*AttestorEntry) ProtoMessage()    {}
func (*AttestorEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{27}
}
func (m *AttestorEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttestorEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttestorEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttestorEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttestorEntry.Merge(m, src)
}
func (m *AttestorEntry) XXX_Size() int {
	return m.Size()
}
func (m *AttestorEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_AttestorEntry.DiscardUnknown(m)
}

var xxx_messageInfo_AttestorEntry proto.InternalMessageInfo

func (m *AttestorEntry) GetAttestor() string {
	if m != nil {
		return m.Attestor
	}
	return ""
}

func (m *AttestorEntry) GetTimestamp() *types.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

// ResolverInfo is the human-readable resolver information.
type ResolverInfo struct {
	// id is the ID of the resolver.
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// url is the URL of the resolver.
	Url string `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
	// manager is the address of the resolver manager.
	Manager string `protobuf:"bytes,3,opt,name=manager,proto3" json:"manager,omitempty"`
}

func (m *ResolverInfo) Reset()         { *m = ResolverInfo{} }
func (m *ResolverInfo) String() string { return proto.CompactTextString(m) }
func (*ResolverInfo) ProtoMessage()    {}
func (*ResolverInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{28}
}
func (m *ResolverInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResolverInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResolverInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResolverInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResolverInfo.Merge(m, src)
}
func (m *ResolverInfo) XXX_Size() int {
	return m.Size()
}
func (m *ResolverInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ResolverInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ResolverInfo proto.InternalMessageInfo

func (m *ResolverInfo) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ResolverInfo) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *ResolverInfo) GetManager() string {
	if m != nil {
		return m.Manager
	}
	return ""
}

func init() {
	proto.RegisterType((*QueryAnchorByIRIRequest)(nil), "regen.data.v1.QueryAnchorByIRIRequest")
	proto.RegisterType((*QueryAnchorByIRIResponse)(nil), "regen.data.v1.QueryAnchorByIRIResponse")
	proto.RegisterType((*QueryAnchorByHashRequest)(nil), "regen.data.v1.QueryAnchorByHashRequest")
	proto.RegisterType((*QueryAnchorByHashResponse)(nil), "regen.data.v1.QueryAnchorByHashResponse")
	proto.RegisterType((*QueryAnchorsByAttestorRequest)(nil), "regen.data.v1.QueryAnchorsByAttestorRequest")
	proto.RegisterType((*QueryAnchorsByAttestorResponse)(nil), "regen.data.v1.QueryAnchorsByAttestorResponse")
	proto.RegisterType((*QueryAttestorsByIRIRequest)(nil), "regen.data.v1.QueryAttestorsByIRIRequest")
	proto.RegisterType((*QueryAttestorsByIRIResponse)(nil), "regen.data.v1.QueryAttestorsByIRIResponse")
	proto.RegisterType((*QueryAttestorsByHashRequest)(nil), "regen.data.v1.QueryAttestorsByHashRequest")
	proto.RegisterType((*QueryAttestorsByHashResponse)(nil), "regen.data.v1.QueryAttestorsByHashResponse")
	proto.RegisterType((*QueryResolverRequest)(nil), "regen.data.v1.QueryResolverRequest")
	proto.RegisterType((*QueryResolverResponse)(nil), "regen.data.v1.QueryResolverResponse")
	proto.RegisterType((*QueryResolversByIRIRequest)(nil), "regen.data.v1.QueryResolversByIRIRequest")
	proto.RegisterType((*QueryResolversByIRIResponse)(nil), "regen.data.v1.QueryResolversByIRIResponse")
	proto.RegisterType((*QueryResolversByHashRequest)(nil), "regen.data.v1.QueryResolversByHashRequest")
	proto.RegisterType((*QueryResolversByHashResponse)(nil), "regen.data.v1.QueryResolversByHashResponse")
	proto.RegisterType((*QueryResolversByURLRequest)(nil), "regen.data.v1.QueryResolversByURLRequest")
	proto.RegisterType((*QueryResolversByURLResponse)(nil), "regen.data.v1.QueryResolversByURLResponse")
	proto.RegisterType((*ConvertIRIToHashRequest)(nil), "regen.data.v1.ConvertIRIToHashRequest")
	proto.RegisterType((*ConvertIRIToHashResponse)(nil), "regen.data.v1.ConvertIRIToHashResponse")
	proto.RegisterType((*ConvertHashToIRIRequest)(nil), "regen.data.v1.ConvertHashToIRIRequest")
	proto.RegisterType((*ConvertHashToIRIResponse)(nil), "regen.data.v1.ConvertHashToIRIResponse")
	proto.RegisterType((*ConvertRawHashToIRIRequest)(nil), "regen.data.v1.ConvertRawHashToIRIRequest")
	proto.RegisterType((*ConvertRawHashToIRIResponse)(nil), "regen.data.v1.ConvertRawHashToIRIResponse")
	proto.RegisterType((*ConvertGraphHashToIRIRequest)(nil), "regen.data.v1.ConvertGraphHashToIRIRequest")
	proto.RegisterType((*ConvertGraphHashToIRIResponse)(nil), "regen.data.v1.ConvertGraphHashToIRIResponse")
	proto.RegisterType((*AnchorEntry)(nil), "regen.data.v1.AnchorEntry")
	proto.RegisterType((*AttestorEntry)(nil), "regen.data.v1.AttestorEntry")
	proto.RegisterType((*ResolverInfo)(nil), "regen.data.v1.ResolverInfo")
}

func init() { proto.RegisterFile("regen/data/v1/query.proto", fileDescriptor_38d540b97ef3e368) }

var fileDescriptor_38d540b97ef3e368 = []byte{
	// 1263 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x57, 0xcf, 0x6f, 0x1b, 0x45,
	0x14, 0xf6, 0xba, 0xa5, 0x8d, 0x5f, 0x7e, 0x34, 0x0c, 0x54, 0x75, 0x36, 0xa9, 0x1b, 0x96, 0x90,
	0x84, 0x24, 0xde, 0x55, 0x02, 0x08, 0xa8, 0x84, 0x50, 0x12, 0x68, 0x31, 0x6a, 0xa1, 0xac, 0x52,
	0x89, 0x70, 0x89, 0xc6, 0xf6, 0x74, 0xbd, 0xaa, 0xbd, 0xeb, 0xce, 0x8e, 0x1d, 0x4c, 0xd4, 0x0b,
	0xdc, 0x90, 0x90, 0x2a, 0x81, 0x38, 0x21, 0x21, 0x0a, 0x12, 0x17, 0xee, 0xfc, 0x0b, 0x1c, 0x2b,
	0x71, 0xe1, 0x88, 0x12, 0xce, 0xfc, 0x0d, 0x68, 0x67, 0x67, 0xd6, 0xeb, 0xfd, 0x61, 0x47, 0x24,
	0xad, 0x72, 0xdb, 0xf5, 0x7e, 0xf3, 0xde, 0xf7, 0xbe, 0xf7, 0x3c, 0xf3, 0x0d, 0xcc, 0x50, 0x62,
	0x11, 0xc7, 0xa8, 0x63, 0x86, 0x8d, 0xee, 0xba, 0xf1, 0xa0, 0x43, 0x68, 0x4f, 0x6f, 0x53, 0x97,
	0xb9, 0x68, 0x92, 0x7f, 0xd2, 0xfd, 0x4f, 0x7a, 0x77, 0x5d, 0x9d, 0xb3, 0x5c, 0xd7, 0x6a, 0x12,
	0x03, 0xb7, 0x6d, 0x03, 0x3b, 0x8e, 0xcb, 0x30, 0xb3, 0x5d, 0xc7, 0x0b, 0xc0, 0xea, 0x35, 0xf1,
	0x95, 0xbf, 0x55, 0x3b, 0xf7, 0x0c, 0x66, 0xb7, 0x88, 0xc7, 0x70, 0xab, 0x2d, 0x00, 0x2b, 0x35,
	0xd7, 0x6b, 0xb9, 0x9e, 0x51, 0xc5, 0x1e, 0x09, 0xd2, 0x18, 0xdd, 0xf5, 0x2a, 0x61, 0x78, 0xdd,
	0x68, 0x63, 0xcb, 0x76, 0x78, 0x34, 0x81, 0x8d, 0x91, 0x62, 0xbd, 0x36, 0x11, 0x79, 0xb4, 0x55,
	0xb8, 0xf2, 0x89, 0xbf, 0x78, 0xd3, 0xa9, 0x35, 0x5c, 0xba, 0xd5, 0xab, 0x98, 0x15, 0x93, 0x3c,
	0xe8, 0x10, 0x8f, 0xa1, 0x69, 0x38, 0x67, 0x53, 0xbb, 0xa8, 0xcc, 0x2b, 0xcb, 0x05, 0xd3, 0x7f,
	0xd4, 0x3e, 0x82, 0x62, 0x12, 0xec, 0xb5, 0x5d, 0xc7, 0x23, 0x68, 0x03, 0x2e, 0x60, 0xfe, 0x33,
	0x5f, 0x30, 0xbe, 0xa1, 0xea, 0x03, 0xe5, 0xea, 0xc1, 0x9a, 0xf7, 0x1d, 0x46, 0x7b, 0xa6, 0x40,
	0x6a, 0xbb, 0xb1, 0x78, 0x1f, 0x60, 0xaf, 0x21, 0xb3, 0xbf, 0x03, 0x13, 0x35, 0xd7, 0x61, 0xc4,
	0x61, 0x7b, 0x0d, 0xec, 0x35, 0x32, 0xa2, 0x6e, 0x07, 0x10, 0xbe, 0x70, 0xbc, 0xd6, 0x7f, 0xd1,
	0x3e, 0x86, 0x99, 0x94, 0xd0, 0x27, 0xe0, 0xfa, 0x95, 0x02, 0x57, 0x23, 0x11, 0xbd, 0xad, 0xde,
	0x26, 0x63, 0xc4, 0x63, 0x2e, 0x95, 0x8c, 0x55, 0x18, 0xc3, 0xe2, 0x27, 0x21, 0x5a, 0xf8, 0x8e,
	0x6e, 0x00, 0xf4, 0xbb, 0x52, 0xcc, 0xf3, 0xac, 0x8b, 0x7a, 0xd0, 0x42, 0xdd, 0x6f, 0xa1, 0x1e,
	0x4c, 0x8a, 0x68, 0xa1, 0x7e, 0x07, 0x5b, 0x44, 0xc4, 0x35, 0x23, 0x2b, 0xb5, 0x1f, 0x15, 0x28,
	0x65, 0xb1, 0x10, 0xc5, 0xbd, 0x0e, 0x17, 0x03, 0xca, 0x5e, 0x51, 0x99, 0x3f, 0x37, 0xa2, 0x3a,
	0x09, 0x45, 0x37, 0x53, 0x08, 0x2e, 0x8d, 0x24, 0x18, 0xa4, 0x1c, 0x60, 0xd8, 0x05, 0x35, 0x20,
	0x28, 0x78, 0x79, 0xc3, 0x67, 0xea, 0xd4, 0x94, 0x79, 0xac, 0xc0, 0x6c, 0x6a, 0x62, 0x21, 0xcb,
	0x75, 0x28, 0xc8, 0x6e, 0x48, 0x61, 0xe6, 0xe2, 0xc2, 0x88, 0xef, 0x81, 0x34, 0x7d, 0xf8, 0xe9,
	0x89, 0xf3, 0x4b, 0x0a, 0xc9, 0xd3, 0x1b, 0xfa, 0x53, 0xd3, 0xf2, 0x67, 0x05, 0xe6, 0xd2, 0x69,
	0x9e, 0x25, 0x31, 0x17, 0xe1, 0x45, 0x4e, 0xd2, 0x24, 0x9e, 0xdb, 0xec, 0x92, 0xf0, 0x7f, 0x38,
	0x05, 0x79, 0xbb, 0xce, 0xa5, 0x3b, 0x6f, 0xe6, 0xed, 0xba, 0x76, 0x07, 0x2e, 0xc7, 0x70, 0xa2,
	0x8a, 0x37, 0x61, 0x8c, 0x8a, 0xdf, 0x84, 0xd2, 0xb3, 0xb1, 0x22, 0xe4, 0x92, 0x8a, 0x73, 0xcf,
	0x35, 0x43, 0x70, 0x38, 0xe3, 0xf2, 0xf3, 0xb3, 0x9a, 0xf1, 0x9f, 0xe4, 0xf8, 0xc4, 0x13, 0x8b,
	0x82, 0xde, 0x86, 0x82, 0xe4, 0x28, 0xdb, 0x32, 0xb4, 0xa2, 0x3e, 0xfa, 0x29, 0x8c, 0x78, 0x84,
	0xe3, 0x19, 0x1c, 0xf1, 0xc7, 0x72, 0xc4, 0x13, 0x34, 0xcf, 0x90, 0x96, 0x29, 0x73, 0x76, 0xd7,
	0xbc, 0x15, 0x99, 0xb3, 0x0e, 0x6d, 0xca, 0x39, 0xeb, 0xd0, 0xe6, 0x53, 0x9d, 0x33, 0x9e, 0xf8,
	0x0c, 0x69, 0xb3, 0x0a, 0x57, 0xb6, 0x5d, 0xa7, 0x4b, 0x28, 0xab, 0x98, 0x95, 0x1d, 0x37, 0x3a,
	0x62, 0x49, 0xe3, 0xb2, 0x0b, 0xc5, 0x24, 0x58, 0x14, 0x73, 0x42, 0xa3, 0xf1, 0x69, 0xc8, 0xc3,
	0x7f, 0xdd, 0x71, 0x23, 0x1b, 0xc1, 0x09, 0x23, 0xaf, 0x85, 0xa4, 0x23, 0x91, 0x05, 0xe9, 0x64,
	0x89, 0xbf, 0x2b, 0xa0, 0x0a, 0xb8, 0x89, 0xf7, 0x13, 0x5c, 0x10, 0x9c, 0x0f, 0x39, 0x14, 0x4c,
	0xfe, 0x8c, 0x2a, 0x30, 0x5d, 0xb7, 0x2d, 0xe2, 0xb1, 0x3d, 0xdc, 0xb4, 0x5c, 0x6a, 0xb3, 0x46,
	0x8b, 0x77, 0x64, 0x6a, 0xa3, 0x14, 0xe3, 0xf8, 0x1e, 0x87, 0x6d, 0x4a, 0x94, 0x79, 0xa9, 0x3e,
	0xf8, 0x03, 0xba, 0x0e, 0xd0, 0x22, 0x75, 0x1b, 0xef, 0xf9, 0xde, 0xb2, 0x78, 0x8e, 0x07, 0x49,
	0x8c, 0x04, 0xde, 0xbf, 0xed, 0x63, 0x76, 0x7a, 0x6d, 0x62, 0x16, 0x5a, 0xf2, 0x51, 0x33, 0x60,
	0x36, 0x95, 0x78, 0x66, 0xa9, 0xbf, 0xe5, 0x61, 0x4e, 0xac, 0xb8, 0x49, 0x71, 0xbb, 0xf1, 0xac,
	0x8b, 0x6d, 0x82, 0x5a, 0xc3, 0x8e, 0xeb, 0xd8, 0x35, 0xdc, 0xb4, 0xbf, 0xe0, 0xe3, 0x18, 0x09,
	0x1a, 0x14, 0x5f, 0x8e, 0x05, 0xe5, 0x44, 0xb7, 0x63, 0xab, 0xfa, 0x39, 0x66, 0x6a, 0x59, 0x9f,
	0xd0, 0xbb, 0x30, 0xde, 0x22, 0xf4, 0x7e, 0x93, 0xec, 0x31, 0x4a, 0x48, 0xf1, 0x7c, 0x2a, 0x67,
	0x1e, 0xfe, 0x36, 0x87, 0xed, 0x50, 0x42, 0x4c, 0x68, 0x85, 0xcf, 0xda, 0x3a, 0x5c, 0xcd, 0x50,
	0x2b, 0x53, 0xe1, 0x5d, 0x18, 0x8f, 0xb8, 0xc4, 0x94, 0x13, 0xed, 0x2d, 0x28, 0x84, 0x17, 0x12,
	0xf1, 0x2f, 0x56, 0xf5, 0xe0, 0xca, 0xa2, 0xcb, 0x2b, 0x8b, 0xbe, 0x23, 0x11, 0x66, 0x1f, 0xac,
	0x11, 0x98, 0x1c, 0xb0, 0x06, 0x43, 0x6d, 0xf3, 0xff, 0x4f, 0xf3, 0x21, 0x4c, 0x44, 0xb7, 0xa0,
	0xb8, 0x29, 0x90, 0x9b, 0x67, 0xbe, 0xbf, 0x79, 0x16, 0xe1, 0x62, 0x0b, 0x3b, 0xd8, 0x22, 0x94,
	0xb7, 0xb0, 0x60, 0xca, 0xd7, 0x8d, 0x7f, 0x27, 0xe1, 0x39, 0xbe, 0x1d, 0xa2, 0xaf, 0x15, 0x29,
	0x0c, 0x3f, 0x78, 0xd1, 0x62, 0xac, 0x0d, 0x19, 0x57, 0x29, 0x75, 0x69, 0x24, 0x2e, 0x68, 0x85,
	0xb6, 0xf2, 0xe5, 0x9f, 0xff, 0x7c, 0x9b, 0x5f, 0x40, 0x9a, 0x31, 0x78, 0x65, 0x0b, 0x6c, 0x7a,
	0xb9, 0xda, 0x2b, 0xdb, 0xd4, 0x36, 0x0e, 0x6c, 0x6a, 0x3f, 0x44, 0x35, 0x98, 0x88, 0xde, 0x6e,
	0xd0, 0xd0, 0x24, 0x91, 0xfd, 0x51, 0x5d, 0x1e, 0x0d, 0x14, 0x74, 0x72, 0xe8, 0x57, 0x05, 0x9e,
	0x4f, 0xdc, 0x35, 0xd0, 0x5a, 0x76, 0x84, 0xe4, 0xc5, 0x48, 0x2d, 0x1f, 0x13, 0x2d, 0x92, 0xbe,
	0xc1, 0x35, 0x30, 0x50, 0x39, 0x55, 0x03, 0xcf, 0x17, 0x41, 0x0e, 0x88, 0x71, 0x20, 0x9f, 0x1e,
	0xa2, 0xef, 0x15, 0x98, 0x1a, 0xf4, 0xfe, 0xe8, 0xd5, 0xd4, 0xc4, 0x69, 0x17, 0x13, 0x75, 0xe5,
	0x38, 0x50, 0x41, 0xb0, 0xcc, 0x09, 0x2e, 0xa1, 0x57, 0xe2, 0x04, 0x25, 0x7c, 0xb0, 0x4f, 0x4d,
	0xb8, 0x14, 0xf3, 0xd1, 0x68, 0x54, 0xb6, 0x68, 0xb7, 0x56, 0x8f, 0x85, 0x0d, 0x1b, 0x76, 0x00,
	0x63, 0x72, 0xf0, 0xd1, 0xcb, 0x69, 0x4b, 0x63, 0x76, 0x59, 0x5d, 0x18, 0x0e, 0x12, 0x81, 0x17,
	0x78, 0xcd, 0x25, 0x34, 0x17, 0xab, 0x59, 0x9e, 0xec, 0xc6, 0x81, 0x5d, 0x0f, 0x7a, 0x30, 0xe8,
	0x4d, 0xd3, 0x7b, 0x90, 0x6a, 0x9c, 0xd3, 0x7b, 0x90, 0x6e, 0x75, 0x33, 0x7b, 0x10, 0x3a, 0x8d,
	0x44, 0x0f, 0x62, 0x46, 0x0f, 0x8d, 0xca, 0x36, 0xb2, 0x07, 0x19, 0xce, 0x51, 0xcb, 0xa1, 0x47,
	0x83, 0x32, 0xdc, 0x35, 0x6f, 0x8d, 0x94, 0xa1, 0xef, 0xeb, 0x46, 0xca, 0x10, 0x71, 0x62, 0xda,
	0x12, 0x97, 0xe1, 0x25, 0x74, 0x6d, 0x98, 0x0c, 0xfe, 0xee, 0xf6, 0x8d, 0x02, 0xd3, 0x71, 0x0b,
	0x94, 0xd8, 0xbe, 0x32, 0x0c, 0x55, 0x62, 0xfb, 0xca, 0xf2, 0x52, 0xda, 0x32, 0xa7, 0xa3, 0xa1,
	0xf9, 0x18, 0x1d, 0x9b, 0xda, 0x65, 0xe6, 0x96, 0xfd, 0x83, 0x58, 0x34, 0x84, 0x84, 0x74, 0xc2,
	0xf3, 0x28, 0x8b, 0x4e, 0xfc, 0x78, 0xcf, 0xa2, 0x93, 0x38, 0xd8, 0xb4, 0x1c, 0xfa, 0x4e, 0x81,
	0x17, 0x52, 0xcc, 0x45, 0xa2, 0x1d, 0xd9, 0xce, 0x29, 0xd1, 0x8e, 0x21, 0x5e, 0x45, 0x5b, 0xe4,
	0xf5, 0xcf, 0xa3, 0x52, 0xbc, 0x1d, 0x78, 0x9f, 0x17, 0xef, 0x8b, 0xe0, 0x1f, 0x9f, 0x3f, 0x28,
	0x70, 0x39, 0xf5, 0x4c, 0x46, 0xab, 0xe9, 0xd9, 0x52, 0x7d, 0x8e, 0xba, 0x76, 0x3c, 0xf0, 0x88,
	0xe6, 0x58, 0x3e, 0x3c, 0x4a, 0x6f, 0xeb, 0xc6, 0x1f, 0x87, 0x25, 0xe5, 0xc9, 0x61, 0x49, 0xf9,
	0xfb, 0xb0, 0xa4, 0x3c, 0x3a, 0x2a, 0xe5, 0x9e, 0x1c, 0x95, 0x72, 0x7f, 0x1d, 0x95, 0x72, 0x9f,
	0xad, 0x59, 0x36, 0x6b, 0x74, 0xaa, 0x7a, 0xcd, 0x6d, 0x05, 0x51, 0xca, 0x0e, 0x61, 0xfb, 0x2e,
	0xbd, 0x2f, 0xde, 0x9a, 0xa4, 0x6e, 0x11, 0x6a, 0x7c, 0xce, 0x83, 0x57, 0x2f, 0xf0, 0x33, 0xfa,
	0xb5, 0xff, 0x02, 0x00, 0x00, 0xff, 0xff, 0x80, 0x36, 0xc3, 0xb3, 0x15, 0x15, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// QueryClient is the client API for Query service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QueryClient interface {
	// AnchorByIRI queries for an anchor entry by IRI.
	AnchorByIRI(ctx context.Context, in *QueryAnchorByIRIRequest, opts ...grpc.CallOption) (*QueryAnchorByIRIResponse, error)
	// AnchorByHash queries for an anchor entry by ContentHash.
	AnchorByHash(ctx context.Context, in *QueryAnchorByHashRequest, opts ...grpc.CallOption) (*QueryAnchorByHashResponse, error)
	// AnchorsByAttestor queries for all anchor entries attested to by an
	// attestor.
	AnchorsByAttestor(ctx context.Context, in *QueryAnchorsByAttestorRequest, opts ...grpc.CallOption) (*QueryAnchorsByAttestorResponse, error)
	// AttestorsByIRI queries for all attestor entries for an anchor entry by IRI.
	AttestorsByIRI(ctx context.Context, in *QueryAttestorsByIRIRequest, opts ...grpc.CallOption) (*QueryAttestorsByIRIResponse, error)
	// AttestorsByHash queries for all attestor entries for an anchor entry by
	// ContentHash.
	AttestorsByHash(ctx context.Context, in *QueryAttestorsByHashRequest, opts ...grpc.CallOption) (*QueryAttestorsByHashResponse, error)
	// Resolver queries for a resolver by ID.
	Resolver(ctx context.Context, in *QueryResolverRequest, opts ...grpc.CallOption) (*QueryResolverResponse, error)
	// ResolversByIRI queries for all resolvers that have registered an anchored
	// data entry by the IRI of the anchored data.
	ResolversByIRI(ctx context.Context, in *QueryResolversByIRIRequest, opts ...grpc.CallOption) (*QueryResolversByIRIResponse, error)
	// ResolversByHash queries for all resolvers that have registered an anchor
	// data entry by the ContentHash of the anchored data.
	ResolversByHash(ctx context.Context, in *QueryResolversByHashRequest, opts ...grpc.CallOption) (*QueryResolversByHashResponse, error)
	// ResolversByURL queries all resolvers by URL.
	ResolversByURL(ctx context.Context, in *QueryResolversByURLRequest, opts ...grpc.CallOption) (*QueryResolversByURLResponse, error)
	// ConvertIRIToHash converts an IRI to a ContentHash.
	ConvertIRIToHash(ctx context.Context, in *ConvertIRIToHashRequest, opts ...grpc.CallOption) (*ConvertIRIToHashResponse, error)
	// ConvertHashToIRI converts a ContentHash to an IRI.
	ConvertHashToIRI(ctx context.Context, in *ConvertHashToIRIRequest, opts ...grpc.CallOption) (*ConvertHashToIRIResponse, error)
	// ConvertRawHashToIRI converts ContentHash_Raw properties to an IRI.
	ConvertRawHashToIRI(ctx context.Context, in *ConvertRawHashToIRIRequest, opts ...grpc.CallOption) (*ConvertRawHashToIRIResponse, error)
	// ConvertGraphHashToIRI converts ContentHash_Graph properties to an IRI.
	ConvertGraphHashToIRI(ctx context.Context, in *ConvertGraphHashToIRIRequest, opts ...grpc.CallOption) (*ConvertGraphHashToIRIResponse, error)
}

type queryClient struct {
	cc grpc1.ClientConn
}

func NewQueryClient(cc grpc1.ClientConn) QueryClient {
	return &queryClient{cc}
}

func (c *queryClient) AnchorByIRI(ctx context.Context, in *QueryAnchorByIRIRequest, opts ...grpc.CallOption) (*QueryAnchorByIRIResponse, error) {
	out := new(QueryAnchorByIRIResponse)
	err := c.cc.Invoke(ctx, "/regen.data.v1.Query/AnchorByIRI", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) AnchorByHash(ctx context.Context, in *QueryAnchorByHashRequest, opts ...grpc.CallOption) (*QueryAnchorByHashResponse, error) {
	out := new(QueryAnchorByHashResponse)
	err := c.cc.Invoke(ctx, "/regen.data.v1.Query/AnchorByHash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) AnchorsByAttestor(ctx context.Context, in *QueryAnchorsByAttestorRequest, opts ...grpc.CallOption) (*QueryAnchorsByAttestorResponse, error) {
	out := new(QueryAnchorsByAttestorResponse)
	err := c.cc.Invoke(ctx, "/regen.data.v1.Query/AnchorsByAttestor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) AttestorsByIRI(ctx context.Context, in *QueryAttestorsByIRIRequest, opts ...grpc.CallOption) (*QueryAttestorsByIRIResponse, error) {
	out := new(QueryAttestorsByIRIResponse)
	err := c.cc.Invoke(ctx, "/regen.data.v1.Query/AttestorsByIRI", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) AttestorsByHash(ctx context.Context, in *QueryAttestorsByHashRequest, opts ...grpc.CallOption) (*QueryAttestorsByHashResponse, error) {
	out := new(QueryAttestorsByHashResponse)
	err := c.cc.Invoke(ctx, "/regen.data.v1.Query/AttestorsByHash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Resolver(ctx context.Context, in *QueryResolverRequest, opts ...grpc.CallOption) (*QueryResolverResponse, error) {
	out := new(QueryResolverResponse)
	err := c.cc.Invoke(ctx, "/regen.data.v1.Query/Resolver", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) ResolversByIRI(ctx context.Context, in *QueryResolversByIRIRequest, opts ...grpc.CallOption) (*QueryResolversByIRIResponse, error) {
	out := new(QueryResolversByIRIResponse)
	err := c.cc.Invoke(ctx, "/regen.data.v1.Query/ResolversByIRI", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) ResolversByHash(ctx context.Context, in *QueryResolversByHashRequest, opts ...grpc.CallOption) (*QueryResolversByHashResponse, error) {
	out := new(QueryResolversByHashResponse)
	err := c.cc.Invoke(ctx, "/regen.data.v1.Query/ResolversByHash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) ResolversByURL(ctx context.Context, in *QueryResolversByURLRequest, opts ...grpc.CallOption) (*QueryResolversByURLResponse, error) {
	out := new(QueryResolversByURLResponse)
	err := c.cc.Invoke(ctx, "/regen.data.v1.Query/ResolversByURL", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) ConvertIRIToHash(ctx context.Context, in *ConvertIRIToHashRequest, opts ...grpc.CallOption) (*ConvertIRIToHashResponse, error) {
	out := new(ConvertIRIToHashResponse)
	err := c.cc.Invoke(ctx, "/regen.data.v1.Query/ConvertIRIToHash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) ConvertHashToIRI(ctx context.Context, in *ConvertHashToIRIRequest, opts ...grpc.CallOption) (*ConvertHashToIRIResponse, error) {
	out := new(ConvertHashToIRIResponse)
	err := c.cc.Invoke(ctx, "/regen.data.v1.Query/ConvertHashToIRI", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) ConvertRawHashToIRI(ctx context.Context, in *ConvertRawHashToIRIRequest, opts ...grpc.CallOption) (*ConvertRawHashToIRIResponse, error) {
	out := new(ConvertRawHashToIRIResponse)
	err := c.cc.Invoke(ctx, "/regen.data.v1.Query/ConvertRawHashToIRI", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) ConvertGraphHashToIRI(ctx context.Context, in *ConvertGraphHashToIRIRequest, opts ...grpc.CallOption) (*ConvertGraphHashToIRIResponse, error) {
	out := new(ConvertGraphHashToIRIResponse)
	err := c.cc.Invoke(ctx, "/regen.data.v1.Query/ConvertGraphHashToIRI", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QueryServer is the server API for Query service.
type QueryServer interface {
	// AnchorByIRI queries for an anchor entry by IRI.
	AnchorByIRI(context.Context, *QueryAnchorByIRIRequest) (*QueryAnchorByIRIResponse, error)
	// AnchorByHash queries for an anchor entry by ContentHash.
	AnchorByHash(context.Context, *QueryAnchorByHashRequest) (*QueryAnchorByHashResponse, error)
	// AnchorsByAttestor queries for all anchor entries attested to by an
	// attestor.
	AnchorsByAttestor(context.Context, *QueryAnchorsByAttestorRequest) (*QueryAnchorsByAttestorResponse, error)
	// AttestorsByIRI queries for all attestor entries for an anchor entry by IRI.
	AttestorsByIRI(context.Context, *QueryAttestorsByIRIRequest) (*QueryAttestorsByIRIResponse, error)
	// AttestorsByHash queries for all attestor entries for an anchor entry by
	// ContentHash.
	AttestorsByHash(context.Context, *QueryAttestorsByHashRequest) (*QueryAttestorsByHashResponse, error)
	// Resolver queries for a resolver by ID.
	Resolver(context.Context, *QueryResolverRequest) (*QueryResolverResponse, error)
	// ResolversByIRI queries for all resolvers that have registered an anchored
	// data entry by the IRI of the anchored data.
	ResolversByIRI(context.Context, *QueryResolversByIRIRequest) (*QueryResolversByIRIResponse, error)
	// ResolversByHash queries for all resolvers that have registered an anchor
	// data entry by the ContentHash of the anchored data.
	ResolversByHash(context.Context, *QueryResolversByHashRequest) (*QueryResolversByHashResponse, error)
	// ResolversByURL queries all resolvers by URL.
	ResolversByURL(context.Context, *QueryResolversByURLRequest) (*QueryResolversByURLResponse, error)
	// ConvertIRIToHash converts an IRI to a ContentHash.
	ConvertIRIToHash(context.Context, *ConvertIRIToHashRequest) (*ConvertIRIToHashResponse, error)
	// ConvertHashToIRI converts a ContentHash to an IRI.
	ConvertHashToIRI(context.Context, *ConvertHashToIRIRequest) (*ConvertHashToIRIResponse, error)
	// ConvertRawHashToIRI converts ContentHash_Raw properties to an IRI.
	ConvertRawHashToIRI(context.Context, *ConvertRawHashToIRIRequest) (*ConvertRawHashToIRIResponse, error)
	// ConvertGraphHashToIRI converts ContentHash_Graph properties to an IRI.
	ConvertGraphHashToIRI(context.Context, *ConvertGraphHashToIRIRequest) (*ConvertGraphHashToIRIResponse, error)
}

// UnimplementedQueryServer can be embedded to have forward compatible implementations.
type UnimplementedQueryServer struct {
}

func (*UnimplementedQueryServer) AnchorByIRI(ctx context.Context, req *QueryAnchorByIRIRequest) (*QueryAnchorByIRIResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AnchorByIRI not implemented")
}
func (*UnimplementedQueryServer) AnchorByHash(ctx context.Context, req *QueryAnchorByHashRequest) (*QueryAnchorByHashResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AnchorByHash not implemented")
}
func (*UnimplementedQueryServer) AnchorsByAttestor(ctx context.Context, req *QueryAnchorsByAttestorRequest) (*QueryAnchorsByAttestorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AnchorsByAttestor not implemented")
}
func (*UnimplementedQueryServer) AttestorsByIRI(ctx context.Context, req *QueryAttestorsByIRIRequest) (*QueryAttestorsByIRIResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AttestorsByIRI not implemented")
}
func (*UnimplementedQueryServer) AttestorsByHash(ctx context.Context, req *QueryAttestorsByHashRequest) (*QueryAttestorsByHashResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AttestorsByHash not implemented")
}
func (*UnimplementedQueryServer) Resolver(ctx context.Context, req *QueryResolverRequest) (*QueryResolverResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Resolver not implemented")
}
func (*UnimplementedQueryServer) ResolversByIRI(ctx context.Context, req *QueryResolversByIRIRequest) (*QueryResolversByIRIResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResolversByIRI not implemented")
}
func (*UnimplementedQueryServer) ResolversByHash(ctx context.Context, req *QueryResolversByHashRequest) (*QueryResolversByHashResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResolversByHash not implemented")
}
func (*UnimplementedQueryServer) ResolversByURL(ctx context.Context, req *QueryResolversByURLRequest) (*QueryResolversByURLResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResolversByURL not implemented")
}
func (*UnimplementedQueryServer) ConvertIRIToHash(ctx context.Context, req *ConvertIRIToHashRequest) (*ConvertIRIToHashResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConvertIRIToHash not implemented")
}
func (*UnimplementedQueryServer) ConvertHashToIRI(ctx context.Context, req *ConvertHashToIRIRequest) (*ConvertHashToIRIResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConvertHashToIRI not implemented")
}
func (*UnimplementedQueryServer) ConvertRawHashToIRI(ctx context.Context, req *ConvertRawHashToIRIRequest) (*ConvertRawHashToIRIResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConvertRawHashToIRI not implemented")
}
func (*UnimplementedQueryServer) ConvertGraphHashToIRI(ctx context.Context, req *ConvertGraphHashToIRIRequest) (*ConvertGraphHashToIRIResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConvertGraphHashToIRI not implemented")
}

func RegisterQueryServer(s grpc1.Server, srv QueryServer) {
	s.RegisterService(&_Query_serviceDesc, srv)
}

func _Query_AnchorByIRI_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryAnchorByIRIRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).AnchorByIRI(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.data.v1.Query/AnchorByIRI",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).AnchorByIRI(ctx, req.(*QueryAnchorByIRIRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_AnchorByHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryAnchorByHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).AnchorByHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.data.v1.Query/AnchorByHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).AnchorByHash(ctx, req.(*QueryAnchorByHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_AnchorsByAttestor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryAnchorsByAttestorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).AnchorsByAttestor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.data.v1.Query/AnchorsByAttestor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).AnchorsByAttestor(ctx, req.(*QueryAnchorsByAttestorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_AttestorsByIRI_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryAttestorsByIRIRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).AttestorsByIRI(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.data.v1.Query/AttestorsByIRI",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).AttestorsByIRI(ctx, req.(*QueryAttestorsByIRIRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_AttestorsByHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryAttestorsByHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).AttestorsByHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.data.v1.Query/AttestorsByHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).AttestorsByHash(ctx, req.(*QueryAttestorsByHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_Resolver_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryResolverRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Resolver(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.data.v1.Query/Resolver",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Resolver(ctx, req.(*QueryResolverRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_ResolversByIRI_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryResolversByIRIRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).ResolversByIRI(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.data.v1.Query/ResolversByIRI",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).ResolversByIRI(ctx, req.(*QueryResolversByIRIRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_ResolversByHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryResolversByHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).ResolversByHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.data.v1.Query/ResolversByHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).ResolversByHash(ctx, req.(*QueryResolversByHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_ResolversByURL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryResolversByURLRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).ResolversByURL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.data.v1.Query/ResolversByURL",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).ResolversByURL(ctx, req.(*QueryResolversByURLRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_ConvertIRIToHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConvertIRIToHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).ConvertIRIToHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.data.v1.Query/ConvertIRIToHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).ConvertIRIToHash(ctx, req.(*ConvertIRIToHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_ConvertHashToIRI_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConvertHashToIRIRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).ConvertHashToIRI(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.data.v1.Query/ConvertHashToIRI",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).ConvertHashToIRI(ctx, req.(*ConvertHashToIRIRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_ConvertRawHashToIRI_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConvertRawHashToIRIRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).ConvertRawHashToIRI(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.data.v1.Query/ConvertRawHashToIRI",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).ConvertRawHashToIRI(ctx, req.(*ConvertRawHashToIRIRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_ConvertGraphHashToIRI_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConvertGraphHashToIRIRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).ConvertGraphHashToIRI(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.data.v1.Query/ConvertGraphHashToIRI",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).ConvertGraphHashToIRI(ctx, req.(*ConvertGraphHashToIRIRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Query_serviceDesc = grpc.ServiceDesc{
	ServiceName: "regen.data.v1.Query",
	HandlerType: (*QueryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AnchorByIRI",
			Handler:    _Query_AnchorByIRI_Handler,
		},
		{
			MethodName: "AnchorByHash",
			Handler:    _Query_AnchorByHash_Handler,
		},
		{
			MethodName: "AnchorsByAttestor",
			Handler:    _Query_AnchorsByAttestor_Handler,
		},
		{
			MethodName: "AttestorsByIRI",
			Handler:    _Query_AttestorsByIRI_Handler,
		},
		{
			MethodName: "AttestorsByHash",
			Handler:    _Query_AttestorsByHash_Handler,
		},
		{
			MethodName: "Resolver",
			Handler:    _Query_Resolver_Handler,
		},
		{
			MethodName: "ResolversByIRI",
			Handler:    _Query_ResolversByIRI_Handler,
		},
		{
			MethodName: "ResolversByHash",
			Handler:    _Query_ResolversByHash_Handler,
		},
		{
			MethodName: "ResolversByURL",
			Handler:    _Query_ResolversByURL_Handler,
		},
		{
			MethodName: "ConvertIRIToHash",
			Handler:    _Query_ConvertIRIToHash_Handler,
		},
		{
			MethodName: "ConvertHashToIRI",
			Handler:    _Query_ConvertHashToIRI_Handler,
		},
		{
			MethodName: "ConvertRawHashToIRI",
			Handler:    _Query_ConvertRawHashToIRI_Handler,
		},
		{
			MethodName: "ConvertGraphHashToIRI",
			Handler:    _Query_ConvertGraphHashToIRI_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "regen/data/v1/query.proto",
}

func (m *QueryAnchorByIRIRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryAnchorByIRIRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryAnchorByIRIRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Iri) > 0 {
		i -= len(m.Iri)
		copy(dAtA[i:], m.Iri)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Iri)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryAnchorByIRIResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryAnchorByIRIResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryAnchorByIRIResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Anchor != nil {
		{
			size, err := m.Anchor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryAnchorByHashRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryAnchorByHashRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryAnchorByHashRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ContentHash != nil {
		{
			size, err := m.ContentHash.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryAnchorByHashResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryAnchorByHashResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryAnchorByHashResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Anchor != nil {
		{
			size, err := m.Anchor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryAnchorsByAttestorRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryAnchorsByAttestorRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryAnchorsByAttestorRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Attestor) > 0 {
		i -= len(m.Attestor)
		copy(dAtA[i:], m.Attestor)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Attestor)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryAnchorsByAttestorResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryAnchorsByAttestorResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryAnchorsByAttestorResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Anchors) > 0 {
		for iNdEx := len(m.Anchors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Anchors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryAttestorsByIRIRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryAttestorsByIRIRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryAttestorsByIRIRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Iri) > 0 {
		i -= len(m.Iri)
		copy(dAtA[i:], m.Iri)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Iri)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryAttestorsByIRIResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryAttestorsByIRIResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryAttestorsByIRIResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Attestors) > 0 {
		for iNdEx := len(m.Attestors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Attestors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryAttestorsByHashRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryAttestorsByHashRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryAttestorsByHashRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ContentHash != nil {
		{
			size, err := m.ContentHash.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryAttestorsByHashResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryAttestorsByHashResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryAttestorsByHashResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Attestors) > 0 {
		for iNdEx := len(m.Attestors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Attestors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryResolverRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryResolverRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryResolverRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryResolverResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryResolverResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryResolverResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Resolver != nil {
		{
			size, err := m.Resolver.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryResolversByIRIRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryResolversByIRIRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryResolversByIRIRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Iri) > 0 {
		i -= len(m.Iri)
		copy(dAtA[i:], m.Iri)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Iri)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryResolversByIRIResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryResolversByIRIResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryResolversByIRIResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Resolvers) > 0 {
		for iNdEx := len(m.Resolvers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Resolvers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryResolversByHashRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryResolversByHashRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryResolversByHashRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ContentHash != nil {
		{
			size, err := m.ContentHash.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryResolversByHashResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryResolversByHashResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryResolversByHashResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Resolvers) > 0 {
		for iNdEx := len(m.Resolvers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Resolvers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryResolversByURLRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryResolversByURLRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryResolversByURLRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryResolversByURLResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryResolversByURLResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryResolversByURLResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Resolvers) > 0 {
		for iNdEx := len(m.Resolvers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Resolvers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ConvertIRIToHashRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConvertIRIToHashRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConvertIRIToHashRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Iri) > 0 {
		i -= len(m.Iri)
		copy(dAtA[i:], m.Iri)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Iri)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConvertIRIToHashResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConvertIRIToHashResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConvertIRIToHashResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ContentHash != nil {
		{
			size, err := m.ContentHash.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConvertHashToIRIRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConvertHashToIRIRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConvertHashToIRIRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ContentHash != nil {
		{
			size, err := m.ContentHash.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConvertHashToIRIResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConvertHashToIRIResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConvertHashToIRIResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Iri) > 0 {
		i -= len(m.Iri)
		copy(dAtA[i:], m.Iri)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Iri)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConvertRawHashToIRIRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConvertRawHashToIRIRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConvertRawHashToIRIRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MediaType != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.MediaType))
		i--
		dAtA[i] = 0x18
	}
	if m.DigestAlgorithm != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.DigestAlgorithm))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConvertRawHashToIRIResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConvertRawHashToIRIResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConvertRawHashToIRIResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Iri) > 0 {
		i -= len(m.Iri)
		copy(dAtA[i:], m.Iri)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Iri)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConvertGraphHashToIRIRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConvertGraphHashToIRIRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConvertGraphHashToIRIRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MerkleTree != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.MerkleTree))
		i--
		dAtA[i] = 0x20
	}
	if m.CanonicalizationAlgorithm != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.CanonicalizationAlgorithm))
		i--
		dAtA[i] = 0x18
	}
	if m.DigestAlgorithm != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.DigestAlgorithm))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConvertGraphHashToIRIResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConvertGraphHashToIRIResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConvertGraphHashToIRIResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Iri) > 0 {
		i -= len(m.Iri)
		copy(dAtA[i:], m.Iri)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Iri)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AnchorEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnchorEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AnchorEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timestamp != nil {
		{
			size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Iri) > 0 {
		i -= len(m.Iri)
		copy(dAtA[i:], m.Iri)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Iri)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AttestorEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttestorEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttestorEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timestamp != nil {
		{
			size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Attestor) > 0 {
		i -= len(m.Attestor)
		copy(dAtA[i:], m.Attestor)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Attestor)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResolverInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResolverInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResolverInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Manager) > 0 {
		i -= len(m.Manager)
		copy(dAtA[i:], m.Manager)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Manager)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintQuery(dAtA []byte, offset int, v uint64) int {
	offset -= sovQuery(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *QueryAnchorByIRIRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Iri)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryAnchorByIRIResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Anchor != nil {
		l = m.Anchor.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryAnchorByHashRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ContentHash != nil {
		l = m.ContentHash.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryAnchorByHashResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Anchor != nil {
		l = m.Anchor.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryAnchorsByAttestorRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Attestor)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryAnchorsByAttestorResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Anchors) > 0 {
		for _, e := range m.Anchors {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryAttestorsByIRIRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Iri)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryAttestorsByIRIResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Attestors) > 0 {
		for _, e := range m.Attestors {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryAttestorsByHashRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ContentHash != nil {
		l = m.ContentHash.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryAttestorsByHashResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Attestors) > 0 {
		for _, e := range m.Attestors {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryResolverRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovQuery(uint64(m.Id))
	}
	return n
}

func (m *QueryResolverResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Resolver != nil {
		l = m.Resolver.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryResolversByIRIRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Iri)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryResolversByIRIResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Resolvers) > 0 {
		for _, e := range m.Resolvers {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryResolversByHashRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ContentHash != nil {
		l = m.ContentHash.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryResolversByHashResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Resolvers) > 0 {
		for _, e := range m.Resolvers {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryResolversByURLRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryResolversByURLResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Resolvers) > 0 {
		for _, e := range m.Resolvers {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *ConvertIRIToHashRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Iri)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *ConvertIRIToHashResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ContentHash != nil {
		l = m.ContentHash.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *ConvertHashToIRIRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ContentHash != nil {
		l = m.ContentHash.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *ConvertHashToIRIResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Iri)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *ConvertRawHashToIRIRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.DigestAlgorithm != 0 {
		n += 1 + sovQuery(uint64(m.DigestAlgorithm))
	}
	if m.MediaType != 0 {
		n += 1 + sovQuery(uint64(m.MediaType))
	}
	return n
}

func (m *ConvertRawHashToIRIResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Iri)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *ConvertGraphHashToIRIRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.DigestAlgorithm != 0 {
		n += 1 + sovQuery(uint64(m.DigestAlgorithm))
	}
	if m.CanonicalizationAlgorithm != 0 {
		n += 1 + sovQuery(uint64(m.CanonicalizationAlgorithm))
	}
	if m.MerkleTree != 0 {
		n += 1 + sovQuery(uint64(m.MerkleTree))
	}
	return n
}

func (m *ConvertGraphHashToIRIResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Iri)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *AnchorEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Iri)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *AttestorEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Attestor)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *ResolverInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovQuery(uint64(m.Id))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Manager)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func sovQuery(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozQuery(x uint64) (n int) {
	return sovQuery(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *QueryAnchorByIRIRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryAnchorByIRIRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryAnchorByIRIRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Iri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Iri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryAnchorByIRIResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryAnchorByIRIResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryAnchorByIRIResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Anchor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Anchor == nil {
				m.Anchor = &AnchorEntry{}
			}
			if err := m.Anchor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryAnchorByHashRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryAnchorByHashRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryAnchorByHashRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentHash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContentHash == nil {
				m.ContentHash = &ContentHash{}
			}
			if err := m.ContentHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryAnchorByHashResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryAnchorByHashResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryAnchorByHashResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Anchor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Anchor == nil {
				m.Anchor = &AnchorEntry{}
			}
			if err := m.Anchor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryAnchorsByAttestorRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryAnchorsByAttestorRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryAnchorsByAttestorRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attestor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attestor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageRequest{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryAnchorsByAttestorResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryAnchorsByAttestorResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryAnchorsByAttestorResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Anchors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Anchors = append(m.Anchors, &AnchorEntry{})
			if err := m.Anchors[len(m.Anchors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageResponse{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryAttestorsByIRIRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryAttestorsByIRIRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryAttestorsByIRIRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Iri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Iri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageRequest{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryAttestorsByIRIResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryAttestorsByIRIResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryAttestorsByIRIResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attestors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attestors = append(m.Attestors, &AttestorEntry{})
			if err := m.Attestors[len(m.Attestors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageResponse{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryAttestorsByHashRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryAttestorsByHashRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryAttestorsByHashRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentHash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContentHash == nil {
				m.ContentHash = &ContentHash{}
			}
			if err := m.ContentHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageRequest{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryAttestorsByHashResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryAttestorsByHashResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryAttestorsByHashResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attestors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attestors = append(m.Attestors, &AttestorEntry{})
			if err := m.Attestors[len(m.Attestors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageResponse{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryResolverRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryResolverRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryResolverRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryResolverResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryResolverResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryResolverResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resolver", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resolver == nil {
				m.Resolver = &ResolverInfo{}
			}
			if err := m.Resolver.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryResolversByIRIRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryResolversByIRIRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryResolversByIRIRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Iri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Iri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageRequest{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryResolversByIRIResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryResolversByIRIResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryResolversByIRIResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resolvers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resolvers = append(m.Resolvers, &ResolverInfo{})
			if err := m.Resolvers[len(m.Resolvers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageResponse{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryResolversByHashRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryResolversByHashRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryResolversByHashRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentHash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContentHash == nil {
				m.ContentHash = &ContentHash{}
			}
			if err := m.ContentHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageRequest{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryResolversByHashResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryResolversByHashResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryResolversByHashResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resolvers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resolvers = append(m.Resolvers, &ResolverInfo{})
			if err := m.Resolvers[len(m.Resolvers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageResponse{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryResolversByURLRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryResolversByURLRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryResolversByURLRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageRequest{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryResolversByURLResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryResolversByURLResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryResolversByURLResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resolvers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resolvers = append(m.Resolvers, &ResolverInfo{})
			if err := m.Resolvers[len(m.Resolvers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageResponse{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConvertIRIToHashRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConvertIRIToHashRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConvertIRIToHashRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Iri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Iri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConvertIRIToHashResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConvertIRIToHashResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConvertIRIToHashResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentHash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContentHash == nil {
				m.ContentHash = &ContentHash{}
			}
			if err := m.ContentHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConvertHashToIRIRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConvertHashToIRIRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConvertHashToIRIRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentHash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContentHash == nil {
				m.ContentHash = &ContentHash{}
			}
			if err := m.ContentHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConvertHashToIRIResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConvertHashToIRIResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConvertHashToIRIResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Iri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Iri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConvertRawHashToIRIRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConvertRawHashToIRIRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConvertRawHashToIRIRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DigestAlgorithm", wireType)
			}
			m.DigestAlgorithm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DigestAlgorithm |= DigestAlgorithm(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaType", wireType)
			}
			m.MediaType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MediaType |= RawMediaType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConvertRawHashToIRIResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConvertRawHashToIRIResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConvertRawHashToIRIResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Iri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Iri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConvertGraphHashToIRIRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConvertGraphHashToIRIRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConvertGraphHashToIRIRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DigestAlgorithm", wireType)
			}
			m.DigestAlgorithm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DigestAlgorithm |= DigestAlgorithm(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanonicalizationAlgorithm", wireType)
			}
			m.CanonicalizationAlgorithm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CanonicalizationAlgorithm |= GraphCanonicalizationAlgorithm(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerkleTree", wireType)
			}
			m.MerkleTree = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MerkleTree |= GraphMerkleTree(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConvertGraphHashToIRIResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConvertGraphHashToIRIResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConvertGraphHashToIRIResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Iri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Iri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnchorEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnchorEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnchorEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Iri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Iri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &types.Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttestorEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttestorEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttestorEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attestor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attestor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &types.Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResolverInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResolverInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResolverInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Manager", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Manager = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipQuery(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthQuery
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupQuery
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthQuery
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthQuery        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowQuery          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupQuery = fmt.Errorf("proto: unexpected end of group")
)
