// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: regen/data/v1/query.proto

package data

import (
	context "context"
	fmt "fmt"
	query "github.com/cosmos/cosmos-sdk/types/query"
	grpc1 "github.com/gogo/protobuf/grpc"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// QueryAnchorByIRIRequest is the Query/AnchorByIRI request type.
type QueryAnchorByIRIRequest struct {
	// iri is the IRI of the anchored data.
	Iri string `protobuf:"bytes,1,opt,name=iri,proto3" json:"iri,omitempty"`
}

func (m *QueryAnchorByIRIRequest) Reset()         { *m = QueryAnchorByIRIRequest{} }
func (m *QueryAnchorByIRIRequest) String() string { return proto.CompactTextString(m) }
func (*QueryAnchorByIRIRequest) ProtoMessage()    {}
func (*QueryAnchorByIRIRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{0}
}
func (m *QueryAnchorByIRIRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryAnchorByIRIRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryAnchorByIRIRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryAnchorByIRIRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryAnchorByIRIRequest.Merge(m, src)
}
func (m *QueryAnchorByIRIRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryAnchorByIRIRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryAnchorByIRIRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryAnchorByIRIRequest proto.InternalMessageInfo

func (m *QueryAnchorByIRIRequest) GetIri() string {
	if m != nil {
		return m.Iri
	}
	return ""
}

// QueryAnchorByIRIResponse is the Query/AnchorByIRI response type.
type QueryAnchorByIRIResponse struct {
	// anchor is information about the data anchor.
	Anchor *AnchorInfo `protobuf:"bytes,1,opt,name=anchor,proto3" json:"anchor,omitempty"`
}

func (m *QueryAnchorByIRIResponse) Reset()         { *m = QueryAnchorByIRIResponse{} }
func (m *QueryAnchorByIRIResponse) String() string { return proto.CompactTextString(m) }
func (*QueryAnchorByIRIResponse) ProtoMessage()    {}
func (*QueryAnchorByIRIResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{1}
}
func (m *QueryAnchorByIRIResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryAnchorByIRIResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryAnchorByIRIResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryAnchorByIRIResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryAnchorByIRIResponse.Merge(m, src)
}
func (m *QueryAnchorByIRIResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryAnchorByIRIResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryAnchorByIRIResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryAnchorByIRIResponse proto.InternalMessageInfo

func (m *QueryAnchorByIRIResponse) GetAnchor() *AnchorInfo {
	if m != nil {
		return m.Anchor
	}
	return nil
}

// QueryAnchorByHashRequest is the Query/AnchorByHash request type.
type QueryAnchorByHashRequest struct {
	// content_hash is the ContentHash of the anchored data.
	ContentHash *ContentHash `protobuf:"bytes,1,opt,name=content_hash,json=contentHash,proto3" json:"content_hash,omitempty"`
}

func (m *QueryAnchorByHashRequest) Reset()         { *m = QueryAnchorByHashRequest{} }
func (m *QueryAnchorByHashRequest) String() string { return proto.CompactTextString(m) }
func (*QueryAnchorByHashRequest) ProtoMessage()    {}
func (*QueryAnchorByHashRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{2}
}
func (m *QueryAnchorByHashRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryAnchorByHashRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryAnchorByHashRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryAnchorByHashRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryAnchorByHashRequest.Merge(m, src)
}
func (m *QueryAnchorByHashRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryAnchorByHashRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryAnchorByHashRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryAnchorByHashRequest proto.InternalMessageInfo

func (m *QueryAnchorByHashRequest) GetContentHash() *ContentHash {
	if m != nil {
		return m.ContentHash
	}
	return nil
}

// QueryAnchorByHashResponse is the Query/AnchorByHash response type.
type QueryAnchorByHashResponse struct {
	// anchor is information about the data anchor.
	Anchor *AnchorInfo `protobuf:"bytes,1,opt,name=anchor,proto3" json:"anchor,omitempty"`
}

func (m *QueryAnchorByHashResponse) Reset()         { *m = QueryAnchorByHashResponse{} }
func (m *QueryAnchorByHashResponse) String() string { return proto.CompactTextString(m) }
func (*QueryAnchorByHashResponse) ProtoMessage()    {}
func (*QueryAnchorByHashResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{3}
}
func (m *QueryAnchorByHashResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryAnchorByHashResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryAnchorByHashResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryAnchorByHashResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryAnchorByHashResponse.Merge(m, src)
}
func (m *QueryAnchorByHashResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryAnchorByHashResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryAnchorByHashResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryAnchorByHashResponse proto.InternalMessageInfo

func (m *QueryAnchorByHashResponse) GetAnchor() *AnchorInfo {
	if m != nil {
		return m.Anchor
	}
	return nil
}

// QueryAttestationsByAttestorRequest is the Query/AttestationsByAttestor
// request type.
type QueryAttestationsByAttestorRequest struct {
	// attestor is the address of the attestor.
	Attestor string `protobuf:"bytes,1,opt,name=attestor,proto3" json:"attestor,omitempty"`
	// pagination is the PageRequest to use for pagination.
	Pagination *query.PageRequest `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryAttestationsByAttestorRequest) Reset()         { *m = QueryAttestationsByAttestorRequest{} }
func (m *QueryAttestationsByAttestorRequest) String() string { return proto.CompactTextString(m) }
func (*QueryAttestationsByAttestorRequest) ProtoMessage()    {}
func (*QueryAttestationsByAttestorRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{4}
}
func (m *QueryAttestationsByAttestorRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryAttestationsByAttestorRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryAttestationsByAttestorRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryAttestationsByAttestorRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryAttestationsByAttestorRequest.Merge(m, src)
}
func (m *QueryAttestationsByAttestorRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryAttestationsByAttestorRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryAttestationsByAttestorRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryAttestationsByAttestorRequest proto.InternalMessageInfo

func (m *QueryAttestationsByAttestorRequest) GetAttestor() string {
	if m != nil {
		return m.Attestor
	}
	return ""
}

func (m *QueryAttestationsByAttestorRequest) GetPagination() *query.PageRequest {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QueryAttestationsByAttestorResponse is the Query/AttestationsByAttestor
// response type.
type QueryAttestationsByAttestorResponse struct {
	// attestations are the attestations by the attestor.
	Attestations []*AttestationInfo `protobuf:"bytes,1,rep,name=attestations,proto3" json:"attestations,omitempty"`
	// pagination is the pagination PageResponse.
	Pagination *query.PageResponse `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryAttestationsByAttestorResponse) Reset()         { *m = QueryAttestationsByAttestorResponse{} }
func (m *QueryAttestationsByAttestorResponse) String() string { return proto.CompactTextString(m) }
func (*QueryAttestationsByAttestorResponse) ProtoMessage()    {}
func (*QueryAttestationsByAttestorResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{5}
}
func (m *QueryAttestationsByAttestorResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryAttestationsByAttestorResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryAttestationsByAttestorResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryAttestationsByAttestorResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryAttestationsByAttestorResponse.Merge(m, src)
}
func (m *QueryAttestationsByAttestorResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryAttestationsByAttestorResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryAttestationsByAttestorResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryAttestationsByAttestorResponse proto.InternalMessageInfo

func (m *QueryAttestationsByAttestorResponse) GetAttestations() []*AttestationInfo {
	if m != nil {
		return m.Attestations
	}
	return nil
}

func (m *QueryAttestationsByAttestorResponse) GetPagination() *query.PageResponse {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QueryAttestationsByIRIRequest is the Query/AttestationsByIRI request type.
type QueryAttestationsByIRIRequest struct {
	// iri is the IRI of the anchored data.
	Iri string `protobuf:"bytes,1,opt,name=iri,proto3" json:"iri,omitempty"`
	// pagination is the PageRequest to use for pagination.
	Pagination *query.PageRequest `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryAttestationsByIRIRequest) Reset()         { *m = QueryAttestationsByIRIRequest{} }
func (m *QueryAttestationsByIRIRequest) String() string { return proto.CompactTextString(m) }
func (*QueryAttestationsByIRIRequest) ProtoMessage()    {}
func (*QueryAttestationsByIRIRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{6}
}
func (m *QueryAttestationsByIRIRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryAttestationsByIRIRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryAttestationsByIRIRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryAttestationsByIRIRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryAttestationsByIRIRequest.Merge(m, src)
}
func (m *QueryAttestationsByIRIRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryAttestationsByIRIRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryAttestationsByIRIRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryAttestationsByIRIRequest proto.InternalMessageInfo

func (m *QueryAttestationsByIRIRequest) GetIri() string {
	if m != nil {
		return m.Iri
	}
	return ""
}

func (m *QueryAttestationsByIRIRequest) GetPagination() *query.PageRequest {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QueryAttestationsByIRIResponse is the Query/AttestationsByIRI response type.
type QueryAttestationsByIRIResponse struct {
	// attestations are the attestations that have been made to the anchored data.
	Attestations []*AttestationInfo `protobuf:"bytes,1,rep,name=attestations,proto3" json:"attestations,omitempty"`
	// pagination is the pagination PageResponse.
	Pagination *query.PageResponse `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryAttestationsByIRIResponse) Reset()         { *m = QueryAttestationsByIRIResponse{} }
func (m *QueryAttestationsByIRIResponse) String() string { return proto.CompactTextString(m) }
func (*QueryAttestationsByIRIResponse) ProtoMessage()    {}
func (*QueryAttestationsByIRIResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{7}
}
func (m *QueryAttestationsByIRIResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryAttestationsByIRIResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryAttestationsByIRIResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryAttestationsByIRIResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryAttestationsByIRIResponse.Merge(m, src)
}
func (m *QueryAttestationsByIRIResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryAttestationsByIRIResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryAttestationsByIRIResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryAttestationsByIRIResponse proto.InternalMessageInfo

func (m *QueryAttestationsByIRIResponse) GetAttestations() []*AttestationInfo {
	if m != nil {
		return m.Attestations
	}
	return nil
}

func (m *QueryAttestationsByIRIResponse) GetPagination() *query.PageResponse {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QueryAttestationsByHashRequest is the Query/AttestationsByHash request type.
type QueryAttestationsByHashRequest struct {
	// content_hash is the ContentHash of the anchored data.
	ContentHash *ContentHash `protobuf:"bytes,1,opt,name=content_hash,json=contentHash,proto3" json:"content_hash,omitempty"`
	// pagination is the PageRequest to use for pagination.
	Pagination *query.PageRequest `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryAttestationsByHashRequest) Reset()         { *m = QueryAttestationsByHashRequest{} }
func (m *QueryAttestationsByHashRequest) String() string { return proto.CompactTextString(m) }
func (*QueryAttestationsByHashRequest) ProtoMessage()    {}
func (*QueryAttestationsByHashRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{8}
}
func (m *QueryAttestationsByHashRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryAttestationsByHashRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryAttestationsByHashRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryAttestationsByHashRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryAttestationsByHashRequest.Merge(m, src)
}
func (m *QueryAttestationsByHashRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryAttestationsByHashRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryAttestationsByHashRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryAttestationsByHashRequest proto.InternalMessageInfo

func (m *QueryAttestationsByHashRequest) GetContentHash() *ContentHash {
	if m != nil {
		return m.ContentHash
	}
	return nil
}

func (m *QueryAttestationsByHashRequest) GetPagination() *query.PageRequest {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QueryAttestationsByHashResponse is the Query/AttestationsByHash response
// type.
type QueryAttestationsByHashResponse struct {
	// attestations are the attestations that have been made to the anchored data.
	Attestations []*AttestationInfo `protobuf:"bytes,1,rep,name=attestations,proto3" json:"attestations,omitempty"`
	// pagination is the pagination PageResponse.
	Pagination *query.PageResponse `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryAttestationsByHashResponse) Reset()         { *m = QueryAttestationsByHashResponse{} }
func (m *QueryAttestationsByHashResponse) String() string { return proto.CompactTextString(m) }
func (*QueryAttestationsByHashResponse) ProtoMessage()    {}
func (*QueryAttestationsByHashResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{9}
}
func (m *QueryAttestationsByHashResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryAttestationsByHashResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryAttestationsByHashResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryAttestationsByHashResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryAttestationsByHashResponse.Merge(m, src)
}
func (m *QueryAttestationsByHashResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryAttestationsByHashResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryAttestationsByHashResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryAttestationsByHashResponse proto.InternalMessageInfo

func (m *QueryAttestationsByHashResponse) GetAttestations() []*AttestationInfo {
	if m != nil {
		return m.Attestations
	}
	return nil
}

func (m *QueryAttestationsByHashResponse) GetPagination() *query.PageResponse {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QueryResolverRequest is the Query/Resolver request type.
type QueryResolverRequest struct {
	// id is the ID of the resolver.
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *QueryResolverRequest) Reset()         { *m = QueryResolverRequest{} }
func (m *QueryResolverRequest) String() string { return proto.CompactTextString(m) }
func (*QueryResolverRequest) ProtoMessage()    {}
func (*QueryResolverRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{10}
}
func (m *QueryResolverRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryResolverRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryResolverRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryResolverRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryResolverRequest.Merge(m, src)
}
func (m *QueryResolverRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryResolverRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryResolverRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryResolverRequest proto.InternalMessageInfo

func (m *QueryResolverRequest) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

// QueryResolverResponse is the Query/Resolver response type.
type QueryResolverResponse struct {
	// resolver is information about the resolver.
	Resolver *ResolverInfo `protobuf:"bytes,1,opt,name=resolver,proto3" json:"resolver,omitempty"`
}

func (m *QueryResolverResponse) Reset()         { *m = QueryResolverResponse{} }
func (m *QueryResolverResponse) String() string { return proto.CompactTextString(m) }
func (*QueryResolverResponse) ProtoMessage()    {}
func (*QueryResolverResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{11}
}
func (m *QueryResolverResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryResolverResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryResolverResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryResolverResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryResolverResponse.Merge(m, src)
}
func (m *QueryResolverResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryResolverResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryResolverResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryResolverResponse proto.InternalMessageInfo

func (m *QueryResolverResponse) GetResolver() *ResolverInfo {
	if m != nil {
		return m.Resolver
	}
	return nil
}

// QueryResolversByIRIRequest is the Query/ResolversByIRI request type.
type QueryResolversByIRIRequest struct {
	// iri is the IRI of the anchored data.
	Iri string `protobuf:"bytes,1,opt,name=iri,proto3" json:"iri,omitempty"`
	// pagination is the PageRequest to use for pagination.
	Pagination *query.PageRequest `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryResolversByIRIRequest) Reset()         { *m = QueryResolversByIRIRequest{} }
func (m *QueryResolversByIRIRequest) String() string { return proto.CompactTextString(m) }
func (*QueryResolversByIRIRequest) ProtoMessage()    {}
func (*QueryResolversByIRIRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{12}
}
func (m *QueryResolversByIRIRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryResolversByIRIRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryResolversByIRIRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryResolversByIRIRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryResolversByIRIRequest.Merge(m, src)
}
func (m *QueryResolversByIRIRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryResolversByIRIRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryResolversByIRIRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryResolversByIRIRequest proto.InternalMessageInfo

func (m *QueryResolversByIRIRequest) GetIri() string {
	if m != nil {
		return m.Iri
	}
	return ""
}

func (m *QueryResolversByIRIRequest) GetPagination() *query.PageRequest {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QueryResolversByIRIResponse is the Query/ResolversByIRI response type.
type QueryResolversByIRIResponse struct {
	// resolvers are the resolvers that have registered the anchored data.
	Resolvers []*ResolverInfo `protobuf:"bytes,1,rep,name=resolvers,proto3" json:"resolvers,omitempty"`
	// pagination is the PageResponse to use for pagination.
	Pagination *query.PageResponse `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryResolversByIRIResponse) Reset()         { *m = QueryResolversByIRIResponse{} }
func (m *QueryResolversByIRIResponse) String() string { return proto.CompactTextString(m) }
func (*QueryResolversByIRIResponse) ProtoMessage()    {}
func (*QueryResolversByIRIResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{13}
}
func (m *QueryResolversByIRIResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryResolversByIRIResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryResolversByIRIResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryResolversByIRIResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryResolversByIRIResponse.Merge(m, src)
}
func (m *QueryResolversByIRIResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryResolversByIRIResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryResolversByIRIResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryResolversByIRIResponse proto.InternalMessageInfo

func (m *QueryResolversByIRIResponse) GetResolvers() []*ResolverInfo {
	if m != nil {
		return m.Resolvers
	}
	return nil
}

func (m *QueryResolversByIRIResponse) GetPagination() *query.PageResponse {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QueryResolversByHashRequest is the Query/ResolversByHash request type.
type QueryResolversByHashRequest struct {
	// content_hash is the ContentHash of the anchored data.
	ContentHash *ContentHash `protobuf:"bytes,1,opt,name=content_hash,json=contentHash,proto3" json:"content_hash,omitempty"`
	// pagination is the PageRequest to use for pagination.
	Pagination *query.PageRequest `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryResolversByHashRequest) Reset()         { *m = QueryResolversByHashRequest{} }
func (m *QueryResolversByHashRequest) String() string { return proto.CompactTextString(m) }
func (*QueryResolversByHashRequest) ProtoMessage()    {}
func (*QueryResolversByHashRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{14}
}
func (m *QueryResolversByHashRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryResolversByHashRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryResolversByHashRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryResolversByHashRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryResolversByHashRequest.Merge(m, src)
}
func (m *QueryResolversByHashRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryResolversByHashRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryResolversByHashRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryResolversByHashRequest proto.InternalMessageInfo

func (m *QueryResolversByHashRequest) GetContentHash() *ContentHash {
	if m != nil {
		return m.ContentHash
	}
	return nil
}

func (m *QueryResolversByHashRequest) GetPagination() *query.PageRequest {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QueryResolversByHashResponse is the Query/ResolversByHash response type.
type QueryResolversByHashResponse struct {
	// resolvers are the resolvers that have registered the data.
	Resolvers []*ResolverInfo `protobuf:"bytes,1,rep,name=resolvers,proto3" json:"resolvers,omitempty"`
	// pagination is the PageResponse to use for pagination.
	Pagination *query.PageResponse `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryResolversByHashResponse) Reset()         { *m = QueryResolversByHashResponse{} }
func (m *QueryResolversByHashResponse) String() string { return proto.CompactTextString(m) }
func (*QueryResolversByHashResponse) ProtoMessage()    {}
func (*QueryResolversByHashResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{15}
}
func (m *QueryResolversByHashResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryResolversByHashResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryResolversByHashResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryResolversByHashResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryResolversByHashResponse.Merge(m, src)
}
func (m *QueryResolversByHashResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryResolversByHashResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryResolversByHashResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryResolversByHashResponse proto.InternalMessageInfo

func (m *QueryResolversByHashResponse) GetResolvers() []*ResolverInfo {
	if m != nil {
		return m.Resolvers
	}
	return nil
}

func (m *QueryResolversByHashResponse) GetPagination() *query.PageResponse {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QueryResolversByURLRequest is the Query/ResolversByURL request type.
type QueryResolversByURLRequest struct {
	// url is the URL of the resolver.
	Url string `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	// pagination is the PageRequest to use for pagination.
	Pagination *query.PageRequest `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryResolversByURLRequest) Reset()         { *m = QueryResolversByURLRequest{} }
func (m *QueryResolversByURLRequest) String() string { return proto.CompactTextString(m) }
func (*QueryResolversByURLRequest) ProtoMessage()    {}
func (*QueryResolversByURLRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{16}
}
func (m *QueryResolversByURLRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryResolversByURLRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryResolversByURLRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryResolversByURLRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryResolversByURLRequest.Merge(m, src)
}
func (m *QueryResolversByURLRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryResolversByURLRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryResolversByURLRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryResolversByURLRequest proto.InternalMessageInfo

func (m *QueryResolversByURLRequest) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *QueryResolversByURLRequest) GetPagination() *query.PageRequest {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QueryResolversByURLResponse is the Query/ResolversByURL response type.
type QueryResolversByURLResponse struct {
	// resolvers are the resolvers that have a matching URL.
	Resolvers []*ResolverInfo `protobuf:"bytes,1,rep,name=resolvers,proto3" json:"resolvers,omitempty"`
	// pagination is the PageResponse to use for pagination.
	Pagination *query.PageResponse `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryResolversByURLResponse) Reset()         { *m = QueryResolversByURLResponse{} }
func (m *QueryResolversByURLResponse) String() string { return proto.CompactTextString(m) }
func (*QueryResolversByURLResponse) ProtoMessage()    {}
func (*QueryResolversByURLResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{17}
}
func (m *QueryResolversByURLResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryResolversByURLResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryResolversByURLResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryResolversByURLResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryResolversByURLResponse.Merge(m, src)
}
func (m *QueryResolversByURLResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryResolversByURLResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryResolversByURLResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryResolversByURLResponse proto.InternalMessageInfo

func (m *QueryResolversByURLResponse) GetResolvers() []*ResolverInfo {
	if m != nil {
		return m.Resolvers
	}
	return nil
}

func (m *QueryResolversByURLResponse) GetPagination() *query.PageResponse {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// ConvertIRIToHashRequest is the Query/ConvertIRIToHash request type.
type ConvertIRIToHashRequest struct {
	// iri is the IRI to convert to a ContentHash.
	Iri string `protobuf:"bytes,1,opt,name=iri,proto3" json:"iri,omitempty"`
}

func (m *ConvertIRIToHashRequest) Reset()         { *m = ConvertIRIToHashRequest{} }
func (m *ConvertIRIToHashRequest) String() string { return proto.CompactTextString(m) }
func (*ConvertIRIToHashRequest) ProtoMessage()    {}
func (*ConvertIRIToHashRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{18}
}
func (m *ConvertIRIToHashRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConvertIRIToHashRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConvertIRIToHashRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConvertIRIToHashRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConvertIRIToHashRequest.Merge(m, src)
}
func (m *ConvertIRIToHashRequest) XXX_Size() int {
	return m.Size()
}
func (m *ConvertIRIToHashRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ConvertIRIToHashRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ConvertIRIToHashRequest proto.InternalMessageInfo

func (m *ConvertIRIToHashRequest) GetIri() string {
	if m != nil {
		return m.Iri
	}
	return ""
}

// ConvertIRIToHashResponse is the Query/ConvertIRIToHash response type.
type ConvertIRIToHashResponse struct {
	// content_hash is the ContentHash converted from the IRI.
	ContentHash *ContentHash `protobuf:"bytes,1,opt,name=content_hash,json=contentHash,proto3" json:"content_hash,omitempty"`
}

func (m *ConvertIRIToHashResponse) Reset()         { *m = ConvertIRIToHashResponse{} }
func (m *ConvertIRIToHashResponse) String() string { return proto.CompactTextString(m) }
func (*ConvertIRIToHashResponse) ProtoMessage()    {}
func (*ConvertIRIToHashResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{19}
}
func (m *ConvertIRIToHashResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConvertIRIToHashResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConvertIRIToHashResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConvertIRIToHashResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConvertIRIToHashResponse.Merge(m, src)
}
func (m *ConvertIRIToHashResponse) XXX_Size() int {
	return m.Size()
}
func (m *ConvertIRIToHashResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ConvertIRIToHashResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ConvertIRIToHashResponse proto.InternalMessageInfo

func (m *ConvertIRIToHashResponse) GetContentHash() *ContentHash {
	if m != nil {
		return m.ContentHash
	}
	return nil
}

// ConvertHashToIRIRequest is the Query/ConvertHashToIRI request type.
type ConvertHashToIRIRequest struct {
	// content_hash is the ContentHash to convert to an IRI.
	ContentHash *ContentHash `protobuf:"bytes,1,opt,name=content_hash,json=contentHash,proto3" json:"content_hash,omitempty"`
}

func (m *ConvertHashToIRIRequest) Reset()         { *m = ConvertHashToIRIRequest{} }
func (m *ConvertHashToIRIRequest) String() string { return proto.CompactTextString(m) }
func (*ConvertHashToIRIRequest) ProtoMessage()    {}
func (*ConvertHashToIRIRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{20}
}
func (m *ConvertHashToIRIRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConvertHashToIRIRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConvertHashToIRIRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConvertHashToIRIRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConvertHashToIRIRequest.Merge(m, src)
}
func (m *ConvertHashToIRIRequest) XXX_Size() int {
	return m.Size()
}
func (m *ConvertHashToIRIRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ConvertHashToIRIRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ConvertHashToIRIRequest proto.InternalMessageInfo

func (m *ConvertHashToIRIRequest) GetContentHash() *ContentHash {
	if m != nil {
		return m.ContentHash
	}
	return nil
}

// ConvertHashToIRIResponse is the Query/ConvertHashToIRI response type.
type ConvertHashToIRIResponse struct {
	// iri is the IRI converted from the ContentHash.
	Iri string `protobuf:"bytes,1,opt,name=iri,proto3" json:"iri,omitempty"`
}

func (m *ConvertHashToIRIResponse) Reset()         { *m = ConvertHashToIRIResponse{} }
func (m *ConvertHashToIRIResponse) String() string { return proto.CompactTextString(m) }
func (*ConvertHashToIRIResponse) ProtoMessage()    {}
func (*ConvertHashToIRIResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{21}
}
func (m *ConvertHashToIRIResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConvertHashToIRIResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConvertHashToIRIResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConvertHashToIRIResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConvertHashToIRIResponse.Merge(m, src)
}
func (m *ConvertHashToIRIResponse) XXX_Size() int {
	return m.Size()
}
func (m *ConvertHashToIRIResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ConvertHashToIRIResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ConvertHashToIRIResponse proto.InternalMessageInfo

func (m *ConvertHashToIRIResponse) GetIri() string {
	if m != nil {
		return m.Iri
	}
	return ""
}

// AnchorInfo is the information for a data anchor.
type AnchorInfo struct {
	// iri is the IRI of the anchored data.
	Iri string `protobuf:"bytes,1,opt,name=iri,proto3" json:"iri,omitempty"`
	// content_hash is the ContentHash of the anchored data.
	ContentHash *ContentHash `protobuf:"bytes,2,opt,name=content_hash,json=contentHash,proto3" json:"content_hash,omitempty"`
	// timestamp is the time at which the data was anchored.
	Timestamp *types.Timestamp `protobuf:"bytes,3,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *AnchorInfo) Reset()         { *m = AnchorInfo{} }
func (m *AnchorInfo) String() string { return proto.CompactTextString(m) }
func (*AnchorInfo) ProtoMessage()    {}
func (*AnchorInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{22}
}
func (m *AnchorInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AnchorInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AnchorInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AnchorInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnchorInfo.Merge(m, src)
}
func (m *AnchorInfo) XXX_Size() int {
	return m.Size()
}
func (m *AnchorInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AnchorInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AnchorInfo proto.InternalMessageInfo

func (m *AnchorInfo) GetIri() string {
	if m != nil {
		return m.Iri
	}
	return ""
}

func (m *AnchorInfo) GetContentHash() *ContentHash {
	if m != nil {
		return m.ContentHash
	}
	return nil
}

func (m *AnchorInfo) GetTimestamp() *types.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

// AttestationInfo is the information for an attestation.
type AttestationInfo struct {
	// iri is the IRI of the anchored data.
	Iri string `protobuf:"bytes,1,opt,name=iri,proto3" json:"iri,omitempty"`
	// attestor is the address of the account that attested to the anchored data.
	Attestor string `protobuf:"bytes,2,opt,name=attestor,proto3" json:"attestor,omitempty"`
	// timestamp is the time at which the data was attested to.
	Timestamp *types.Timestamp `protobuf:"bytes,3,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *AttestationInfo) Reset()         { *m = AttestationInfo{} }
func (m *AttestationInfo) String() string { return proto.CompactTextString(m) }
func (*AttestationInfo) ProtoMessage()    {}
func (*AttestationInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{23}
}
func (m *AttestationInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttestationInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttestationInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttestationInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttestationInfo.Merge(m, src)
}
func (m *AttestationInfo) XXX_Size() int {
	return m.Size()
}
func (m *AttestationInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AttestationInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AttestationInfo proto.InternalMessageInfo

func (m *AttestationInfo) GetIri() string {
	if m != nil {
		return m.Iri
	}
	return ""
}

func (m *AttestationInfo) GetAttestor() string {
	if m != nil {
		return m.Attestor
	}
	return ""
}

func (m *AttestationInfo) GetTimestamp() *types.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

// ResolverInfo is the information for a resolver.
type ResolverInfo struct {
	// id is the ID of the resolver.
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// url is the URL of the resolver.
	Url string `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
	// manager is the address of the account that manages the resolver.
	Manager string `protobuf:"bytes,3,opt,name=manager,proto3" json:"manager,omitempty"`
}

func (m *ResolverInfo) Reset()         { *m = ResolverInfo{} }
func (m *ResolverInfo) String() string { return proto.CompactTextString(m) }
func (*ResolverInfo) ProtoMessage()    {}
func (*ResolverInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d540b97ef3e368, []int{24}
}
func (m *ResolverInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResolverInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResolverInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResolverInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResolverInfo.Merge(m, src)
}
func (m *ResolverInfo) XXX_Size() int {
	return m.Size()
}
func (m *ResolverInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ResolverInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ResolverInfo proto.InternalMessageInfo

func (m *ResolverInfo) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ResolverInfo) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *ResolverInfo) GetManager() string {
	if m != nil {
		return m.Manager
	}
	return ""
}

func init() {
	proto.RegisterType((*QueryAnchorByIRIRequest)(nil), "regen.data.v1.QueryAnchorByIRIRequest")
	proto.RegisterType((*QueryAnchorByIRIResponse)(nil), "regen.data.v1.QueryAnchorByIRIResponse")
	proto.RegisterType((*QueryAnchorByHashRequest)(nil), "regen.data.v1.QueryAnchorByHashRequest")
	proto.RegisterType((*QueryAnchorByHashResponse)(nil), "regen.data.v1.QueryAnchorByHashResponse")
	proto.RegisterType((*QueryAttestationsByAttestorRequest)(nil), "regen.data.v1.QueryAttestationsByAttestorRequest")
	proto.RegisterType((*QueryAttestationsByAttestorResponse)(nil), "regen.data.v1.QueryAttestationsByAttestorResponse")
	proto.RegisterType((*QueryAttestationsByIRIRequest)(nil), "regen.data.v1.QueryAttestationsByIRIRequest")
	proto.RegisterType((*QueryAttestationsByIRIResponse)(nil), "regen.data.v1.QueryAttestationsByIRIResponse")
	proto.RegisterType((*QueryAttestationsByHashRequest)(nil), "regen.data.v1.QueryAttestationsByHashRequest")
	proto.RegisterType((*QueryAttestationsByHashResponse)(nil), "regen.data.v1.QueryAttestationsByHashResponse")
	proto.RegisterType((*QueryResolverRequest)(nil), "regen.data.v1.QueryResolverRequest")
	proto.RegisterType((*QueryResolverResponse)(nil), "regen.data.v1.QueryResolverResponse")
	proto.RegisterType((*QueryResolversByIRIRequest)(nil), "regen.data.v1.QueryResolversByIRIRequest")
	proto.RegisterType((*QueryResolversByIRIResponse)(nil), "regen.data.v1.QueryResolversByIRIResponse")
	proto.RegisterType((*QueryResolversByHashRequest)(nil), "regen.data.v1.QueryResolversByHashRequest")
	proto.RegisterType((*QueryResolversByHashResponse)(nil), "regen.data.v1.QueryResolversByHashResponse")
	proto.RegisterType((*QueryResolversByURLRequest)(nil), "regen.data.v1.QueryResolversByURLRequest")
	proto.RegisterType((*QueryResolversByURLResponse)(nil), "regen.data.v1.QueryResolversByURLResponse")
	proto.RegisterType((*ConvertIRIToHashRequest)(nil), "regen.data.v1.ConvertIRIToHashRequest")
	proto.RegisterType((*ConvertIRIToHashResponse)(nil), "regen.data.v1.ConvertIRIToHashResponse")
	proto.RegisterType((*ConvertHashToIRIRequest)(nil), "regen.data.v1.ConvertHashToIRIRequest")
	proto.RegisterType((*ConvertHashToIRIResponse)(nil), "regen.data.v1.ConvertHashToIRIResponse")
	proto.RegisterType((*AnchorInfo)(nil), "regen.data.v1.AnchorInfo")
	proto.RegisterType((*AttestationInfo)(nil), "regen.data.v1.AttestationInfo")
	proto.RegisterType((*ResolverInfo)(nil), "regen.data.v1.ResolverInfo")
}

func init() { proto.RegisterFile("regen/data/v1/query.proto", fileDescriptor_38d540b97ef3e368) }

var fileDescriptor_38d540b97ef3e368 = []byte{
	// 1174 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x96, 0x4f, 0x6f, 0x1b, 0x45,
	0x18, 0xc6, 0x33, 0x0e, 0x94, 0xe4, 0x4d, 0x68, 0xca, 0x08, 0xa8, 0xe3, 0x24, 0x4e, 0x98, 0xb4,
	0x49, 0x48, 0xe2, 0x5d, 0x6c, 0x0e, 0x40, 0x25, 0x84, 0x48, 0xa1, 0xad, 0xab, 0xa6, 0x2d, 0xdb,
	0x44, 0x22, 0xbe, 0xa0, 0xb5, 0x3d, 0xb5, 0x57, 0xd8, 0x3b, 0xee, 0xee, 0xda, 0x60, 0x45, 0xb9,
	0x70, 0xe2, 0x88, 0x40, 0x88, 0x0b, 0x17, 0x10, 0x12, 0xa7, 0xf6, 0xc0, 0x81, 0x0b, 0x7c, 0x00,
	0x04, 0x97, 0x4a, 0x5c, 0x38, 0xa2, 0x84, 0x33, 0x47, 0xce, 0x68, 0x67, 0x67, 0xbd, 0xff, 0xd7,
	0x6e, 0x1b, 0x90, 0x6f, 0x1e, 0xef, 0x33, 0x33, 0xbf, 0xf7, 0x9d, 0x67, 0x76, 0x1f, 0x98, 0x37,
	0x68, 0x83, 0xea, 0x72, 0x5d, 0xb5, 0x54, 0xb9, 0x57, 0x94, 0xef, 0x75, 0xa9, 0xd1, 0x97, 0x3a,
	0x06, 0xb3, 0x18, 0x7e, 0x96, 0x3f, 0x92, 0xec, 0x47, 0x52, 0xaf, 0x98, 0x5b, 0x6c, 0x30, 0xd6,
	0x68, 0x51, 0x59, 0xed, 0x68, 0xb2, 0xaa, 0xeb, 0xcc, 0x52, 0x2d, 0x8d, 0xe9, 0xa6, 0x23, 0xce,
	0x2d, 0x8b, 0xa7, 0x7c, 0x54, 0xed, 0xde, 0x95, 0x2d, 0xad, 0x4d, 0x4d, 0x4b, 0x6d, 0x77, 0x84,
	0x60, 0xb3, 0xc6, 0xcc, 0x36, 0x33, 0xe5, 0xaa, 0x6a, 0x52, 0x67, 0x1b, 0xb9, 0x57, 0xac, 0x52,
	0x4b, 0x2d, 0xca, 0x1d, 0xb5, 0xa1, 0xe9, 0x7c, 0x35, 0xa1, 0x0d, 0x41, 0x59, 0xfd, 0x0e, 0x15,
	0xfb, 0x90, 0x2d, 0x38, 0xff, 0x9e, 0x3d, 0xf9, 0x6d, 0xbd, 0xd6, 0x64, 0xc6, 0x4e, 0xbf, 0xac,
	0x94, 0x15, 0x7a, 0xaf, 0x4b, 0x4d, 0x0b, 0x9f, 0x83, 0x49, 0xcd, 0xd0, 0xb2, 0x68, 0x05, 0x6d,
	0x4c, 0x2b, 0xf6, 0x4f, 0xb2, 0x0b, 0xd9, 0xa8, 0xd8, 0xec, 0x30, 0xdd, 0xa4, 0xb8, 0x08, 0x67,
	0x54, 0xfe, 0x37, 0x9f, 0x30, 0x53, 0x9a, 0x97, 0x02, 0xe5, 0x4a, 0xce, 0x9c, 0xb2, 0x7e, 0x97,
	0x29, 0x42, 0x48, 0x0e, 0x42, 0xcb, 0x5d, 0x53, 0xcd, 0xa6, 0xbb, 0xf9, 0x9b, 0x30, 0x5b, 0x63,
	0xba, 0x45, 0x75, 0xeb, 0x83, 0xa6, 0x6a, 0x36, 0xc5, 0xa2, 0xb9, 0xd0, 0xa2, 0x97, 0x1d, 0x09,
	0x9f, 0x38, 0x53, 0xf3, 0x06, 0xe4, 0x26, 0xcc, 0xc7, 0x2c, 0xfd, 0xf8, 0xa8, 0x9f, 0x22, 0x20,
	0xce, 0x82, 0x96, 0x65, 0x1f, 0x03, 0x3f, 0xaa, 0x1d, 0x31, 0x62, 0x86, 0x4b, 0x9d, 0x83, 0x29,
	0x55, 0xfc, 0x25, 0xfa, 0x36, 0x18, 0xe3, 0x2b, 0x00, 0xde, 0xc1, 0x64, 0x33, 0x7c, 0xe7, 0x35,
	0xc9, 0x39, 0x45, 0xc9, 0x3e, 0x45, 0xc9, 0x31, 0x8b, 0x38, 0x45, 0xe9, 0xb6, 0xda, 0xa0, 0x62,
	0x5d, 0xc5, 0x37, 0x93, 0xfc, 0x80, 0x60, 0x35, 0x15, 0x45, 0x54, 0xb9, 0x03, 0xb3, 0xaa, 0x4f,
	0x91, 0x45, 0x2b, 0x93, 0x1b, 0x33, 0xa5, 0x7c, 0xb8, 0x56, 0x4f, 0xc2, 0x0b, 0x0e, 0xcc, 0xc1,
	0x57, 0x63, 0x98, 0xd7, 0x87, 0x32, 0x3b, 0x00, 0x01, 0xe8, 0x3e, 0x2c, 0xc5, 0x30, 0xa7, 0x99,
	0xed, 0xd4, 0xfa, 0x75, 0x1f, 0x41, 0x3e, 0x69, 0xef, 0x71, 0x6c, 0xd5, 0xf7, 0xf1, 0xbc, 0xa7,
	0x77, 0x39, 0x4e, 0xad, 0xb3, 0x0f, 0x10, 0x2c, 0x27, 0x92, 0x8e, 0x63, 0x6b, 0xd7, 0xe0, 0x79,
	0xce, 0xab, 0x50, 0x93, 0xb5, 0x7a, 0x74, 0x70, 0x6d, 0xcf, 0x42, 0x46, 0xab, 0xf3, 0x2e, 0x3e,
	0xa5, 0x64, 0xb4, 0x3a, 0xb9, 0x0d, 0x2f, 0x84, 0x74, 0xa2, 0x9a, 0xd7, 0x60, 0xca, 0x10, 0xff,
	0x89, 0xa6, 0x2f, 0x84, 0x2a, 0x71, 0xa7, 0xf0, 0x32, 0x06, 0x62, 0xd2, 0x83, 0x5c, 0x60, 0xc5,
	0xff, 0xcb, 0xfc, 0xdf, 0x20, 0x58, 0x88, 0xdd, 0x58, 0x14, 0xf4, 0x06, 0x4c, 0xbb, 0x8c, 0xee,
	0xd9, 0xa4, 0x56, 0xe4, 0xa9, 0x4f, 0xef, 0x54, 0xbe, 0x8b, 0x61, 0x1c, 0x43, 0xb7, 0x7f, 0x8b,
	0x60, 0x31, 0x1e, 0x73, 0x8c, 0x7a, 0x19, 0xe3, 0xb3, 0x7d, 0xe5, 0x86, 0xcf, 0x67, 0x5d, 0xa3,
	0xe5, 0xfa, 0xac, 0x6b, 0xb4, 0xfe, 0x53, 0x9f, 0xf1, 0x8d, 0xc7, 0xa8, 0x37, 0x5b, 0x70, 0xfe,
	0x32, 0xd3, 0x7b, 0xd4, 0xb0, 0xca, 0x4a, 0x79, 0x8f, 0xf9, 0x2d, 0x16, 0x8d, 0x3a, 0x07, 0x90,
	0x8d, 0x8a, 0x45, 0x31, 0x4f, 0x98, 0x4d, 0xde, 0x1f, 0x70, 0xd8, 0xc3, 0x3d, 0xe6, 0x7b, 0x11,
	0x3c, 0xe1, 0xca, 0xdb, 0x03, 0x68, 0xdf, 0xca, 0x02, 0x3a, 0x5a, 0xe2, 0x57, 0x08, 0xc0, 0x8b,
	0x3a, 0x31, 0x2f, 0xa1, 0x30, 0x4d, 0xe6, 0xd1, 0x2e, 0xde, 0xeb, 0x30, 0x3d, 0x08, 0xad, 0xd9,
	0x49, 0x31, 0xd7, 0x89, 0xb5, 0x92, 0x1b, 0x6b, 0xa5, 0x3d, 0x57, 0xa1, 0x78, 0x62, 0xd2, 0x87,
	0xb9, 0xd0, 0x17, 0x21, 0x86, 0xce, 0x9f, 0xb5, 0x32, 0xa1, 0xac, 0xf5, 0xf8, 0x5b, 0x5f, 0x87,
	0x59, 0xbf, 0x11, 0xc3, 0x9f, 0x06, 0xf7, 0x0a, 0x65, 0xbc, 0x2b, 0x94, 0x85, 0x67, 0xda, 0xaa,
	0xae, 0x36, 0xa8, 0xc1, 0x77, 0x9a, 0x56, 0xdc, 0x61, 0xe9, 0x9f, 0x39, 0x78, 0x9a, 0x5f, 0x0a,
	0xfc, 0x00, 0xc1, 0x8c, 0x2f, 0x34, 0xe3, 0xb5, 0x50, 0x0f, 0x13, 0x22, 0x78, 0x6e, 0x7d, 0xa8,
	0xce, 0x39, 0x5d, 0x72, 0xf3, 0x93, 0xdf, 0xff, 0xfa, 0x22, 0x73, 0x0d, 0x13, 0x39, 0x18, 0xf5,
	0x9d, 0xf8, 0x5a, 0xa8, 0xf6, 0x0b, 0x9a, 0xa1, 0xc9, 0x87, 0x9a, 0xa1, 0x1d, 0x55, 0x08, 0x5e,
	0x89, 0x55, 0x99, 0xf2, 0x40, 0x83, 0xef, 0x23, 0x98, 0xf5, 0x67, 0x67, 0x9c, 0x4a, 0xe2, 0xbb,
	0x4a, 0xb9, 0x8d, 0xe1, 0x42, 0xc1, 0x7c, 0x9d, 0x33, 0xbf, 0x43, 0x96, 0x12, 0x99, 0x6d, 0xd7,
	0x5d, 0x42, 0x9b, 0x95, 0x15, 0xb2, 0x90, 0x40, 0x2c, 0x14, 0xf8, 0x6f, 0x04, 0x2f, 0xc6, 0xe7,
	0x61, 0x5c, 0x8c, 0x05, 0x4a, 0x8b, 0xf1, 0xb9, 0xd2, 0xa3, 0x4c, 0x11, 0xd5, 0xb4, 0x79, 0x35,
	0x0d, 0x5c, 0x0a, 0x93, 0xfa, 0xa6, 0xd9, 0x35, 0xb9, 0x1e, 0x95, 0x0f, 0xdd, 0x5f, 0x47, 0x95,
	0x22, 0x96, 0x53, 0x66, 0xc9, 0x31, 0x53, 0xf0, 0x6f, 0x08, 0x9e, 0x8b, 0x04, 0x5a, 0xbc, 0x3d,
	0x1c, 0xdc, 0xe7, 0xae, 0xc2, 0x88, 0x6a, 0x51, 0xe1, 0x01, 0xaf, 0xf0, 0x0e, 0xde, 0x18, 0x52,
	0xa1, 0xe7, 0xb4, 0x75, 0x7c, 0x31, 0xad, 0x2e, 0xcf, 0x6e, 0xbf, 0x22, 0xc0, 0xd1, 0x10, 0x89,
	0x47, 0x00, 0xf4, 0x5b, 0x4f, 0x1a, 0x55, 0x2e, 0x0a, 0xda, 0xe7, 0x05, 0xdd, 0x22, 0xab, 0x43,
	0x0a, 0x72, 0x6d, 0x78, 0x91, 0xac, 0xa4, 0x95, 0xe3, 0x7a, 0xf1, 0x6b, 0x04, 0x53, 0xee, 0x3b,
	0x04, 0xaf, 0xc6, 0x31, 0x85, 0xf2, 0x67, 0xee, 0x42, 0xba, 0x48, 0xe0, 0xbe, 0xcb, 0x71, 0xdf,
	0xc2, 0x8b, 0x21, 0x08, 0xf7, 0x53, 0x29, 0x1f, 0x6a, 0xf5, 0xa3, 0xca, 0x32, 0x5e, 0x4a, 0x78,
	0x6e, 0x72, 0x01, 0xfe, 0x19, 0xc1, 0xd9, 0x60, 0x1a, 0xc4, 0x2f, 0xa7, 0xed, 0x1f, 0xf4, 0xcc,
	0xe6, 0x28, 0x52, 0x01, 0x7c, 0x87, 0x03, 0xef, 0x46, 0x4c, 0x30, 0x00, 0x0a, 0xba, 0xe5, 0x42,
	0xe4, 0xed, 0xe5, 0x91, 0x7b, 0x56, 0xf9, 0x09, 0xc1, 0x5c, 0x28, 0x81, 0xe1, 0x61, 0x50, 0x7e,
	0x93, 0x6c, 0x8d, 0xa4, 0x15, 0x15, 0xdc, 0xe2, 0x15, 0x94, 0x23, 0xe7, 0x1e, 0xa8, 0xc0, 0xb5,
	0x07, 0x21, 0xc9, 0x9d, 0x77, 0xbd, 0xf1, 0x63, 0xb0, 0xf9, 0xfb, 0xca, 0x8d, 0xa1, 0xcd, 0xf7,
	0xf2, 0xdb, 0xd0, 0xe6, 0xfb, 0x12, 0x17, 0xd9, 0xe5, 0xe8, 0x57, 0xc9, 0x72, 0x1a, 0x7a, 0xd7,
	0x68, 0xd9, 0xe4, 0x2f, 0x91, 0xc5, 0x44, 0x72, 0x47, 0x82, 0xbf, 0x44, 0x70, 0x2e, 0x1c, 0x88,
	0x22, 0x9f, 0xb1, 0x84, 0x78, 0x15, 0xf9, 0x8c, 0x25, 0x25, 0x2b, 0xf2, 0x0a, 0x87, 0xde, 0x8c,
	0xbc, 0x62, 0x6a, 0xce, 0x04, 0xdb, 0x2c, 0x05, 0x8b, 0xf1, 0x8e, 0x0b, 0x3b, 0x7c, 0xee, 0x71,
	0x0d, 0x32, 0x4f, 0x12, 0x57, 0x38, 0x6e, 0x25, 0x71, 0x45, 0xc2, 0x13, 0x29, 0x70, 0xae, 0x75,
	0x42, 0x12, 0xb8, 0x6c, 0x20, 0x1b, 0x4c, 0x33, 0xb4, 0x4b, 0x68, 0x73, 0xe7, 0xca, 0x2f, 0xc7,
	0x79, 0xf4, 0xf0, 0x38, 0x8f, 0xfe, 0x3c, 0xce, 0xa3, 0xcf, 0x4e, 0xf2, 0x13, 0x0f, 0x4f, 0xf2,
	0x13, 0x7f, 0x9c, 0xe4, 0x27, 0x2a, 0xdb, 0x0d, 0xcd, 0x6a, 0x76, 0xab, 0x52, 0x8d, 0xb5, 0x9d,
	0xa5, 0x0a, 0x3a, 0xb5, 0x3e, 0x62, 0xc6, 0x87, 0x62, 0xd4, 0xa2, 0xf5, 0x06, 0x35, 0xe4, 0x8f,
	0xf9, 0x0e, 0xd5, 0x33, 0x3c, 0xab, 0xbc, 0xfa, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xa5, 0x10,
	0xd9, 0x40, 0x55, 0x14, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// QueryClient is the client API for Query service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QueryClient interface {
	// AnchorByIRI queries a data anchor by the IRI of the data.
	AnchorByIRI(ctx context.Context, in *QueryAnchorByIRIRequest, opts ...grpc.CallOption) (*QueryAnchorByIRIResponse, error)
	// AnchorByHash queries a data anchor by the ContentHash of the data.
	AnchorByHash(ctx context.Context, in *QueryAnchorByHashRequest, opts ...grpc.CallOption) (*QueryAnchorByHashResponse, error)
	// AttestationsByAttestor queries data attestations by an attestor.
	AttestationsByAttestor(ctx context.Context, in *QueryAttestationsByAttestorRequest, opts ...grpc.CallOption) (*QueryAttestationsByAttestorResponse, error)
	// AttestationsByIRI queries data attestations by the IRI of the data.
	AttestationsByIRI(ctx context.Context, in *QueryAttestationsByIRIRequest, opts ...grpc.CallOption) (*QueryAttestationsByIRIResponse, error)
	// AttestationsByHash queries data attestations by the ContentHash of the
	// data.
	AttestationsByHash(ctx context.Context, in *QueryAttestationsByHashRequest, opts ...grpc.CallOption) (*QueryAttestationsByHashResponse, error)
	// Resolver queries a resolver by its unique identifier.
	Resolver(ctx context.Context, in *QueryResolverRequest, opts ...grpc.CallOption) (*QueryResolverResponse, error)
	// ResolversByIRI queries resolvers with registered data by the IRI of the
	// data.
	ResolversByIRI(ctx context.Context, in *QueryResolversByIRIRequest, opts ...grpc.CallOption) (*QueryResolversByIRIResponse, error)
	// ResolversByHash queries resolvers with registered data by the ContentHash
	// of the data.
	ResolversByHash(ctx context.Context, in *QueryResolversByHashRequest, opts ...grpc.CallOption) (*QueryResolversByHashResponse, error)
	// ResolversByURL queries resolvers by URL.
	ResolversByURL(ctx context.Context, in *QueryResolversByURLRequest, opts ...grpc.CallOption) (*QueryResolversByURLResponse, error)
	// ConvertIRIToHash converts an IRI to a ContentHash.
	ConvertIRIToHash(ctx context.Context, in *ConvertIRIToHashRequest, opts ...grpc.CallOption) (*ConvertIRIToHashResponse, error)
	// ConvertHashToIRI converts a ContentHash to an IRI.
	ConvertHashToIRI(ctx context.Context, in *ConvertHashToIRIRequest, opts ...grpc.CallOption) (*ConvertHashToIRIResponse, error)
}

type queryClient struct {
	cc grpc1.ClientConn
}

func NewQueryClient(cc grpc1.ClientConn) QueryClient {
	return &queryClient{cc}
}

func (c *queryClient) AnchorByIRI(ctx context.Context, in *QueryAnchorByIRIRequest, opts ...grpc.CallOption) (*QueryAnchorByIRIResponse, error) {
	out := new(QueryAnchorByIRIResponse)
	err := c.cc.Invoke(ctx, "/regen.data.v1.Query/AnchorByIRI", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) AnchorByHash(ctx context.Context, in *QueryAnchorByHashRequest, opts ...grpc.CallOption) (*QueryAnchorByHashResponse, error) {
	out := new(QueryAnchorByHashResponse)
	err := c.cc.Invoke(ctx, "/regen.data.v1.Query/AnchorByHash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) AttestationsByAttestor(ctx context.Context, in *QueryAttestationsByAttestorRequest, opts ...grpc.CallOption) (*QueryAttestationsByAttestorResponse, error) {
	out := new(QueryAttestationsByAttestorResponse)
	err := c.cc.Invoke(ctx, "/regen.data.v1.Query/AttestationsByAttestor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) AttestationsByIRI(ctx context.Context, in *QueryAttestationsByIRIRequest, opts ...grpc.CallOption) (*QueryAttestationsByIRIResponse, error) {
	out := new(QueryAttestationsByIRIResponse)
	err := c.cc.Invoke(ctx, "/regen.data.v1.Query/AttestationsByIRI", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) AttestationsByHash(ctx context.Context, in *QueryAttestationsByHashRequest, opts ...grpc.CallOption) (*QueryAttestationsByHashResponse, error) {
	out := new(QueryAttestationsByHashResponse)
	err := c.cc.Invoke(ctx, "/regen.data.v1.Query/AttestationsByHash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Resolver(ctx context.Context, in *QueryResolverRequest, opts ...grpc.CallOption) (*QueryResolverResponse, error) {
	out := new(QueryResolverResponse)
	err := c.cc.Invoke(ctx, "/regen.data.v1.Query/Resolver", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) ResolversByIRI(ctx context.Context, in *QueryResolversByIRIRequest, opts ...grpc.CallOption) (*QueryResolversByIRIResponse, error) {
	out := new(QueryResolversByIRIResponse)
	err := c.cc.Invoke(ctx, "/regen.data.v1.Query/ResolversByIRI", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) ResolversByHash(ctx context.Context, in *QueryResolversByHashRequest, opts ...grpc.CallOption) (*QueryResolversByHashResponse, error) {
	out := new(QueryResolversByHashResponse)
	err := c.cc.Invoke(ctx, "/regen.data.v1.Query/ResolversByHash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) ResolversByURL(ctx context.Context, in *QueryResolversByURLRequest, opts ...grpc.CallOption) (*QueryResolversByURLResponse, error) {
	out := new(QueryResolversByURLResponse)
	err := c.cc.Invoke(ctx, "/regen.data.v1.Query/ResolversByURL", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) ConvertIRIToHash(ctx context.Context, in *ConvertIRIToHashRequest, opts ...grpc.CallOption) (*ConvertIRIToHashResponse, error) {
	out := new(ConvertIRIToHashResponse)
	err := c.cc.Invoke(ctx, "/regen.data.v1.Query/ConvertIRIToHash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) ConvertHashToIRI(ctx context.Context, in *ConvertHashToIRIRequest, opts ...grpc.CallOption) (*ConvertHashToIRIResponse, error) {
	out := new(ConvertHashToIRIResponse)
	err := c.cc.Invoke(ctx, "/regen.data.v1.Query/ConvertHashToIRI", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QueryServer is the server API for Query service.
type QueryServer interface {
	// AnchorByIRI queries a data anchor by the IRI of the data.
	AnchorByIRI(context.Context, *QueryAnchorByIRIRequest) (*QueryAnchorByIRIResponse, error)
	// AnchorByHash queries a data anchor by the ContentHash of the data.
	AnchorByHash(context.Context, *QueryAnchorByHashRequest) (*QueryAnchorByHashResponse, error)
	// AttestationsByAttestor queries data attestations by an attestor.
	AttestationsByAttestor(context.Context, *QueryAttestationsByAttestorRequest) (*QueryAttestationsByAttestorResponse, error)
	// AttestationsByIRI queries data attestations by the IRI of the data.
	AttestationsByIRI(context.Context, *QueryAttestationsByIRIRequest) (*QueryAttestationsByIRIResponse, error)
	// AttestationsByHash queries data attestations by the ContentHash of the
	// data.
	AttestationsByHash(context.Context, *QueryAttestationsByHashRequest) (*QueryAttestationsByHashResponse, error)
	// Resolver queries a resolver by its unique identifier.
	Resolver(context.Context, *QueryResolverRequest) (*QueryResolverResponse, error)
	// ResolversByIRI queries resolvers with registered data by the IRI of the
	// data.
	ResolversByIRI(context.Context, *QueryResolversByIRIRequest) (*QueryResolversByIRIResponse, error)
	// ResolversByHash queries resolvers with registered data by the ContentHash
	// of the data.
	ResolversByHash(context.Context, *QueryResolversByHashRequest) (*QueryResolversByHashResponse, error)
	// ResolversByURL queries resolvers by URL.
	ResolversByURL(context.Context, *QueryResolversByURLRequest) (*QueryResolversByURLResponse, error)
	// ConvertIRIToHash converts an IRI to a ContentHash.
	ConvertIRIToHash(context.Context, *ConvertIRIToHashRequest) (*ConvertIRIToHashResponse, error)
	// ConvertHashToIRI converts a ContentHash to an IRI.
	ConvertHashToIRI(context.Context, *ConvertHashToIRIRequest) (*ConvertHashToIRIResponse, error)
}

// UnimplementedQueryServer can be embedded to have forward compatible implementations.
type UnimplementedQueryServer struct {
}

func (*UnimplementedQueryServer) AnchorByIRI(ctx context.Context, req *QueryAnchorByIRIRequest) (*QueryAnchorByIRIResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AnchorByIRI not implemented")
}
func (*UnimplementedQueryServer) AnchorByHash(ctx context.Context, req *QueryAnchorByHashRequest) (*QueryAnchorByHashResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AnchorByHash not implemented")
}
func (*UnimplementedQueryServer) AttestationsByAttestor(ctx context.Context, req *QueryAttestationsByAttestorRequest) (*QueryAttestationsByAttestorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AttestationsByAttestor not implemented")
}
func (*UnimplementedQueryServer) AttestationsByIRI(ctx context.Context, req *QueryAttestationsByIRIRequest) (*QueryAttestationsByIRIResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AttestationsByIRI not implemented")
}
func (*UnimplementedQueryServer) AttestationsByHash(ctx context.Context, req *QueryAttestationsByHashRequest) (*QueryAttestationsByHashResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AttestationsByHash not implemented")
}
func (*UnimplementedQueryServer) Resolver(ctx context.Context, req *QueryResolverRequest) (*QueryResolverResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Resolver not implemented")
}
func (*UnimplementedQueryServer) ResolversByIRI(ctx context.Context, req *QueryResolversByIRIRequest) (*QueryResolversByIRIResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResolversByIRI not implemented")
}
func (*UnimplementedQueryServer) ResolversByHash(ctx context.Context, req *QueryResolversByHashRequest) (*QueryResolversByHashResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResolversByHash not implemented")
}
func (*UnimplementedQueryServer) ResolversByURL(ctx context.Context, req *QueryResolversByURLRequest) (*QueryResolversByURLResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResolversByURL not implemented")
}
func (*UnimplementedQueryServer) ConvertIRIToHash(ctx context.Context, req *ConvertIRIToHashRequest) (*ConvertIRIToHashResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConvertIRIToHash not implemented")
}
func (*UnimplementedQueryServer) ConvertHashToIRI(ctx context.Context, req *ConvertHashToIRIRequest) (*ConvertHashToIRIResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConvertHashToIRI not implemented")
}

func RegisterQueryServer(s grpc1.Server, srv QueryServer) {
	s.RegisterService(&_Query_serviceDesc, srv)
}

func _Query_AnchorByIRI_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryAnchorByIRIRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).AnchorByIRI(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.data.v1.Query/AnchorByIRI",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).AnchorByIRI(ctx, req.(*QueryAnchorByIRIRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_AnchorByHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryAnchorByHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).AnchorByHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.data.v1.Query/AnchorByHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).AnchorByHash(ctx, req.(*QueryAnchorByHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_AttestationsByAttestor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryAttestationsByAttestorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).AttestationsByAttestor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.data.v1.Query/AttestationsByAttestor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).AttestationsByAttestor(ctx, req.(*QueryAttestationsByAttestorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_AttestationsByIRI_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryAttestationsByIRIRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).AttestationsByIRI(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.data.v1.Query/AttestationsByIRI",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).AttestationsByIRI(ctx, req.(*QueryAttestationsByIRIRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_AttestationsByHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryAttestationsByHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).AttestationsByHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.data.v1.Query/AttestationsByHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).AttestationsByHash(ctx, req.(*QueryAttestationsByHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_Resolver_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryResolverRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Resolver(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.data.v1.Query/Resolver",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Resolver(ctx, req.(*QueryResolverRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_ResolversByIRI_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryResolversByIRIRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).ResolversByIRI(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.data.v1.Query/ResolversByIRI",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).ResolversByIRI(ctx, req.(*QueryResolversByIRIRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_ResolversByHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryResolversByHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).ResolversByHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.data.v1.Query/ResolversByHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).ResolversByHash(ctx, req.(*QueryResolversByHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_ResolversByURL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryResolversByURLRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).ResolversByURL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.data.v1.Query/ResolversByURL",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).ResolversByURL(ctx, req.(*QueryResolversByURLRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_ConvertIRIToHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConvertIRIToHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).ConvertIRIToHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.data.v1.Query/ConvertIRIToHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).ConvertIRIToHash(ctx, req.(*ConvertIRIToHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_ConvertHashToIRI_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConvertHashToIRIRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).ConvertHashToIRI(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.data.v1.Query/ConvertHashToIRI",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).ConvertHashToIRI(ctx, req.(*ConvertHashToIRIRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Query_serviceDesc = grpc.ServiceDesc{
	ServiceName: "regen.data.v1.Query",
	HandlerType: (*QueryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AnchorByIRI",
			Handler:    _Query_AnchorByIRI_Handler,
		},
		{
			MethodName: "AnchorByHash",
			Handler:    _Query_AnchorByHash_Handler,
		},
		{
			MethodName: "AttestationsByAttestor",
			Handler:    _Query_AttestationsByAttestor_Handler,
		},
		{
			MethodName: "AttestationsByIRI",
			Handler:    _Query_AttestationsByIRI_Handler,
		},
		{
			MethodName: "AttestationsByHash",
			Handler:    _Query_AttestationsByHash_Handler,
		},
		{
			MethodName: "Resolver",
			Handler:    _Query_Resolver_Handler,
		},
		{
			MethodName: "ResolversByIRI",
			Handler:    _Query_ResolversByIRI_Handler,
		},
		{
			MethodName: "ResolversByHash",
			Handler:    _Query_ResolversByHash_Handler,
		},
		{
			MethodName: "ResolversByURL",
			Handler:    _Query_ResolversByURL_Handler,
		},
		{
			MethodName: "ConvertIRIToHash",
			Handler:    _Query_ConvertIRIToHash_Handler,
		},
		{
			MethodName: "ConvertHashToIRI",
			Handler:    _Query_ConvertHashToIRI_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "regen/data/v1/query.proto",
}

func (m *QueryAnchorByIRIRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryAnchorByIRIRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryAnchorByIRIRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Iri) > 0 {
		i -= len(m.Iri)
		copy(dAtA[i:], m.Iri)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Iri)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryAnchorByIRIResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryAnchorByIRIResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryAnchorByIRIResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Anchor != nil {
		{
			size, err := m.Anchor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryAnchorByHashRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryAnchorByHashRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryAnchorByHashRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ContentHash != nil {
		{
			size, err := m.ContentHash.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryAnchorByHashResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryAnchorByHashResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryAnchorByHashResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Anchor != nil {
		{
			size, err := m.Anchor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryAttestationsByAttestorRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryAttestationsByAttestorRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryAttestationsByAttestorRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Attestor) > 0 {
		i -= len(m.Attestor)
		copy(dAtA[i:], m.Attestor)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Attestor)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryAttestationsByAttestorResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryAttestationsByAttestorResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryAttestationsByAttestorResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Attestations) > 0 {
		for iNdEx := len(m.Attestations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Attestations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryAttestationsByIRIRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryAttestationsByIRIRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryAttestationsByIRIRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Iri) > 0 {
		i -= len(m.Iri)
		copy(dAtA[i:], m.Iri)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Iri)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryAttestationsByIRIResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryAttestationsByIRIResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryAttestationsByIRIResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Attestations) > 0 {
		for iNdEx := len(m.Attestations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Attestations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryAttestationsByHashRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryAttestationsByHashRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryAttestationsByHashRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ContentHash != nil {
		{
			size, err := m.ContentHash.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryAttestationsByHashResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryAttestationsByHashResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryAttestationsByHashResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Attestations) > 0 {
		for iNdEx := len(m.Attestations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Attestations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryResolverRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryResolverRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryResolverRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryResolverResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryResolverResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryResolverResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Resolver != nil {
		{
			size, err := m.Resolver.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryResolversByIRIRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryResolversByIRIRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryResolversByIRIRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Iri) > 0 {
		i -= len(m.Iri)
		copy(dAtA[i:], m.Iri)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Iri)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryResolversByIRIResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryResolversByIRIResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryResolversByIRIResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Resolvers) > 0 {
		for iNdEx := len(m.Resolvers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Resolvers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryResolversByHashRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryResolversByHashRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryResolversByHashRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ContentHash != nil {
		{
			size, err := m.ContentHash.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryResolversByHashResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryResolversByHashResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryResolversByHashResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Resolvers) > 0 {
		for iNdEx := len(m.Resolvers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Resolvers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryResolversByURLRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryResolversByURLRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryResolversByURLRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryResolversByURLResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryResolversByURLResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryResolversByURLResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Resolvers) > 0 {
		for iNdEx := len(m.Resolvers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Resolvers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ConvertIRIToHashRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConvertIRIToHashRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConvertIRIToHashRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Iri) > 0 {
		i -= len(m.Iri)
		copy(dAtA[i:], m.Iri)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Iri)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConvertIRIToHashResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConvertIRIToHashResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConvertIRIToHashResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ContentHash != nil {
		{
			size, err := m.ContentHash.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConvertHashToIRIRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConvertHashToIRIRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConvertHashToIRIRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ContentHash != nil {
		{
			size, err := m.ContentHash.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConvertHashToIRIResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConvertHashToIRIResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConvertHashToIRIResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Iri) > 0 {
		i -= len(m.Iri)
		copy(dAtA[i:], m.Iri)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Iri)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AnchorInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnchorInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AnchorInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timestamp != nil {
		{
			size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ContentHash != nil {
		{
			size, err := m.ContentHash.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Iri) > 0 {
		i -= len(m.Iri)
		copy(dAtA[i:], m.Iri)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Iri)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AttestationInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttestationInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttestationInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timestamp != nil {
		{
			size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Attestor) > 0 {
		i -= len(m.Attestor)
		copy(dAtA[i:], m.Attestor)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Attestor)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Iri) > 0 {
		i -= len(m.Iri)
		copy(dAtA[i:], m.Iri)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Iri)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResolverInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResolverInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResolverInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Manager) > 0 {
		i -= len(m.Manager)
		copy(dAtA[i:], m.Manager)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Manager)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintQuery(dAtA []byte, offset int, v uint64) int {
	offset -= sovQuery(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *QueryAnchorByIRIRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Iri)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryAnchorByIRIResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Anchor != nil {
		l = m.Anchor.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryAnchorByHashRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ContentHash != nil {
		l = m.ContentHash.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryAnchorByHashResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Anchor != nil {
		l = m.Anchor.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryAttestationsByAttestorRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Attestor)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryAttestationsByAttestorResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Attestations) > 0 {
		for _, e := range m.Attestations {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryAttestationsByIRIRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Iri)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryAttestationsByIRIResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Attestations) > 0 {
		for _, e := range m.Attestations {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryAttestationsByHashRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ContentHash != nil {
		l = m.ContentHash.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryAttestationsByHashResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Attestations) > 0 {
		for _, e := range m.Attestations {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryResolverRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovQuery(uint64(m.Id))
	}
	return n
}

func (m *QueryResolverResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Resolver != nil {
		l = m.Resolver.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryResolversByIRIRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Iri)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryResolversByIRIResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Resolvers) > 0 {
		for _, e := range m.Resolvers {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryResolversByHashRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ContentHash != nil {
		l = m.ContentHash.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryResolversByHashResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Resolvers) > 0 {
		for _, e := range m.Resolvers {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryResolversByURLRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryResolversByURLResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Resolvers) > 0 {
		for _, e := range m.Resolvers {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *ConvertIRIToHashRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Iri)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *ConvertIRIToHashResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ContentHash != nil {
		l = m.ContentHash.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *ConvertHashToIRIRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ContentHash != nil {
		l = m.ContentHash.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *ConvertHashToIRIResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Iri)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *AnchorInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Iri)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.ContentHash != nil {
		l = m.ContentHash.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *AttestationInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Iri)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Attestor)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *ResolverInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovQuery(uint64(m.Id))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Manager)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func sovQuery(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozQuery(x uint64) (n int) {
	return sovQuery(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *QueryAnchorByIRIRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryAnchorByIRIRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryAnchorByIRIRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Iri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Iri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryAnchorByIRIResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryAnchorByIRIResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryAnchorByIRIResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Anchor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Anchor == nil {
				m.Anchor = &AnchorInfo{}
			}
			if err := m.Anchor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryAnchorByHashRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryAnchorByHashRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryAnchorByHashRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentHash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContentHash == nil {
				m.ContentHash = &ContentHash{}
			}
			if err := m.ContentHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryAnchorByHashResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryAnchorByHashResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryAnchorByHashResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Anchor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Anchor == nil {
				m.Anchor = &AnchorInfo{}
			}
			if err := m.Anchor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryAttestationsByAttestorRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryAttestationsByAttestorRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryAttestationsByAttestorRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attestor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attestor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageRequest{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryAttestationsByAttestorResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryAttestationsByAttestorResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryAttestationsByAttestorResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attestations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attestations = append(m.Attestations, &AttestationInfo{})
			if err := m.Attestations[len(m.Attestations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageResponse{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryAttestationsByIRIRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryAttestationsByIRIRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryAttestationsByIRIRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Iri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Iri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageRequest{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryAttestationsByIRIResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryAttestationsByIRIResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryAttestationsByIRIResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attestations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attestations = append(m.Attestations, &AttestationInfo{})
			if err := m.Attestations[len(m.Attestations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageResponse{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryAttestationsByHashRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryAttestationsByHashRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryAttestationsByHashRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentHash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContentHash == nil {
				m.ContentHash = &ContentHash{}
			}
			if err := m.ContentHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageRequest{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryAttestationsByHashResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryAttestationsByHashResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryAttestationsByHashResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attestations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attestations = append(m.Attestations, &AttestationInfo{})
			if err := m.Attestations[len(m.Attestations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageResponse{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryResolverRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryResolverRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryResolverRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryResolverResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryResolverResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryResolverResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resolver", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resolver == nil {
				m.Resolver = &ResolverInfo{}
			}
			if err := m.Resolver.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryResolversByIRIRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryResolversByIRIRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryResolversByIRIRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Iri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Iri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageRequest{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryResolversByIRIResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryResolversByIRIResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryResolversByIRIResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resolvers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resolvers = append(m.Resolvers, &ResolverInfo{})
			if err := m.Resolvers[len(m.Resolvers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageResponse{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryResolversByHashRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryResolversByHashRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryResolversByHashRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentHash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContentHash == nil {
				m.ContentHash = &ContentHash{}
			}
			if err := m.ContentHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageRequest{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryResolversByHashResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryResolversByHashResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryResolversByHashResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resolvers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resolvers = append(m.Resolvers, &ResolverInfo{})
			if err := m.Resolvers[len(m.Resolvers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageResponse{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryResolversByURLRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryResolversByURLRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryResolversByURLRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageRequest{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryResolversByURLResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryResolversByURLResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryResolversByURLResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resolvers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resolvers = append(m.Resolvers, &ResolverInfo{})
			if err := m.Resolvers[len(m.Resolvers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageResponse{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConvertIRIToHashRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConvertIRIToHashRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConvertIRIToHashRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Iri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Iri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConvertIRIToHashResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConvertIRIToHashResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConvertIRIToHashResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentHash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContentHash == nil {
				m.ContentHash = &ContentHash{}
			}
			if err := m.ContentHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConvertHashToIRIRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConvertHashToIRIRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConvertHashToIRIRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentHash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContentHash == nil {
				m.ContentHash = &ContentHash{}
			}
			if err := m.ContentHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConvertHashToIRIResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConvertHashToIRIResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConvertHashToIRIResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Iri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Iri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnchorInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnchorInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnchorInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Iri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Iri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentHash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContentHash == nil {
				m.ContentHash = &ContentHash{}
			}
			if err := m.ContentHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &types.Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttestationInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttestationInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttestationInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Iri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Iri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attestor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attestor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &types.Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResolverInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResolverInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResolverInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Manager", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Manager = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipQuery(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthQuery
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupQuery
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthQuery
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthQuery        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowQuery          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupQuery = fmt.Errorf("proto: unexpected end of group")
)
