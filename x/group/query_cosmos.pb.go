// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package group

import (
	context "context"
	types "github.com/regen-network/regen-ledger/types"
	grpc "google.golang.org/grpc"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion7

// QueryClient is the client API for Query service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type QueryClient interface {
	// GroupInfo queries group info based on group id.
	GroupInfo(ctx context.Context, in *QueryGroupInfoRequest, opts ...grpc.CallOption) (*QueryGroupInfoResponse, error)
	// GroupAccountInfo queries group account info based on group account address.
	GroupAccountInfo(ctx context.Context, in *QueryGroupAccountInfoRequest, opts ...grpc.CallOption) (*QueryGroupAccountInfoResponse, error)
	// GroupMembers queries members for a group
	GroupMembers(ctx context.Context, in *QueryGroupMembersRequest, opts ...grpc.CallOption) (*QueryGroupMembersResponse, error)
	// GroupsByAdmin queries groups by admin address.
	GroupsByAdmin(ctx context.Context, in *QueryGroupsByAdminRequest, opts ...grpc.CallOption) (*QueryGroupsByAdminResponse, error)
	// GroupAccountsByGroup queries group accounts by group id.
	GroupAccountsByGroup(ctx context.Context, in *QueryGroupAccountsByGroupRequest, opts ...grpc.CallOption) (*QueryGroupAccountsByGroupResponse, error)
	// GroupsByAdmin queries group accounts by admin address.
	GroupAccountsByAdmin(ctx context.Context, in *QueryGroupAccountsByAdminRequest, opts ...grpc.CallOption) (*QueryGroupAccountsByAdminResponse, error)
	// Proposal queries a proposal based on proposal id.
	Proposal(ctx context.Context, in *QueryProposalRequest, opts ...grpc.CallOption) (*QueryProposalResponse, error)
	// ProposalsByGroupAccount queries proposals based on group account address.
	ProposalsByGroupAccount(ctx context.Context, in *QueryProposalsByGroupAccountRequest, opts ...grpc.CallOption) (*QueryProposalsByGroupAccountResponse, error)
	// VoteByProposalVoter queries a vote by proposal id and voter.
	VoteByProposalVoter(ctx context.Context, in *QueryVoteByProposalVoterRequest, opts ...grpc.CallOption) (*QueryVoteByProposalVoterResponse, error)
	// VotesByProposal queries a vote by proposal.
	VotesByProposal(ctx context.Context, in *QueryVotesByProposalRequest, opts ...grpc.CallOption) (*QueryVotesByProposalResponse, error)
	// VotesByVoter queries a vote by voter.
	VotesByVoter(ctx context.Context, in *QueryVotesByVoterRequest, opts ...grpc.CallOption) (*QueryVotesByVoterResponse, error)
}

type queryClient struct {
	cc                       grpc.ClientConnInterface
	_GroupInfo               types.Invoker
	_GroupAccountInfo        types.Invoker
	_GroupMembers            types.Invoker
	_GroupsByAdmin           types.Invoker
	_GroupAccountsByGroup    types.Invoker
	_GroupAccountsByAdmin    types.Invoker
	_Proposal                types.Invoker
	_ProposalsByGroupAccount types.Invoker
	_VoteByProposalVoter     types.Invoker
	_VotesByProposal         types.Invoker
	_VotesByVoter            types.Invoker
}

func NewQueryClient(cc grpc.ClientConnInterface) QueryClient {
	return &queryClient{cc: cc}
}

func (c *queryClient) GroupInfo(ctx context.Context, in *QueryGroupInfoRequest, opts ...grpc.CallOption) (*QueryGroupInfoResponse, error) {
	if invoker := c._GroupInfo; invoker != nil {
		var out QueryGroupInfoResponse
		err := invoker(ctx, in, &out)
		return &out, err
	}
	if invokerConn, ok := c.cc.(types.InvokerConn); ok {
		var err error
		c._GroupInfo, err = invokerConn.Invoker("/regen.group.v1alpha1.Query/GroupInfo")
		if err != nil {
			var out QueryGroupInfoResponse
			err = c._GroupInfo(ctx, in, &out)
			return &out, err
		}
	}
	out := new(QueryGroupInfoResponse)
	err := c.cc.Invoke(ctx, "/regen.group.v1alpha1.Query/GroupInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) GroupAccountInfo(ctx context.Context, in *QueryGroupAccountInfoRequest, opts ...grpc.CallOption) (*QueryGroupAccountInfoResponse, error) {
	if invoker := c._GroupAccountInfo; invoker != nil {
		var out QueryGroupAccountInfoResponse
		err := invoker(ctx, in, &out)
		return &out, err
	}
	if invokerConn, ok := c.cc.(types.InvokerConn); ok {
		var err error
		c._GroupAccountInfo, err = invokerConn.Invoker("/regen.group.v1alpha1.Query/GroupAccountInfo")
		if err != nil {
			var out QueryGroupAccountInfoResponse
			err = c._GroupAccountInfo(ctx, in, &out)
			return &out, err
		}
	}
	out := new(QueryGroupAccountInfoResponse)
	err := c.cc.Invoke(ctx, "/regen.group.v1alpha1.Query/GroupAccountInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) GroupMembers(ctx context.Context, in *QueryGroupMembersRequest, opts ...grpc.CallOption) (*QueryGroupMembersResponse, error) {
	if invoker := c._GroupMembers; invoker != nil {
		var out QueryGroupMembersResponse
		err := invoker(ctx, in, &out)
		return &out, err
	}
	if invokerConn, ok := c.cc.(types.InvokerConn); ok {
		var err error
		c._GroupMembers, err = invokerConn.Invoker("/regen.group.v1alpha1.Query/GroupMembers")
		if err != nil {
			var out QueryGroupMembersResponse
			err = c._GroupMembers(ctx, in, &out)
			return &out, err
		}
	}
	out := new(QueryGroupMembersResponse)
	err := c.cc.Invoke(ctx, "/regen.group.v1alpha1.Query/GroupMembers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) GroupsByAdmin(ctx context.Context, in *QueryGroupsByAdminRequest, opts ...grpc.CallOption) (*QueryGroupsByAdminResponse, error) {
	if invoker := c._GroupsByAdmin; invoker != nil {
		var out QueryGroupsByAdminResponse
		err := invoker(ctx, in, &out)
		return &out, err
	}
	if invokerConn, ok := c.cc.(types.InvokerConn); ok {
		var err error
		c._GroupsByAdmin, err = invokerConn.Invoker("/regen.group.v1alpha1.Query/GroupsByAdmin")
		if err != nil {
			var out QueryGroupsByAdminResponse
			err = c._GroupsByAdmin(ctx, in, &out)
			return &out, err
		}
	}
	out := new(QueryGroupsByAdminResponse)
	err := c.cc.Invoke(ctx, "/regen.group.v1alpha1.Query/GroupsByAdmin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) GroupAccountsByGroup(ctx context.Context, in *QueryGroupAccountsByGroupRequest, opts ...grpc.CallOption) (*QueryGroupAccountsByGroupResponse, error) {
	if invoker := c._GroupAccountsByGroup; invoker != nil {
		var out QueryGroupAccountsByGroupResponse
		err := invoker(ctx, in, &out)
		return &out, err
	}
	if invokerConn, ok := c.cc.(types.InvokerConn); ok {
		var err error
		c._GroupAccountsByGroup, err = invokerConn.Invoker("/regen.group.v1alpha1.Query/GroupAccountsByGroup")
		if err != nil {
			var out QueryGroupAccountsByGroupResponse
			err = c._GroupAccountsByGroup(ctx, in, &out)
			return &out, err
		}
	}
	out := new(QueryGroupAccountsByGroupResponse)
	err := c.cc.Invoke(ctx, "/regen.group.v1alpha1.Query/GroupAccountsByGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) GroupAccountsByAdmin(ctx context.Context, in *QueryGroupAccountsByAdminRequest, opts ...grpc.CallOption) (*QueryGroupAccountsByAdminResponse, error) {
	if invoker := c._GroupAccountsByAdmin; invoker != nil {
		var out QueryGroupAccountsByAdminResponse
		err := invoker(ctx, in, &out)
		return &out, err
	}
	if invokerConn, ok := c.cc.(types.InvokerConn); ok {
		var err error
		c._GroupAccountsByAdmin, err = invokerConn.Invoker("/regen.group.v1alpha1.Query/GroupAccountsByAdmin")
		if err != nil {
			var out QueryGroupAccountsByAdminResponse
			err = c._GroupAccountsByAdmin(ctx, in, &out)
			return &out, err
		}
	}
	out := new(QueryGroupAccountsByAdminResponse)
	err := c.cc.Invoke(ctx, "/regen.group.v1alpha1.Query/GroupAccountsByAdmin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Proposal(ctx context.Context, in *QueryProposalRequest, opts ...grpc.CallOption) (*QueryProposalResponse, error) {
	if invoker := c._Proposal; invoker != nil {
		var out QueryProposalResponse
		err := invoker(ctx, in, &out)
		return &out, err
	}
	if invokerConn, ok := c.cc.(types.InvokerConn); ok {
		var err error
		c._Proposal, err = invokerConn.Invoker("/regen.group.v1alpha1.Query/Proposal")
		if err != nil {
			var out QueryProposalResponse
			err = c._Proposal(ctx, in, &out)
			return &out, err
		}
	}
	out := new(QueryProposalResponse)
	err := c.cc.Invoke(ctx, "/regen.group.v1alpha1.Query/Proposal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) ProposalsByGroupAccount(ctx context.Context, in *QueryProposalsByGroupAccountRequest, opts ...grpc.CallOption) (*QueryProposalsByGroupAccountResponse, error) {
	if invoker := c._ProposalsByGroupAccount; invoker != nil {
		var out QueryProposalsByGroupAccountResponse
		err := invoker(ctx, in, &out)
		return &out, err
	}
	if invokerConn, ok := c.cc.(types.InvokerConn); ok {
		var err error
		c._ProposalsByGroupAccount, err = invokerConn.Invoker("/regen.group.v1alpha1.Query/ProposalsByGroupAccount")
		if err != nil {
			var out QueryProposalsByGroupAccountResponse
			err = c._ProposalsByGroupAccount(ctx, in, &out)
			return &out, err
		}
	}
	out := new(QueryProposalsByGroupAccountResponse)
	err := c.cc.Invoke(ctx, "/regen.group.v1alpha1.Query/ProposalsByGroupAccount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) VoteByProposalVoter(ctx context.Context, in *QueryVoteByProposalVoterRequest, opts ...grpc.CallOption) (*QueryVoteByProposalVoterResponse, error) {
	if invoker := c._VoteByProposalVoter; invoker != nil {
		var out QueryVoteByProposalVoterResponse
		err := invoker(ctx, in, &out)
		return &out, err
	}
	if invokerConn, ok := c.cc.(types.InvokerConn); ok {
		var err error
		c._VoteByProposalVoter, err = invokerConn.Invoker("/regen.group.v1alpha1.Query/VoteByProposalVoter")
		if err != nil {
			var out QueryVoteByProposalVoterResponse
			err = c._VoteByProposalVoter(ctx, in, &out)
			return &out, err
		}
	}
	out := new(QueryVoteByProposalVoterResponse)
	err := c.cc.Invoke(ctx, "/regen.group.v1alpha1.Query/VoteByProposalVoter", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) VotesByProposal(ctx context.Context, in *QueryVotesByProposalRequest, opts ...grpc.CallOption) (*QueryVotesByProposalResponse, error) {
	if invoker := c._VotesByProposal; invoker != nil {
		var out QueryVotesByProposalResponse
		err := invoker(ctx, in, &out)
		return &out, err
	}
	if invokerConn, ok := c.cc.(types.InvokerConn); ok {
		var err error
		c._VotesByProposal, err = invokerConn.Invoker("/regen.group.v1alpha1.Query/VotesByProposal")
		if err != nil {
			var out QueryVotesByProposalResponse
			err = c._VotesByProposal(ctx, in, &out)
			return &out, err
		}
	}
	out := new(QueryVotesByProposalResponse)
	err := c.cc.Invoke(ctx, "/regen.group.v1alpha1.Query/VotesByProposal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) VotesByVoter(ctx context.Context, in *QueryVotesByVoterRequest, opts ...grpc.CallOption) (*QueryVotesByVoterResponse, error) {
	if invoker := c._VotesByVoter; invoker != nil {
		var out QueryVotesByVoterResponse
		err := invoker(ctx, in, &out)
		return &out, err
	}
	if invokerConn, ok := c.cc.(types.InvokerConn); ok {
		var err error
		c._VotesByVoter, err = invokerConn.Invoker("/regen.group.v1alpha1.Query/VotesByVoter")
		if err != nil {
			var out QueryVotesByVoterResponse
			err = c._VotesByVoter(ctx, in, &out)
			return &out, err
		}
	}
	out := new(QueryVotesByVoterResponse)
	err := c.cc.Invoke(ctx, "/regen.group.v1alpha1.Query/VotesByVoter", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QueryServer is the server API for Query service.
type QueryServer interface {
	// GroupInfo queries group info based on group id.
	GroupInfo(types.Context, *QueryGroupInfoRequest) (*QueryGroupInfoResponse, error)
	// GroupAccountInfo queries group account info based on group account address.
	GroupAccountInfo(types.Context, *QueryGroupAccountInfoRequest) (*QueryGroupAccountInfoResponse, error)
	// GroupMembers queries members for a group
	GroupMembers(types.Context, *QueryGroupMembersRequest) (*QueryGroupMembersResponse, error)
	// GroupsByAdmin queries groups by admin address.
	GroupsByAdmin(types.Context, *QueryGroupsByAdminRequest) (*QueryGroupsByAdminResponse, error)
	// GroupAccountsByGroup queries group accounts by group id.
	GroupAccountsByGroup(types.Context, *QueryGroupAccountsByGroupRequest) (*QueryGroupAccountsByGroupResponse, error)
	// GroupsByAdmin queries group accounts by admin address.
	GroupAccountsByAdmin(types.Context, *QueryGroupAccountsByAdminRequest) (*QueryGroupAccountsByAdminResponse, error)
	// Proposal queries a proposal based on proposal id.
	Proposal(types.Context, *QueryProposalRequest) (*QueryProposalResponse, error)
	// ProposalsByGroupAccount queries proposals based on group account address.
	ProposalsByGroupAccount(types.Context, *QueryProposalsByGroupAccountRequest) (*QueryProposalsByGroupAccountResponse, error)
	// VoteByProposalVoter queries a vote by proposal id and voter.
	VoteByProposalVoter(types.Context, *QueryVoteByProposalVoterRequest) (*QueryVoteByProposalVoterResponse, error)
	// VotesByProposal queries a vote by proposal.
	VotesByProposal(types.Context, *QueryVotesByProposalRequest) (*QueryVotesByProposalResponse, error)
	// VotesByVoter queries a vote by voter.
	VotesByVoter(types.Context, *QueryVotesByVoterRequest) (*QueryVotesByVoterResponse, error)
}

func RegisterQueryServer(s grpc.ServiceRegistrar, srv QueryServer) {
	s.RegisterService(&Query_ServiceDesc, srv)
}

func _Query_GroupInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryGroupInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).GroupInfo(types.UnwrapSDKContext(ctx), in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.group.v1alpha1.Query/GroupInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).GroupInfo(types.UnwrapSDKContext(ctx), req.(*QueryGroupInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_GroupAccountInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryGroupAccountInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).GroupAccountInfo(types.UnwrapSDKContext(ctx), in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.group.v1alpha1.Query/GroupAccountInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).GroupAccountInfo(types.UnwrapSDKContext(ctx), req.(*QueryGroupAccountInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_GroupMembers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryGroupMembersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).GroupMembers(types.UnwrapSDKContext(ctx), in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.group.v1alpha1.Query/GroupMembers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).GroupMembers(types.UnwrapSDKContext(ctx), req.(*QueryGroupMembersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_GroupsByAdmin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryGroupsByAdminRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).GroupsByAdmin(types.UnwrapSDKContext(ctx), in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.group.v1alpha1.Query/GroupsByAdmin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).GroupsByAdmin(types.UnwrapSDKContext(ctx), req.(*QueryGroupsByAdminRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_GroupAccountsByGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryGroupAccountsByGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).GroupAccountsByGroup(types.UnwrapSDKContext(ctx), in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.group.v1alpha1.Query/GroupAccountsByGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).GroupAccountsByGroup(types.UnwrapSDKContext(ctx), req.(*QueryGroupAccountsByGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_GroupAccountsByAdmin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryGroupAccountsByAdminRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).GroupAccountsByAdmin(types.UnwrapSDKContext(ctx), in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.group.v1alpha1.Query/GroupAccountsByAdmin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).GroupAccountsByAdmin(types.UnwrapSDKContext(ctx), req.(*QueryGroupAccountsByAdminRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_Proposal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryProposalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Proposal(types.UnwrapSDKContext(ctx), in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.group.v1alpha1.Query/Proposal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Proposal(types.UnwrapSDKContext(ctx), req.(*QueryProposalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_ProposalsByGroupAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryProposalsByGroupAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).ProposalsByGroupAccount(types.UnwrapSDKContext(ctx), in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.group.v1alpha1.Query/ProposalsByGroupAccount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).ProposalsByGroupAccount(types.UnwrapSDKContext(ctx), req.(*QueryProposalsByGroupAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_VoteByProposalVoter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryVoteByProposalVoterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).VoteByProposalVoter(types.UnwrapSDKContext(ctx), in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.group.v1alpha1.Query/VoteByProposalVoter",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).VoteByProposalVoter(types.UnwrapSDKContext(ctx), req.(*QueryVoteByProposalVoterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_VotesByProposal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryVotesByProposalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).VotesByProposal(types.UnwrapSDKContext(ctx), in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.group.v1alpha1.Query/VotesByProposal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).VotesByProposal(types.UnwrapSDKContext(ctx), req.(*QueryVotesByProposalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_VotesByVoter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryVotesByVoterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).VotesByVoter(types.UnwrapSDKContext(ctx), in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.group.v1alpha1.Query/VotesByVoter",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).VotesByVoter(types.UnwrapSDKContext(ctx), req.(*QueryVotesByVoterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Query_ServiceDesc is the grpc.ServiceDesc for Query service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Query_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "regen.group.v1alpha1.Query",
	HandlerType: (*QueryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GroupInfo",
			Handler:    _Query_GroupInfo_Handler,
		},
		{
			MethodName: "GroupAccountInfo",
			Handler:    _Query_GroupAccountInfo_Handler,
		},
		{
			MethodName: "GroupMembers",
			Handler:    _Query_GroupMembers_Handler,
		},
		{
			MethodName: "GroupsByAdmin",
			Handler:    _Query_GroupsByAdmin_Handler,
		},
		{
			MethodName: "GroupAccountsByGroup",
			Handler:    _Query_GroupAccountsByGroup_Handler,
		},
		{
			MethodName: "GroupAccountsByAdmin",
			Handler:    _Query_GroupAccountsByAdmin_Handler,
		},
		{
			MethodName: "Proposal",
			Handler:    _Query_Proposal_Handler,
		},
		{
			MethodName: "ProposalsByGroupAccount",
			Handler:    _Query_ProposalsByGroupAccount_Handler,
		},
		{
			MethodName: "VoteByProposalVoter",
			Handler:    _Query_VoteByProposalVoter_Handler,
		},
		{
			MethodName: "VotesByProposal",
			Handler:    _Query_VotesByProposal_Handler,
		},
		{
			MethodName: "VotesByVoter",
			Handler:    _Query_VotesByVoter_Handler,
		},
	},
	Metadata: "regen/group/v1alpha1/query.proto",
}

const (
	QueryGroupInfoMethod               = "/regen.group.v1alpha1.Query/GroupInfo"
	QueryGroupAccountInfoMethod        = "/regen.group.v1alpha1.Query/GroupAccountInfo"
	QueryGroupMembersMethod            = "/regen.group.v1alpha1.Query/GroupMembers"
	QueryGroupsByAdminMethod           = "/regen.group.v1alpha1.Query/GroupsByAdmin"
	QueryGroupAccountsByGroupMethod    = "/regen.group.v1alpha1.Query/GroupAccountsByGroup"
	QueryGroupAccountsByAdminMethod    = "/regen.group.v1alpha1.Query/GroupAccountsByAdmin"
	QueryProposalMethod                = "/regen.group.v1alpha1.Query/Proposal"
	QueryProposalsByGroupAccountMethod = "/regen.group.v1alpha1.Query/ProposalsByGroupAccount"
	QueryVoteByProposalVoterMethod     = "/regen.group.v1alpha1.Query/VoteByProposalVoter"
	QueryVotesByProposalMethod         = "/regen.group.v1alpha1.Query/VotesByProposal"
	QueryVotesByVoterMethod            = "/regen.group.v1alpha1.Query/VotesByVoter"
)
