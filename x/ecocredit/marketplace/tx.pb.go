// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: regen/ecocredit/marketplace/v1/tx.proto

package marketplace

import (
	context "context"
	fmt "fmt"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/cosmos-sdk/types/msgservice"
	_ "github.com/gogo/protobuf/gogoproto"
	grpc1 "github.com/gogo/protobuf/grpc"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MsgSell is the Msg/Sell request type.
type MsgSell struct {
	// seller is the address of the account that is selling credits.
	Seller string `protobuf:"bytes,1,opt,name=seller,proto3" json:"seller,omitempty"`
	// orders are the sell orders being created.
	Orders []*MsgSell_Order `protobuf:"bytes,2,rep,name=orders,proto3" json:"orders,omitempty"`
}

func (m *MsgSell) Reset()         { *m = MsgSell{} }
func (m *MsgSell) String() string { return proto.CompactTextString(m) }
func (*MsgSell) ProtoMessage()    {}
func (*MsgSell) Descriptor() ([]byte, []int) {
	return fileDescriptor_68c9b4e4b7fcb584, []int{0}
}
func (m *MsgSell) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSell) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSell.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSell) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSell.Merge(m, src)
}
func (m *MsgSell) XXX_Size() int {
	return m.Size()
}
func (m *MsgSell) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSell.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSell proto.InternalMessageInfo

func (m *MsgSell) GetSeller() string {
	if m != nil {
		return m.Seller
	}
	return ""
}

func (m *MsgSell) GetOrders() []*MsgSell_Order {
	if m != nil {
		return m.Orders
	}
	return nil
}

// Order is the content of a new sell order.
type MsgSell_Order struct {
	// batch_denom is the credit batch being sold.
	BatchDenom string `protobuf:"bytes,1,opt,name=batch_denom,json=batchDenom,proto3" json:"batch_denom,omitempty"`
	// quantity is the quantity of credits being sold from this batch. If it is
	// less then the balance of credits the owner has available at the time this
	// sell order is matched, the quantity will be adjusted downwards to the
	// owner's balance. However, if the balance of credits is less than this
	// quantity at the time the sell order is created, the operation will fail.
	Quantity string `protobuf:"bytes,2,opt,name=quantity,proto3" json:"quantity,omitempty"`
	// ask_price is the price the seller is asking for each unit of the
	// batch_denom. Each credit unit of the batch will be sold for at least the
	// ask_price or more.
	AskPrice *types.Coin `protobuf:"bytes,3,opt,name=ask_price,json=askPrice,proto3" json:"ask_price,omitempty"`
	// disable_auto_retire disables auto-retirement of credits which allows a
	// buyer to disable auto-retirement in their buy order enabling them to
	// resell the credits to another buyer.
	DisableAutoRetire bool `protobuf:"varint,4,opt,name=disable_auto_retire,json=disableAutoRetire,proto3" json:"disable_auto_retire,omitempty"`
	// expiration is an optional timestamp when the sell order expires. When the
	// expiration time is reached, the sell order is removed from state.
	Expiration *time.Time `protobuf:"bytes,5,opt,name=expiration,proto3,stdtime" json:"expiration,omitempty"`
}

func (m *MsgSell_Order) Reset()         { *m = MsgSell_Order{} }
func (m *MsgSell_Order) String() string { return proto.CompactTextString(m) }
func (*MsgSell_Order) ProtoMessage()    {}
func (*MsgSell_Order) Descriptor() ([]byte, []int) {
	return fileDescriptor_68c9b4e4b7fcb584, []int{0, 0}
}
func (m *MsgSell_Order) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSell_Order) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSell_Order.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSell_Order) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSell_Order.Merge(m, src)
}
func (m *MsgSell_Order) XXX_Size() int {
	return m.Size()
}
func (m *MsgSell_Order) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSell_Order.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSell_Order proto.InternalMessageInfo

func (m *MsgSell_Order) GetBatchDenom() string {
	if m != nil {
		return m.BatchDenom
	}
	return ""
}

func (m *MsgSell_Order) GetQuantity() string {
	if m != nil {
		return m.Quantity
	}
	return ""
}

func (m *MsgSell_Order) GetAskPrice() *types.Coin {
	if m != nil {
		return m.AskPrice
	}
	return nil
}

func (m *MsgSell_Order) GetDisableAutoRetire() bool {
	if m != nil {
		return m.DisableAutoRetire
	}
	return false
}

func (m *MsgSell_Order) GetExpiration() *time.Time {
	if m != nil {
		return m.Expiration
	}
	return nil
}

// MsgSellResponse is the Msg/Sell response type.
type MsgSellResponse struct {
	// sell_order_ids are the sell order IDs of the newly created sell orders.
	SellOrderIds []uint64 `protobuf:"varint,1,rep,packed,name=sell_order_ids,json=sellOrderIds,proto3" json:"sell_order_ids,omitempty"`
}

func (m *MsgSellResponse) Reset()         { *m = MsgSellResponse{} }
func (m *MsgSellResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSellResponse) ProtoMessage()    {}
func (*MsgSellResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_68c9b4e4b7fcb584, []int{1}
}
func (m *MsgSellResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSellResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSellResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSellResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSellResponse.Merge(m, src)
}
func (m *MsgSellResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSellResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSellResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSellResponse proto.InternalMessageInfo

func (m *MsgSellResponse) GetSellOrderIds() []uint64 {
	if m != nil {
		return m.SellOrderIds
	}
	return nil
}

// MsgUpdateSellOrders is the Msg/UpdateSellOrders request type.
type MsgUpdateSellOrders struct {
	// seller is the address of the account that is selling credits.
	Seller string `protobuf:"bytes,1,opt,name=seller,proto3" json:"seller,omitempty"`
	// updates are updates to existing sell orders.
	Updates []*MsgUpdateSellOrders_Update `protobuf:"bytes,2,rep,name=updates,proto3" json:"updates,omitempty"`
}

func (m *MsgUpdateSellOrders) Reset()         { *m = MsgUpdateSellOrders{} }
func (m *MsgUpdateSellOrders) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateSellOrders) ProtoMessage()    {}
func (*MsgUpdateSellOrders) Descriptor() ([]byte, []int) {
	return fileDescriptor_68c9b4e4b7fcb584, []int{2}
}
func (m *MsgUpdateSellOrders) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateSellOrders) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateSellOrders.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateSellOrders) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateSellOrders.Merge(m, src)
}
func (m *MsgUpdateSellOrders) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateSellOrders) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateSellOrders.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateSellOrders proto.InternalMessageInfo

func (m *MsgUpdateSellOrders) GetSeller() string {
	if m != nil {
		return m.Seller
	}
	return ""
}

func (m *MsgUpdateSellOrders) GetUpdates() []*MsgUpdateSellOrders_Update {
	if m != nil {
		return m.Updates
	}
	return nil
}

// Update is an update to an existing sell order.
type MsgUpdateSellOrders_Update struct {
	//  sell_order_id is the ID of an existing sell order.
	SellOrderId uint64 `protobuf:"varint,1,opt,name=sell_order_id,json=sellOrderId,proto3" json:"sell_order_id,omitempty"`
	// new_quantity is the updated quantity of credits available to sell, if it
	// is set to zero then the order is cancelled.
	NewQuantity string `protobuf:"bytes,2,opt,name=new_quantity,json=newQuantity,proto3" json:"new_quantity,omitempty"`
	// new_ask_price is the new ask price for this sell order
	NewAskPrice *types.Coin `protobuf:"bytes,3,opt,name=new_ask_price,json=newAskPrice,proto3" json:"new_ask_price,omitempty"`
	// disable_auto_retire updates the disable_auto_retire field in the sell
	// order.
	DisableAutoRetire bool `protobuf:"varint,4,opt,name=disable_auto_retire,json=disableAutoRetire,proto3" json:"disable_auto_retire,omitempty"`
	// new_expiration is an optional timestamp when the sell order expires. When
	// the expiration time is reached, the sell order is removed from state.
	NewExpiration *time.Time `protobuf:"bytes,5,opt,name=new_expiration,json=newExpiration,proto3,stdtime" json:"new_expiration,omitempty"`
}

func (m *MsgUpdateSellOrders_Update) Reset()         { *m = MsgUpdateSellOrders_Update{} }
func (m *MsgUpdateSellOrders_Update) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateSellOrders_Update) ProtoMessage()    {}
func (*MsgUpdateSellOrders_Update) Descriptor() ([]byte, []int) {
	return fileDescriptor_68c9b4e4b7fcb584, []int{2, 0}
}
func (m *MsgUpdateSellOrders_Update) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateSellOrders_Update) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateSellOrders_Update.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateSellOrders_Update) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateSellOrders_Update.Merge(m, src)
}
func (m *MsgUpdateSellOrders_Update) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateSellOrders_Update) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateSellOrders_Update.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateSellOrders_Update proto.InternalMessageInfo

func (m *MsgUpdateSellOrders_Update) GetSellOrderId() uint64 {
	if m != nil {
		return m.SellOrderId
	}
	return 0
}

func (m *MsgUpdateSellOrders_Update) GetNewQuantity() string {
	if m != nil {
		return m.NewQuantity
	}
	return ""
}

func (m *MsgUpdateSellOrders_Update) GetNewAskPrice() *types.Coin {
	if m != nil {
		return m.NewAskPrice
	}
	return nil
}

func (m *MsgUpdateSellOrders_Update) GetDisableAutoRetire() bool {
	if m != nil {
		return m.DisableAutoRetire
	}
	return false
}

func (m *MsgUpdateSellOrders_Update) GetNewExpiration() *time.Time {
	if m != nil {
		return m.NewExpiration
	}
	return nil
}

// MsgUpdateSellOrdersResponse is the Msg/UpdateSellOrders response type.
type MsgUpdateSellOrdersResponse struct {
}

func (m *MsgUpdateSellOrdersResponse) Reset()         { *m = MsgUpdateSellOrdersResponse{} }
func (m *MsgUpdateSellOrdersResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateSellOrdersResponse) ProtoMessage()    {}
func (*MsgUpdateSellOrdersResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_68c9b4e4b7fcb584, []int{3}
}
func (m *MsgUpdateSellOrdersResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateSellOrdersResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateSellOrdersResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateSellOrdersResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateSellOrdersResponse.Merge(m, src)
}
func (m *MsgUpdateSellOrdersResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateSellOrdersResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateSellOrdersResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateSellOrdersResponse proto.InternalMessageInfo

// MsgCancelSellOrder is the Msg/CancelSellOrder request type.
type MsgCancelSellOrder struct {
	// seller is the address of the account that created the sell order and is
	// therefore authorized to cancel the sell order.
	Seller string `protobuf:"bytes,1,opt,name=seller,proto3" json:"seller,omitempty"`
	// sell_order_id is the id of the seller order to cancel.
	SellOrderId uint64 `protobuf:"varint,2,opt,name=sell_order_id,json=sellOrderId,proto3" json:"sell_order_id,omitempty"`
}

func (m *MsgCancelSellOrder) Reset()         { *m = MsgCancelSellOrder{} }
func (m *MsgCancelSellOrder) String() string { return proto.CompactTextString(m) }
func (*MsgCancelSellOrder) ProtoMessage()    {}
func (*MsgCancelSellOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_68c9b4e4b7fcb584, []int{4}
}
func (m *MsgCancelSellOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCancelSellOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCancelSellOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCancelSellOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCancelSellOrder.Merge(m, src)
}
func (m *MsgCancelSellOrder) XXX_Size() int {
	return m.Size()
}
func (m *MsgCancelSellOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCancelSellOrder.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCancelSellOrder proto.InternalMessageInfo

func (m *MsgCancelSellOrder) GetSeller() string {
	if m != nil {
		return m.Seller
	}
	return ""
}

func (m *MsgCancelSellOrder) GetSellOrderId() uint64 {
	if m != nil {
		return m.SellOrderId
	}
	return 0
}

// MsgCancelSellOrder is the Msg/CancelSellOrder response type.
type MsgCancelSellOrderResponse struct {
}

func (m *MsgCancelSellOrderResponse) Reset()         { *m = MsgCancelSellOrderResponse{} }
func (m *MsgCancelSellOrderResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCancelSellOrderResponse) ProtoMessage()    {}
func (*MsgCancelSellOrderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_68c9b4e4b7fcb584, []int{5}
}
func (m *MsgCancelSellOrderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCancelSellOrderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCancelSellOrderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCancelSellOrderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCancelSellOrderResponse.Merge(m, src)
}
func (m *MsgCancelSellOrderResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCancelSellOrderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCancelSellOrderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCancelSellOrderResponse proto.InternalMessageInfo

// MsgBuyDirect is the Msg/BuyDirect request type.
type MsgBuyDirect struct {
	// buyer is the address of the account that is buying credits.
	Buyer string `protobuf:"bytes,1,opt,name=buyer,proto3" json:"buyer,omitempty"`
	// orders is a list of orders for ecocredits.
	Orders []*MsgBuyDirect_Order `protobuf:"bytes,2,rep,name=orders,proto3" json:"orders,omitempty"`
}

func (m *MsgBuyDirect) Reset()         { *m = MsgBuyDirect{} }
func (m *MsgBuyDirect) String() string { return proto.CompactTextString(m) }
func (*MsgBuyDirect) ProtoMessage()    {}
func (*MsgBuyDirect) Descriptor() ([]byte, []int) {
	return fileDescriptor_68c9b4e4b7fcb584, []int{6}
}
func (m *MsgBuyDirect) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBuyDirect) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBuyDirect.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBuyDirect) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBuyDirect.Merge(m, src)
}
func (m *MsgBuyDirect) XXX_Size() int {
	return m.Size()
}
func (m *MsgBuyDirect) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBuyDirect.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBuyDirect proto.InternalMessageInfo

func (m *MsgBuyDirect) GetBuyer() string {
	if m != nil {
		return m.Buyer
	}
	return ""
}

func (m *MsgBuyDirect) GetOrders() []*MsgBuyDirect_Order {
	if m != nil {
		return m.Orders
	}
	return nil
}

// Order contains the information needed to purchase an ecocredit.
type MsgBuyDirect_Order struct {
	// sell_order_id is the sell order ID against which the buyer is trying
	// to buy.
	SellOrderId uint64 `protobuf:"varint,2,opt,name=sell_order_id,json=sellOrderId,proto3" json:"sell_order_id,omitempty"`
	// quantity is the quantity of credits to buy.
	Quantity string `protobuf:"bytes,3,opt,name=quantity,proto3" json:"quantity,omitempty"`
	// bid_price is the price the buyer is willing to pay per credit.
	BidPrice *types.Coin `protobuf:"bytes,4,opt,name=bid_price,json=bidPrice,proto3" json:"bid_price,omitempty"`
	// disable_auto_retire allows auto-retirement to be disabled. If it is set
	// to true the credits will not auto-retire and can be resold assuming that
	// the corresponding sell order has auto-retirement disabled. If the sell
	// order hasn't disabled auto-retirement and the buy order tries to disable
	// it, that buy order will fail.
	DisableAutoRetire bool `protobuf:"varint,5,opt,name=disable_auto_retire,json=disableAutoRetire,proto3" json:"disable_auto_retire,omitempty"`
	// retirement_jurisdiction is the optional retirement jurisdiction for the
	// credits which will be used only if disable_auto_retire is false.
	RetirementJurisdiction string `protobuf:"bytes,6,opt,name=retirement_jurisdiction,json=retirementJurisdiction,proto3" json:"retirement_jurisdiction,omitempty"`
}

func (m *MsgBuyDirect_Order) Reset()         { *m = MsgBuyDirect_Order{} }
func (m *MsgBuyDirect_Order) String() string { return proto.CompactTextString(m) }
func (*MsgBuyDirect_Order) ProtoMessage()    {}
func (*MsgBuyDirect_Order) Descriptor() ([]byte, []int) {
	return fileDescriptor_68c9b4e4b7fcb584, []int{6, 0}
}
func (m *MsgBuyDirect_Order) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBuyDirect_Order) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBuyDirect_Order.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBuyDirect_Order) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBuyDirect_Order.Merge(m, src)
}
func (m *MsgBuyDirect_Order) XXX_Size() int {
	return m.Size()
}
func (m *MsgBuyDirect_Order) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBuyDirect_Order.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBuyDirect_Order proto.InternalMessageInfo

func (m *MsgBuyDirect_Order) GetSellOrderId() uint64 {
	if m != nil {
		return m.SellOrderId
	}
	return 0
}

func (m *MsgBuyDirect_Order) GetQuantity() string {
	if m != nil {
		return m.Quantity
	}
	return ""
}

func (m *MsgBuyDirect_Order) GetBidPrice() *types.Coin {
	if m != nil {
		return m.BidPrice
	}
	return nil
}

func (m *MsgBuyDirect_Order) GetDisableAutoRetire() bool {
	if m != nil {
		return m.DisableAutoRetire
	}
	return false
}

func (m *MsgBuyDirect_Order) GetRetirementJurisdiction() string {
	if m != nil {
		return m.RetirementJurisdiction
	}
	return ""
}

// MsgBuyDirectResponse is the Msg/BuyDirect response type.
type MsgBuyDirectResponse struct {
}

func (m *MsgBuyDirectResponse) Reset()         { *m = MsgBuyDirectResponse{} }
func (m *MsgBuyDirectResponse) String() string { return proto.CompactTextString(m) }
func (*MsgBuyDirectResponse) ProtoMessage()    {}
func (*MsgBuyDirectResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_68c9b4e4b7fcb584, []int{7}
}
func (m *MsgBuyDirectResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBuyDirectResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBuyDirectResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBuyDirectResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBuyDirectResponse.Merge(m, src)
}
func (m *MsgBuyDirectResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgBuyDirectResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBuyDirectResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBuyDirectResponse proto.InternalMessageInfo

// MsgAddAllowedDenom is the Msg/AddAllowedDenom request type.
// Since Revision 1
type MsgAddAllowedDenom struct {
	// authority is the address of the governance account.
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// denom is the bank denom to allow (ex. ibc/GLKHDSG423SGS)
	BankDenom string `protobuf:"bytes,2,opt,name=bank_denom,json=bankDenom,proto3" json:"bank_denom,omitempty"`
	// display_denom is the denom to display to the user and is informational.
	// Because the denom is likely an IBC denom, this should be chosen by
	// governance to represent the consensus trusted name of the denom.
	DisplayDenom string `protobuf:"bytes,3,opt,name=display_denom,json=displayDenom,proto3" json:"display_denom,omitempty"`
	// exponent is the exponent that relates the denom to the display_denom and is
	// informational
	Exponent uint32 `protobuf:"varint,4,opt,name=exponent,proto3" json:"exponent,omitempty"`
}

func (m *MsgAddAllowedDenom) Reset()         { *m = MsgAddAllowedDenom{} }
func (m *MsgAddAllowedDenom) String() string { return proto.CompactTextString(m) }
func (*MsgAddAllowedDenom) ProtoMessage()    {}
func (*MsgAddAllowedDenom) Descriptor() ([]byte, []int) {
	return fileDescriptor_68c9b4e4b7fcb584, []int{8}
}
func (m *MsgAddAllowedDenom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAddAllowedDenom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAddAllowedDenom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAddAllowedDenom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAddAllowedDenom.Merge(m, src)
}
func (m *MsgAddAllowedDenom) XXX_Size() int {
	return m.Size()
}
func (m *MsgAddAllowedDenom) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAddAllowedDenom.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAddAllowedDenom proto.InternalMessageInfo

func (m *MsgAddAllowedDenom) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgAddAllowedDenom) GetBankDenom() string {
	if m != nil {
		return m.BankDenom
	}
	return ""
}

func (m *MsgAddAllowedDenom) GetDisplayDenom() string {
	if m != nil {
		return m.DisplayDenom
	}
	return ""
}

func (m *MsgAddAllowedDenom) GetExponent() uint32 {
	if m != nil {
		return m.Exponent
	}
	return 0
}

// MsgAddAllowedDenomResponse is the Msg/AddAllowedDenom response type.
// Since Revision 1
type MsgAddAllowedDenomResponse struct {
}

func (m *MsgAddAllowedDenomResponse) Reset()         { *m = MsgAddAllowedDenomResponse{} }
func (m *MsgAddAllowedDenomResponse) String() string { return proto.CompactTextString(m) }
func (*MsgAddAllowedDenomResponse) ProtoMessage()    {}
func (*MsgAddAllowedDenomResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_68c9b4e4b7fcb584, []int{9}
}
func (m *MsgAddAllowedDenomResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAddAllowedDenomResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAddAllowedDenomResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAddAllowedDenomResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAddAllowedDenomResponse.Merge(m, src)
}
func (m *MsgAddAllowedDenomResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgAddAllowedDenomResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAddAllowedDenomResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAddAllowedDenomResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*MsgSell)(nil), "regen.ecocredit.marketplace.v1.MsgSell")
	proto.RegisterType((*MsgSell_Order)(nil), "regen.ecocredit.marketplace.v1.MsgSell.Order")
	proto.RegisterType((*MsgSellResponse)(nil), "regen.ecocredit.marketplace.v1.MsgSellResponse")
	proto.RegisterType((*MsgUpdateSellOrders)(nil), "regen.ecocredit.marketplace.v1.MsgUpdateSellOrders")
	proto.RegisterType((*MsgUpdateSellOrders_Update)(nil), "regen.ecocredit.marketplace.v1.MsgUpdateSellOrders.Update")
	proto.RegisterType((*MsgUpdateSellOrdersResponse)(nil), "regen.ecocredit.marketplace.v1.MsgUpdateSellOrdersResponse")
	proto.RegisterType((*MsgCancelSellOrder)(nil), "regen.ecocredit.marketplace.v1.MsgCancelSellOrder")
	proto.RegisterType((*MsgCancelSellOrderResponse)(nil), "regen.ecocredit.marketplace.v1.MsgCancelSellOrderResponse")
	proto.RegisterType((*MsgBuyDirect)(nil), "regen.ecocredit.marketplace.v1.MsgBuyDirect")
	proto.RegisterType((*MsgBuyDirect_Order)(nil), "regen.ecocredit.marketplace.v1.MsgBuyDirect.Order")
	proto.RegisterType((*MsgBuyDirectResponse)(nil), "regen.ecocredit.marketplace.v1.MsgBuyDirectResponse")
	proto.RegisterType((*MsgAddAllowedDenom)(nil), "regen.ecocredit.marketplace.v1.MsgAddAllowedDenom")
	proto.RegisterType((*MsgAddAllowedDenomResponse)(nil), "regen.ecocredit.marketplace.v1.MsgAddAllowedDenomResponse")
}

func init() {
	proto.RegisterFile("regen/ecocredit/marketplace/v1/tx.proto", fileDescriptor_68c9b4e4b7fcb584)
}

var fileDescriptor_68c9b4e4b7fcb584 = []byte{
	// 894 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0x5f, 0x6f, 0xdb, 0x54,
	0x14, 0xaf, 0x93, 0x34, 0x6b, 0x4e, 0xda, 0x0e, 0xbc, 0xaa, 0x0b, 0x66, 0x4b, 0x43, 0x40, 0x5a,
	0x84, 0xd8, 0xb5, 0xda, 0x21, 0x26, 0x05, 0x4d, 0xa2, 0xdd, 0x26, 0xc4, 0xa4, 0x08, 0xf0, 0x86,
	0x90, 0x90, 0x50, 0xb8, 0xb6, 0x2f, 0xee, 0x25, 0xb6, 0xaf, 0xf1, 0xbd, 0x5e, 0xdb, 0x47, 0x10,
	0x12, 0xaf, 0x7b, 0xe6, 0x91, 0x4f, 0xc0, 0xc7, 0xe0, 0x71, 0x8f, 0xbc, 0x81, 0x5a, 0x89, 0xf2,
	0xc4, 0x67, 0x40, 0xf7, 0xfa, 0xc6, 0x4d, 0x9d, 0xa5, 0xb8, 0x7d, 0xf3, 0x3d, 0xff, 0xcf, 0xef,
	0x77, 0xce, 0x49, 0xe0, 0x4e, 0x4a, 0x02, 0x12, 0xdb, 0xc4, 0x63, 0x5e, 0x4a, 0x7c, 0x2a, 0xec,
	0x08, 0xa7, 0x13, 0x22, 0x92, 0x10, 0x7b, 0xc4, 0x7e, 0xbe, 0x6d, 0x8b, 0x43, 0x94, 0xa4, 0x4c,
	0x30, 0xb3, 0xab, 0x0c, 0x51, 0x61, 0x88, 0x66, 0x0c, 0xd1, 0xf3, 0x6d, 0xab, 0xeb, 0x31, 0x1e,
	0x31, 0x6e, 0xbb, 0x98, 0x4b, 0x47, 0x97, 0x08, 0xbc, 0x6d, 0x7b, 0x8c, 0xc6, 0xb9, 0xbf, 0x75,
	0x53, 0xeb, 0x23, 0x1e, 0xc8, 0xb8, 0x11, 0x0f, 0xb4, 0x62, 0x23, 0x60, 0x01, 0x53, 0x9f, 0xb6,
	0xfc, 0xd2, 0xd2, 0xad, 0x80, 0xb1, 0x20, 0x24, 0xb6, 0x7a, 0xb9, 0xd9, 0xb7, 0xb6, 0xa0, 0x11,
	0xe1, 0x02, 0x47, 0x49, 0x6e, 0xd0, 0xff, 0xbb, 0x06, 0xd7, 0x46, 0x3c, 0x78, 0x4a, 0xc2, 0xd0,
	0xdc, 0x84, 0x26, 0x27, 0x61, 0x48, 0xd2, 0x8e, 0xd1, 0x33, 0x06, 0x2d, 0x47, 0xbf, 0xcc, 0xc7,
	0xd0, 0x64, 0xa9, 0x4f, 0x52, 0xde, 0xa9, 0xf5, 0xea, 0x83, 0xf6, 0xce, 0x5d, 0x74, 0x71, 0x13,
	0x48, 0x07, 0x44, 0x9f, 0x4a, 0x2f, 0x47, 0x3b, 0x5b, 0xff, 0x1a, 0xb0, 0xac, 0x24, 0xe6, 0x16,
	0xb4, 0x5d, 0x2c, 0xbc, 0xfd, 0xb1, 0x4f, 0x62, 0x16, 0xe9, 0x6c, 0xa0, 0x44, 0x8f, 0xa4, 0xc4,
	0xb4, 0x60, 0xe5, 0xfb, 0x0c, 0xc7, 0x82, 0x8a, 0xa3, 0x4e, 0x4d, 0x69, 0x8b, 0xb7, 0xf9, 0x01,
	0xb4, 0x30, 0x9f, 0x8c, 0x93, 0x94, 0x7a, 0xa4, 0x53, 0xef, 0x19, 0x83, 0xf6, 0xce, 0x1b, 0x28,
	0x47, 0x05, 0x49, 0xd4, 0x90, 0x46, 0x0d, 0x3d, 0x64, 0x34, 0x76, 0x56, 0x30, 0x9f, 0x7c, 0x26,
	0x4d, 0x4d, 0x04, 0x37, 0x7c, 0xca, 0xb1, 0x1b, 0x92, 0x31, 0xce, 0x04, 0x1b, 0xa7, 0x44, 0xd0,
	0x94, 0x74, 0x1a, 0x3d, 0x63, 0xb0, 0xe2, 0xbc, 0xae, 0x55, 0xbb, 0x99, 0x60, 0x8e, 0x52, 0x98,
	0x1f, 0x01, 0x90, 0xc3, 0x84, 0xa6, 0x58, 0x50, 0x16, 0x77, 0x96, 0x55, 0x22, 0x0b, 0xe5, 0x78,
	0xa2, 0x29, 0x9e, 0xe8, 0xd9, 0x14, 0xcf, 0xbd, 0xc6, 0x8b, 0x3f, 0xb7, 0x0c, 0x67, 0xc6, 0x67,
	0xd8, 0xfe, 0xf1, 0xf4, 0xb7, 0x77, 0x35, 0x88, 0xfd, 0xfb, 0x70, 0x5d, 0xc3, 0xe2, 0x10, 0x9e,
	0xb0, 0x98, 0x13, 0xf3, 0x1d, 0x58, 0x97, 0xca, 0xb1, 0xc2, 0x67, 0x4c, 0x7d, 0xde, 0x31, 0x7a,
	0xf5, 0x41, 0xc3, 0x59, 0x95, 0x52, 0x85, 0xd4, 0x27, 0x3e, 0xef, 0xff, 0x52, 0x87, 0x1b, 0x23,
	0x1e, 0x7c, 0x91, 0xf8, 0x58, 0x90, 0xa7, 0x53, 0x0d, 0x5f, 0xc8, 0xd6, 0x33, 0xb8, 0x96, 0x29,
	0xdb, 0x29, 0x5d, 0xc3, 0x0a, 0x74, 0x95, 0xa3, 0xa3, 0x5c, 0xe0, 0x4c, 0x43, 0x59, 0x3f, 0xd7,
	0xa0, 0x99, 0xcb, 0xcc, 0x3e, 0xac, 0x9d, 0x2b, 0x5b, 0xe5, 0x6f, 0x38, 0xed, 0x99, 0xaa, 0xcd,
	0xb7, 0x60, 0x35, 0x26, 0x07, 0xe3, 0x12, 0x89, 0xed, 0x98, 0x1c, 0x7c, 0x3e, 0xe5, 0xf1, 0x01,
	0xac, 0x49, 0x93, 0x4b, 0x70, 0x29, 0xdd, 0x77, 0xaf, 0x4a, 0xe7, 0xc7, 0xb0, 0x2e, 0xd3, 0x5d,
	0x81, 0x52, 0x59, 0xe6, 0xe3, 0x05, 0xac, 0xde, 0x86, 0x37, 0x5f, 0x81, 0xde, 0x94, 0xe1, 0xfe,
	0xd7, 0x60, 0x8e, 0x78, 0xf0, 0x10, 0xc7, 0x1e, 0x09, 0x0b, 0xf5, 0x42, 0xe6, 0xe6, 0x80, 0xad,
	0xcd, 0x01, 0x7b, 0x3e, 0xfb, 0x2d, 0xb0, 0xe6, 0xc3, 0x17, 0xc9, 0x4f, 0x6b, 0xb0, 0x3a, 0xe2,
	0xc1, 0x5e, 0x76, 0xf4, 0x88, 0xa6, 0xc4, 0x13, 0xe6, 0x06, 0x2c, 0xbb, 0xd9, 0x51, 0x91, 0x36,
	0x7f, 0x98, 0x4f, 0x4a, 0xdb, 0xbd, 0x53, 0x61, 0x5c, 0x8a, 0x98, 0xa5, 0x15, 0xff, 0xa7, 0x58,
	0xf1, 0x0a, 0xbd, 0x9c, 0xdb, 0xf2, 0xfa, 0xfc, 0x96, 0xbb, 0xd4, 0xd7, 0x93, 0xd1, 0xf8, 0xdf,
	0x2d, 0x77, 0xa9, 0x7f, 0xe1, 0x58, 0x2c, 0x2f, 0x1a, 0x8b, 0xfb, 0x70, 0x33, 0x37, 0x89, 0x48,
	0x2c, 0xc6, 0xdf, 0x65, 0x29, 0xe5, 0x3e, 0xf5, 0xd4, 0x7c, 0x34, 0x55, 0x49, 0x9b, 0x67, 0xea,
	0x27, 0x33, 0xda, 0x21, 0x48, 0x22, 0x72, 0x08, 0xfb, 0x9b, 0xb0, 0x31, 0x0b, 0x4a, 0xc1, 0xc0,
	0xaf, 0x86, 0xe2, 0x7f, 0xd7, 0xf7, 0x77, 0xc3, 0x90, 0x1d, 0x10, 0x3f, 0xbf, 0x6e, 0xb7, 0xa0,
	0x85, 0x33, 0xb1, 0xcf, 0x52, 0xd9, 0x78, 0xce, 0xc5, 0x99, 0xc0, 0xbc, 0x0d, 0xe0, 0xe2, 0x78,
	0xa2, 0x6f, 0x63, 0xbe, 0x38, 0x2d, 0x29, 0xc9, 0x9d, 0xdf, 0x86, 0x35, 0x9f, 0xf2, 0x24, 0xc4,
	0x47, 0xda, 0x22, 0x47, 0x6e, 0x55, 0x0b, 0x8b, 0xfb, 0x49, 0x0e, 0x13, 0x16, 0x93, 0x58, 0x28,
	0xf0, 0xd6, 0x9c, 0xe2, 0x3d, 0x5c, 0x97, 0x85, 0x9f, 0xe5, 0xd3, 0x43, 0x54, 0xaa, 0x71, 0xda,
	0xc2, 0xce, 0x69, 0x03, 0xea, 0x23, 0x1e, 0x98, 0xdf, 0x40, 0x43, 0xfd, 0x46, 0xdc, 0xa9, 0x78,
	0xfb, 0x2d, 0xbb, 0xa2, 0x61, 0x71, 0x0d, 0x7f, 0x32, 0xe0, 0xb5, 0xb9, 0x23, 0x77, 0xef, 0x0a,
	0xb7, 0xcb, 0xfa, 0xf0, 0x0a, 0x4e, 0x45, 0x19, 0x3f, 0x18, 0x70, 0xbd, 0xbc, 0xb0, 0x55, 0x56,
	0xa2, 0xe4, 0x63, 0x0d, 0x2f, 0xef, 0x53, 0xd4, 0xc0, 0xa0, 0x75, 0xb6, 0xb5, 0xef, 0x5d, 0x66,
	0x1f, 0xad, 0xf7, 0x2f, 0x63, 0x7d, 0xae, 0xe9, 0xf2, 0x94, 0x56, 0x69, 0xba, 0xe4, 0x53, 0xa9,
	0xe9, 0x05, 0x93, 0xb6, 0xf7, 0xe5, 0xef, 0xc7, 0x5d, 0xe3, 0xe5, 0x71, 0xd7, 0xf8, 0xeb, 0xb8,
	0x6b, 0xbc, 0x38, 0xe9, 0x2e, 0xbd, 0x3c, 0xe9, 0x2e, 0xfd, 0x71, 0xd2, 0x5d, 0xfa, 0xea, 0x41,
	0x40, 0xc5, 0x7e, 0xe6, 0x22, 0x8f, 0x45, 0xb6, 0x8a, 0x7f, 0x37, 0x26, 0xe2, 0x80, 0xa5, 0x13,
	0xfd, 0x0a, 0x89, 0x1f, 0x90, 0xd4, 0x3e, 0x7c, 0xf5, 0xdf, 0x2f, 0xb7, 0xa9, 0x2e, 0xfb, 0xbd,
	0xff, 0x02, 0x00, 0x00, 0xff, 0xff, 0xf8, 0x46, 0x77, 0x47, 0xa4, 0x09, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	// Sell creates new sell orders.
	Sell(ctx context.Context, in *MsgSell, opts ...grpc.CallOption) (*MsgSellResponse, error)
	// UpdateSellOrders updates existing sell orders.
	UpdateSellOrders(ctx context.Context, in *MsgUpdateSellOrders, opts ...grpc.CallOption) (*MsgUpdateSellOrdersResponse, error)
	// CancelSellOrder cancels a sell order and returns the funds from escrow.
	CancelSellOrder(ctx context.Context, in *MsgCancelSellOrder, opts ...grpc.CallOption) (*MsgCancelSellOrderResponse, error)
	// BuyDirect purchases credits directly from the specified sell order.
	BuyDirect(ctx context.Context, in *MsgBuyDirect, opts ...grpc.CallOption) (*MsgBuyDirectResponse, error)
	// AddAllowedDenom is a governance method that allows the addition of
	// new allowed denom.
	// Since Revision 1
	AddAllowedDenom(ctx context.Context, in *MsgAddAllowedDenom, opts ...grpc.CallOption) (*MsgAddAllowedDenomResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) Sell(ctx context.Context, in *MsgSell, opts ...grpc.CallOption) (*MsgSellResponse, error) {
	out := new(MsgSellResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.marketplace.v1.Msg/Sell", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateSellOrders(ctx context.Context, in *MsgUpdateSellOrders, opts ...grpc.CallOption) (*MsgUpdateSellOrdersResponse, error) {
	out := new(MsgUpdateSellOrdersResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.marketplace.v1.Msg/UpdateSellOrders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CancelSellOrder(ctx context.Context, in *MsgCancelSellOrder, opts ...grpc.CallOption) (*MsgCancelSellOrderResponse, error) {
	out := new(MsgCancelSellOrderResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.marketplace.v1.Msg/CancelSellOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) BuyDirect(ctx context.Context, in *MsgBuyDirect, opts ...grpc.CallOption) (*MsgBuyDirectResponse, error) {
	out := new(MsgBuyDirectResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.marketplace.v1.Msg/BuyDirect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) AddAllowedDenom(ctx context.Context, in *MsgAddAllowedDenom, opts ...grpc.CallOption) (*MsgAddAllowedDenomResponse, error) {
	out := new(MsgAddAllowedDenomResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.marketplace.v1.Msg/AddAllowedDenom", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	// Sell creates new sell orders.
	Sell(context.Context, *MsgSell) (*MsgSellResponse, error)
	// UpdateSellOrders updates existing sell orders.
	UpdateSellOrders(context.Context, *MsgUpdateSellOrders) (*MsgUpdateSellOrdersResponse, error)
	// CancelSellOrder cancels a sell order and returns the funds from escrow.
	CancelSellOrder(context.Context, *MsgCancelSellOrder) (*MsgCancelSellOrderResponse, error)
	// BuyDirect purchases credits directly from the specified sell order.
	BuyDirect(context.Context, *MsgBuyDirect) (*MsgBuyDirectResponse, error)
	// AddAllowedDenom is a governance method that allows the addition of
	// new allowed denom.
	// Since Revision 1
	AddAllowedDenom(context.Context, *MsgAddAllowedDenom) (*MsgAddAllowedDenomResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) Sell(ctx context.Context, req *MsgSell) (*MsgSellResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Sell not implemented")
}
func (*UnimplementedMsgServer) UpdateSellOrders(ctx context.Context, req *MsgUpdateSellOrders) (*MsgUpdateSellOrdersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSellOrders not implemented")
}
func (*UnimplementedMsgServer) CancelSellOrder(ctx context.Context, req *MsgCancelSellOrder) (*MsgCancelSellOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelSellOrder not implemented")
}
func (*UnimplementedMsgServer) BuyDirect(ctx context.Context, req *MsgBuyDirect) (*MsgBuyDirectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BuyDirect not implemented")
}
func (*UnimplementedMsgServer) AddAllowedDenom(ctx context.Context, req *MsgAddAllowedDenom) (*MsgAddAllowedDenomResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddAllowedDenom not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_Sell_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSell)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Sell(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.marketplace.v1.Msg/Sell",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Sell(ctx, req.(*MsgSell))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateSellOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateSellOrders)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateSellOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.marketplace.v1.Msg/UpdateSellOrders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateSellOrders(ctx, req.(*MsgUpdateSellOrders))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CancelSellOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCancelSellOrder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CancelSellOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.marketplace.v1.Msg/CancelSellOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CancelSellOrder(ctx, req.(*MsgCancelSellOrder))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_BuyDirect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBuyDirect)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).BuyDirect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.marketplace.v1.Msg/BuyDirect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).BuyDirect(ctx, req.(*MsgBuyDirect))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_AddAllowedDenom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgAddAllowedDenom)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).AddAllowedDenom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.marketplace.v1.Msg/AddAllowedDenom",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).AddAllowedDenom(ctx, req.(*MsgAddAllowedDenom))
	}
	return interceptor(ctx, in, info, handler)
}

var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "regen.ecocredit.marketplace.v1.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Sell",
			Handler:    _Msg_Sell_Handler,
		},
		{
			MethodName: "UpdateSellOrders",
			Handler:    _Msg_UpdateSellOrders_Handler,
		},
		{
			MethodName: "CancelSellOrder",
			Handler:    _Msg_CancelSellOrder_Handler,
		},
		{
			MethodName: "BuyDirect",
			Handler:    _Msg_BuyDirect_Handler,
		},
		{
			MethodName: "AddAllowedDenom",
			Handler:    _Msg_AddAllowedDenom_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "regen/ecocredit/marketplace/v1/tx.proto",
}

func (m *MsgSell) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSell) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSell) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Orders) > 0 {
		for iNdEx := len(m.Orders) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Orders[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Seller) > 0 {
		i -= len(m.Seller)
		copy(dAtA[i:], m.Seller)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Seller)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSell_Order) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSell_Order) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSell_Order) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Expiration != nil {
		n1, err1 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.Expiration, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.Expiration):])
		if err1 != nil {
			return 0, err1
		}
		i -= n1
		i = encodeVarintTx(dAtA, i, uint64(n1))
		i--
		dAtA[i] = 0x2a
	}
	if m.DisableAutoRetire {
		i--
		if m.DisableAutoRetire {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.AskPrice != nil {
		{
			size, err := m.AskPrice.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Quantity) > 0 {
		i -= len(m.Quantity)
		copy(dAtA[i:], m.Quantity)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Quantity)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.BatchDenom) > 0 {
		i -= len(m.BatchDenom)
		copy(dAtA[i:], m.BatchDenom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.BatchDenom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSellResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSellResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSellResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SellOrderIds) > 0 {
		dAtA4 := make([]byte, len(m.SellOrderIds)*10)
		var j3 int
		for _, num := range m.SellOrderIds {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintTx(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateSellOrders) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateSellOrders) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateSellOrders) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Updates) > 0 {
		for iNdEx := len(m.Updates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Updates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Seller) > 0 {
		i -= len(m.Seller)
		copy(dAtA[i:], m.Seller)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Seller)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateSellOrders_Update) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateSellOrders_Update) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateSellOrders_Update) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NewExpiration != nil {
		n5, err5 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.NewExpiration, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.NewExpiration):])
		if err5 != nil {
			return 0, err5
		}
		i -= n5
		i = encodeVarintTx(dAtA, i, uint64(n5))
		i--
		dAtA[i] = 0x2a
	}
	if m.DisableAutoRetire {
		i--
		if m.DisableAutoRetire {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.NewAskPrice != nil {
		{
			size, err := m.NewAskPrice.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.NewQuantity) > 0 {
		i -= len(m.NewQuantity)
		copy(dAtA[i:], m.NewQuantity)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NewQuantity)))
		i--
		dAtA[i] = 0x12
	}
	if m.SellOrderId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.SellOrderId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateSellOrdersResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateSellOrdersResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateSellOrdersResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgCancelSellOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCancelSellOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCancelSellOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SellOrderId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.SellOrderId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Seller) > 0 {
		i -= len(m.Seller)
		copy(dAtA[i:], m.Seller)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Seller)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCancelSellOrderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCancelSellOrderResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCancelSellOrderResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgBuyDirect) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBuyDirect) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBuyDirect) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Orders) > 0 {
		for iNdEx := len(m.Orders) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Orders[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Buyer) > 0 {
		i -= len(m.Buyer)
		copy(dAtA[i:], m.Buyer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Buyer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgBuyDirect_Order) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBuyDirect_Order) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBuyDirect_Order) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RetirementJurisdiction) > 0 {
		i -= len(m.RetirementJurisdiction)
		copy(dAtA[i:], m.RetirementJurisdiction)
		i = encodeVarintTx(dAtA, i, uint64(len(m.RetirementJurisdiction)))
		i--
		dAtA[i] = 0x32
	}
	if m.DisableAutoRetire {
		i--
		if m.DisableAutoRetire {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.BidPrice != nil {
		{
			size, err := m.BidPrice.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Quantity) > 0 {
		i -= len(m.Quantity)
		copy(dAtA[i:], m.Quantity)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Quantity)))
		i--
		dAtA[i] = 0x1a
	}
	if m.SellOrderId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.SellOrderId))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *MsgBuyDirectResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBuyDirectResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBuyDirectResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgAddAllowedDenom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAddAllowedDenom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAddAllowedDenom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Exponent != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Exponent))
		i--
		dAtA[i] = 0x20
	}
	if len(m.DisplayDenom) > 0 {
		i -= len(m.DisplayDenom)
		copy(dAtA[i:], m.DisplayDenom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.DisplayDenom)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.BankDenom) > 0 {
		i -= len(m.BankDenom)
		copy(dAtA[i:], m.BankDenom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.BankDenom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgAddAllowedDenomResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAddAllowedDenomResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAddAllowedDenomResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgSell) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Seller)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Orders) > 0 {
		for _, e := range m.Orders {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgSell_Order) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BatchDenom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Quantity)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.AskPrice != nil {
		l = m.AskPrice.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.DisableAutoRetire {
		n += 2
	}
	if m.Expiration != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.Expiration)
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgSellResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SellOrderIds) > 0 {
		l = 0
		for _, e := range m.SellOrderIds {
			l += sovTx(uint64(e))
		}
		n += 1 + sovTx(uint64(l)) + l
	}
	return n
}

func (m *MsgUpdateSellOrders) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Seller)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Updates) > 0 {
		for _, e := range m.Updates {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgUpdateSellOrders_Update) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SellOrderId != 0 {
		n += 1 + sovTx(uint64(m.SellOrderId))
	}
	l = len(m.NewQuantity)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.NewAskPrice != nil {
		l = m.NewAskPrice.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.DisableAutoRetire {
		n += 2
	}
	if m.NewExpiration != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.NewExpiration)
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateSellOrdersResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgCancelSellOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Seller)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.SellOrderId != 0 {
		n += 1 + sovTx(uint64(m.SellOrderId))
	}
	return n
}

func (m *MsgCancelSellOrderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgBuyDirect) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Buyer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Orders) > 0 {
		for _, e := range m.Orders {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgBuyDirect_Order) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SellOrderId != 0 {
		n += 1 + sovTx(uint64(m.SellOrderId))
	}
	l = len(m.Quantity)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.BidPrice != nil {
		l = m.BidPrice.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.DisableAutoRetire {
		n += 2
	}
	l = len(m.RetirementJurisdiction)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgBuyDirectResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgAddAllowedDenom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.BankDenom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.DisplayDenom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Exponent != 0 {
		n += 1 + sovTx(uint64(m.Exponent))
	}
	return n
}

func (m *MsgAddAllowedDenomResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgSell) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSell: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSell: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seller", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Seller = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Orders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Orders = append(m.Orders, &MsgSell_Order{})
			if err := m.Orders[len(m.Orders)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSell_Order) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Order: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Order: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Quantity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AskPrice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AskPrice == nil {
				m.AskPrice = &types.Coin{}
			}
			if err := m.AskPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableAutoRetire", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableAutoRetire = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expiration == nil {
				m.Expiration = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.Expiration, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSellResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSellResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSellResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SellOrderIds = append(m.SellOrderIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTx
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTx
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SellOrderIds) == 0 {
					m.SellOrderIds = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SellOrderIds = append(m.SellOrderIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SellOrderIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateSellOrders) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateSellOrders: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateSellOrders: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seller", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Seller = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Updates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Updates = append(m.Updates, &MsgUpdateSellOrders_Update{})
			if err := m.Updates[len(m.Updates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateSellOrders_Update) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Update: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Update: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SellOrderId", wireType)
			}
			m.SellOrderId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SellOrderId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewQuantity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewQuantity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewAskPrice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NewAskPrice == nil {
				m.NewAskPrice = &types.Coin{}
			}
			if err := m.NewAskPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableAutoRetire", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableAutoRetire = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewExpiration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NewExpiration == nil {
				m.NewExpiration = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.NewExpiration, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateSellOrdersResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateSellOrdersResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateSellOrdersResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCancelSellOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCancelSellOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCancelSellOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seller", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Seller = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SellOrderId", wireType)
			}
			m.SellOrderId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SellOrderId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCancelSellOrderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCancelSellOrderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCancelSellOrderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBuyDirect) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBuyDirect: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBuyDirect: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buyer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Buyer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Orders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Orders = append(m.Orders, &MsgBuyDirect_Order{})
			if err := m.Orders[len(m.Orders)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBuyDirect_Order) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Order: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Order: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SellOrderId", wireType)
			}
			m.SellOrderId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SellOrderId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Quantity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BidPrice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BidPrice == nil {
				m.BidPrice = &types.Coin{}
			}
			if err := m.BidPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableAutoRetire", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableAutoRetire = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetirementJurisdiction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetirementJurisdiction = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBuyDirectResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBuyDirectResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBuyDirectResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAddAllowedDenom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAddAllowedDenom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAddAllowedDenom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BankDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BankDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exponent", wireType)
			}
			m.Exponent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exponent |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAddAllowedDenomResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAddAllowedDenomResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAddAllowedDenomResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
