// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: regen/ecocredit/marketplace/v1/events.proto

package v1

import (
	fmt "fmt"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// EventSell is an event emitted when a sell order is created.
type EventSell struct {
	// order_id is the unique ID of sell order.
	OrderId uint64 `protobuf:"varint,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	// batch_denom is the credit batch being sold.
	BatchDenom string `protobuf:"bytes,2,opt,name=batch_denom,json=batchDenom,proto3" json:"batch_denom,omitempty"`
	// quantity is the quantity of credits being sold.
	Quantity string `protobuf:"bytes,3,opt,name=quantity,proto3" json:"quantity,omitempty"`
	// ask_price is the price the seller is asking for each unit of the
	// batch_denom. Each credit unit of the batch will be sold for at least the
	// ask_price or more.
	AskPrice *types.Coin `protobuf:"bytes,4,opt,name=ask_price,json=askPrice,proto3" json:"ask_price,omitempty"`
	// disable_auto_retire disables auto-retirement of credits which allows a
	// buyer to disable auto-retirement in their buy order enabling them to
	// resell the credits to another buyer.
	DisableAutoRetire bool `protobuf:"varint,5,opt,name=disable_auto_retire,json=disableAutoRetire,proto3" json:"disable_auto_retire,omitempty"`
	// expiration is an optional timestamp when the sell order expires. When the
	// expiration time is reached, the sell order is removed from state.
	Expiration *time.Time `protobuf:"bytes,6,opt,name=expiration,proto3,stdtime" json:"expiration,omitempty"`
}

func (m *EventSell) Reset()         { *m = EventSell{} }
func (m *EventSell) String() string { return proto.CompactTextString(m) }
func (*EventSell) ProtoMessage()    {}
func (*EventSell) Descriptor() ([]byte, []int) {
	return fileDescriptor_68b71b54d42cf1d9, []int{0}
}
func (m *EventSell) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSell) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSell.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSell) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSell.Merge(m, src)
}
func (m *EventSell) XXX_Size() int {
	return m.Size()
}
func (m *EventSell) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSell.DiscardUnknown(m)
}

var xxx_messageInfo_EventSell proto.InternalMessageInfo

func (m *EventSell) GetOrderId() uint64 {
	if m != nil {
		return m.OrderId
	}
	return 0
}

func (m *EventSell) GetBatchDenom() string {
	if m != nil {
		return m.BatchDenom
	}
	return ""
}

func (m *EventSell) GetQuantity() string {
	if m != nil {
		return m.Quantity
	}
	return ""
}

func (m *EventSell) GetAskPrice() *types.Coin {
	if m != nil {
		return m.AskPrice
	}
	return nil
}

func (m *EventSell) GetDisableAutoRetire() bool {
	if m != nil {
		return m.DisableAutoRetire
	}
	return false
}

func (m *EventSell) GetExpiration() *time.Time {
	if m != nil {
		return m.Expiration
	}
	return nil
}

// EventUpdateSellOrder is an event emitted when a sell order is updated.
type EventUpdateSellOrder struct {
	// owner is the owner of the sell orders.
	Owner string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	//  sell_order_id is the ID of an existing sell order.
	SellOrderId uint64 `protobuf:"varint,2,opt,name=sell_order_id,json=sellOrderId,proto3" json:"sell_order_id,omitempty"`
	// batch_denom is the credit batch being sold.
	BatchDenom string `protobuf:"bytes,3,opt,name=batch_denom,json=batchDenom,proto3" json:"batch_denom,omitempty"`
	// new_quantity is the updated quantity of credits available to sell, if it
	// is set to zero then the order is cancelled.
	NewQuantity string `protobuf:"bytes,4,opt,name=new_quantity,json=newQuantity,proto3" json:"new_quantity,omitempty"`
	// new_ask_price is the new ask price for this sell order
	NewAskPrice *types.Coin `protobuf:"bytes,5,opt,name=new_ask_price,json=newAskPrice,proto3" json:"new_ask_price,omitempty"`
	// disable_auto_retire updates the disable_auto_retire field in the sell order.
	DisableAutoRetire bool `protobuf:"varint,6,opt,name=disable_auto_retire,json=disableAutoRetire,proto3" json:"disable_auto_retire,omitempty"`
	// new_expiration is an optional timestamp when the sell order expires. When the
	// expiration time is reached, the sell order is removed from state.
	NewExpiration *time.Time `protobuf:"bytes,7,opt,name=new_expiration,json=newExpiration,proto3,stdtime" json:"new_expiration,omitempty"`
}

func (m *EventUpdateSellOrder) Reset()         { *m = EventUpdateSellOrder{} }
func (m *EventUpdateSellOrder) String() string { return proto.CompactTextString(m) }
func (*EventUpdateSellOrder) ProtoMessage()    {}
func (*EventUpdateSellOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_68b71b54d42cf1d9, []int{1}
}
func (m *EventUpdateSellOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventUpdateSellOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventUpdateSellOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventUpdateSellOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventUpdateSellOrder.Merge(m, src)
}
func (m *EventUpdateSellOrder) XXX_Size() int {
	return m.Size()
}
func (m *EventUpdateSellOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_EventUpdateSellOrder.DiscardUnknown(m)
}

var xxx_messageInfo_EventUpdateSellOrder proto.InternalMessageInfo

func (m *EventUpdateSellOrder) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *EventUpdateSellOrder) GetSellOrderId() uint64 {
	if m != nil {
		return m.SellOrderId
	}
	return 0
}

func (m *EventUpdateSellOrder) GetBatchDenom() string {
	if m != nil {
		return m.BatchDenom
	}
	return ""
}

func (m *EventUpdateSellOrder) GetNewQuantity() string {
	if m != nil {
		return m.NewQuantity
	}
	return ""
}

func (m *EventUpdateSellOrder) GetNewAskPrice() *types.Coin {
	if m != nil {
		return m.NewAskPrice
	}
	return nil
}

func (m *EventUpdateSellOrder) GetDisableAutoRetire() bool {
	if m != nil {
		return m.DisableAutoRetire
	}
	return false
}

func (m *EventUpdateSellOrder) GetNewExpiration() *time.Time {
	if m != nil {
		return m.NewExpiration
	}
	return nil
}

// EventBuyOrderCreated is an event emitted when a buy order is created.
type EventBuyOrderCreated struct {
	// buy_order_id is the unique ID of buy order.
	BuyOrderId uint64 `protobuf:"varint,1,opt,name=buy_order_id,json=buyOrderId,proto3" json:"buy_order_id,omitempty"`
	// sell_order_id is the sell order ID against which the buyer is trying to buy.
	SellOrderId uint64 `protobuf:"varint,2,opt,name=sell_order_id,json=sellOrderId,proto3" json:"sell_order_id,omitempty"`
	// quantity is the quantity of credits to buy. If the quantity of credits
	// available is less than this amount the order will be partially filled
	// unless disable_partial_fill is true.
	Quantity string `protobuf:"bytes,3,opt,name=quantity,proto3" json:"quantity,omitempty"`
	// bid price is the bid price for this buy order. A credit unit will be
	// settled at a purchase price that is no more than the bid price. The
	// buy order will fail if the buyer does not have enough funds available
	// to complete the purchase.
	BidPrice *types.Coin `protobuf:"bytes,4,opt,name=bid_price,json=bidPrice,proto3" json:"bid_price,omitempty"`
	// disable_auto_retire allows auto-retirement to be disabled. If it is set to true
	// the credits will not auto-retire and can be resold assuming that the
	// corresponding sell order has auto-retirement disabled. If the sell order
	// hasn't disabled auto-retirement and the buy order tries to disable it,
	// that buy order will fail.
	DisableAutoRetire bool `protobuf:"varint,5,opt,name=disable_auto_retire,json=disableAutoRetire,proto3" json:"disable_auto_retire,omitempty"`
	// disable_partial_fill disables the default behavior of partially filling
	// buy orders if the requested quantity is not available.
	DisablePartialFill bool `protobuf:"varint,6,opt,name=disable_partial_fill,json=disablePartialFill,proto3" json:"disable_partial_fill,omitempty"`
	// retirement_location is the optional retirement location for the credits
	// which will be used only if disable_auto_retire is false.
	RetirementLocation string `protobuf:"bytes,7,opt,name=retirement_location,json=retirementLocation,proto3" json:"retirement_location,omitempty"`
	// expiration is the optional timestamp when the buy order expires. When the
	// expiration time is reached, the buy order is removed from state.
	Expiration *time.Time `protobuf:"bytes,8,opt,name=expiration,proto3,stdtime" json:"expiration,omitempty"`
}

func (m *EventBuyOrderCreated) Reset()         { *m = EventBuyOrderCreated{} }
func (m *EventBuyOrderCreated) String() string { return proto.CompactTextString(m) }
func (*EventBuyOrderCreated) ProtoMessage()    {}
func (*EventBuyOrderCreated) Descriptor() ([]byte, []int) {
	return fileDescriptor_68b71b54d42cf1d9, []int{2}
}
func (m *EventBuyOrderCreated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventBuyOrderCreated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventBuyOrderCreated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventBuyOrderCreated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventBuyOrderCreated.Merge(m, src)
}
func (m *EventBuyOrderCreated) XXX_Size() int {
	return m.Size()
}
func (m *EventBuyOrderCreated) XXX_DiscardUnknown() {
	xxx_messageInfo_EventBuyOrderCreated.DiscardUnknown(m)
}

var xxx_messageInfo_EventBuyOrderCreated proto.InternalMessageInfo

func (m *EventBuyOrderCreated) GetBuyOrderId() uint64 {
	if m != nil {
		return m.BuyOrderId
	}
	return 0
}

func (m *EventBuyOrderCreated) GetSellOrderId() uint64 {
	if m != nil {
		return m.SellOrderId
	}
	return 0
}

func (m *EventBuyOrderCreated) GetQuantity() string {
	if m != nil {
		return m.Quantity
	}
	return ""
}

func (m *EventBuyOrderCreated) GetBidPrice() *types.Coin {
	if m != nil {
		return m.BidPrice
	}
	return nil
}

func (m *EventBuyOrderCreated) GetDisableAutoRetire() bool {
	if m != nil {
		return m.DisableAutoRetire
	}
	return false
}

func (m *EventBuyOrderCreated) GetDisablePartialFill() bool {
	if m != nil {
		return m.DisablePartialFill
	}
	return false
}

func (m *EventBuyOrderCreated) GetRetirementLocation() string {
	if m != nil {
		return m.RetirementLocation
	}
	return ""
}

func (m *EventBuyOrderCreated) GetExpiration() *time.Time {
	if m != nil {
		return m.Expiration
	}
	return nil
}

// EventBuyOrderFilled is an event emitted when a buy order is filled.
type EventBuyOrderFilled struct {
	// buy_order_id is the unique ID of the buy order.
	BuyOrderId uint64 `protobuf:"varint,1,opt,name=buy_order_id,json=buyOrderId,proto3" json:"buy_order_id,omitempty"`
	// sell_order_id is the unique ID of the sell order.
	SellOrderId uint64 `protobuf:"varint,2,opt,name=sell_order_id,json=sellOrderId,proto3" json:"sell_order_id,omitempty"`
	// batch_denom is the credit batch ID of the purchased credits.
	BatchDenom string `protobuf:"bytes,3,opt,name=batch_denom,json=batchDenom,proto3" json:"batch_denom,omitempty"`
	// quantity is the quantity of the purchased credits.
	Quantity string `protobuf:"bytes,4,opt,name=quantity,proto3" json:"quantity,omitempty"`
	// total_price is the total price for the purchased credits.
	TotalPrice *types.Coin `protobuf:"bytes,5,opt,name=total_price,json=totalPrice,proto3" json:"total_price,omitempty"`
}

func (m *EventBuyOrderFilled) Reset()         { *m = EventBuyOrderFilled{} }
func (m *EventBuyOrderFilled) String() string { return proto.CompactTextString(m) }
func (*EventBuyOrderFilled) ProtoMessage()    {}
func (*EventBuyOrderFilled) Descriptor() ([]byte, []int) {
	return fileDescriptor_68b71b54d42cf1d9, []int{3}
}
func (m *EventBuyOrderFilled) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventBuyOrderFilled) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventBuyOrderFilled.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventBuyOrderFilled) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventBuyOrderFilled.Merge(m, src)
}
func (m *EventBuyOrderFilled) XXX_Size() int {
	return m.Size()
}
func (m *EventBuyOrderFilled) XXX_DiscardUnknown() {
	xxx_messageInfo_EventBuyOrderFilled.DiscardUnknown(m)
}

var xxx_messageInfo_EventBuyOrderFilled proto.InternalMessageInfo

func (m *EventBuyOrderFilled) GetBuyOrderId() uint64 {
	if m != nil {
		return m.BuyOrderId
	}
	return 0
}

func (m *EventBuyOrderFilled) GetSellOrderId() uint64 {
	if m != nil {
		return m.SellOrderId
	}
	return 0
}

func (m *EventBuyOrderFilled) GetBatchDenom() string {
	if m != nil {
		return m.BatchDenom
	}
	return ""
}

func (m *EventBuyOrderFilled) GetQuantity() string {
	if m != nil {
		return m.Quantity
	}
	return ""
}

func (m *EventBuyOrderFilled) GetTotalPrice() *types.Coin {
	if m != nil {
		return m.TotalPrice
	}
	return nil
}

// EventAllowAskDenom is an event emitted when an ask denom is added.
type EventAllowAskDenom struct {
	// denom is the denom to allow (ex. ibc/GLKHDSG423SGS)
	Denom string `protobuf:"bytes,1,opt,name=denom,proto3" json:"denom,omitempty"`
	// display_denom is the denom to display to the user and is informational
	DisplayDenom string `protobuf:"bytes,2,opt,name=display_denom,json=displayDenom,proto3" json:"display_denom,omitempty"`
	// exponent is the exponent that relates the denom to the display_denom and is
	// informational
	Exponent uint32 `protobuf:"varint,3,opt,name=exponent,proto3" json:"exponent,omitempty"`
}

func (m *EventAllowAskDenom) Reset()         { *m = EventAllowAskDenom{} }
func (m *EventAllowAskDenom) String() string { return proto.CompactTextString(m) }
func (*EventAllowAskDenom) ProtoMessage()    {}
func (*EventAllowAskDenom) Descriptor() ([]byte, []int) {
	return fileDescriptor_68b71b54d42cf1d9, []int{4}
}
func (m *EventAllowAskDenom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventAllowAskDenom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventAllowAskDenom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventAllowAskDenom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventAllowAskDenom.Merge(m, src)
}
func (m *EventAllowAskDenom) XXX_Size() int {
	return m.Size()
}
func (m *EventAllowAskDenom) XXX_DiscardUnknown() {
	xxx_messageInfo_EventAllowAskDenom.DiscardUnknown(m)
}

var xxx_messageInfo_EventAllowAskDenom proto.InternalMessageInfo

func (m *EventAllowAskDenom) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *EventAllowAskDenom) GetDisplayDenom() string {
	if m != nil {
		return m.DisplayDenom
	}
	return ""
}

func (m *EventAllowAskDenom) GetExponent() uint32 {
	if m != nil {
		return m.Exponent
	}
	return 0
}

func init() {
	proto.RegisterType((*EventSell)(nil), "regen.ecocredit.marketplace.v1.EventSell")
	proto.RegisterType((*EventUpdateSellOrder)(nil), "regen.ecocredit.marketplace.v1.EventUpdateSellOrder")
	proto.RegisterType((*EventBuyOrderCreated)(nil), "regen.ecocredit.marketplace.v1.EventBuyOrderCreated")
	proto.RegisterType((*EventBuyOrderFilled)(nil), "regen.ecocredit.marketplace.v1.EventBuyOrderFilled")
	proto.RegisterType((*EventAllowAskDenom)(nil), "regen.ecocredit.marketplace.v1.EventAllowAskDenom")
}

func init() {
	proto.RegisterFile("regen/ecocredit/marketplace/v1/events.proto", fileDescriptor_68b71b54d42cf1d9)
}

var fileDescriptor_68b71b54d42cf1d9 = []byte{
	// 674 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x95, 0x4f, 0x6f, 0xd3, 0x30,
	0x18, 0xc6, 0x97, 0xae, 0xdd, 0x5a, 0x77, 0x45, 0xc2, 0xeb, 0xa1, 0xeb, 0x21, 0x2b, 0xe5, 0x52,
	0x09, 0x91, 0x30, 0x90, 0x38, 0x20, 0x21, 0xed, 0x0f, 0x03, 0x4d, 0x42, 0x62, 0x04, 0xb8, 0xec,
	0x12, 0x39, 0xc9, 0xbb, 0xce, 0xaa, 0x63, 0x07, 0xc7, 0x59, 0xd7, 0x0f, 0xc0, 0x11, 0x69, 0x1f,
	0x8b, 0x03, 0x87, 0x1d, 0x38, 0x70, 0x03, 0x6d, 0x5f, 0x04, 0xd9, 0x49, 0xff, 0x6c, 0xd3, 0xd4,
	0x6a, 0xe2, 0xd6, 0xd7, 0xef, 0xe3, 0xf8, 0xc9, 0xef, 0x7d, 0xea, 0xa0, 0x27, 0x12, 0xfa, 0xc0,
	0x5d, 0x08, 0x45, 0x28, 0x21, 0xa2, 0xca, 0x8d, 0x89, 0x1c, 0x80, 0x4a, 0x18, 0x09, 0xc1, 0x3d,
	0xdd, 0x72, 0xe1, 0x14, 0xb8, 0x4a, 0x9d, 0x44, 0x0a, 0x25, 0xb0, 0x6d, 0xc4, 0xce, 0x44, 0xec,
	0xcc, 0x88, 0x9d, 0xd3, 0xad, 0x76, 0xb3, 0x2f, 0xfa, 0xc2, 0x48, 0x5d, 0xfd, 0x2b, 0xdf, 0xd5,
	0xb6, 0x43, 0x91, 0xc6, 0x22, 0x75, 0x03, 0x92, 0xea, 0x47, 0x06, 0xa0, 0xc8, 0x96, 0x1b, 0x0a,
	0xca, 0x8b, 0xfe, 0x66, 0x5f, 0x88, 0x3e, 0x03, 0xd7, 0x54, 0x41, 0x76, 0xec, 0x2a, 0x1a, 0x43,
	0xaa, 0x48, 0x9c, 0xe4, 0x82, 0xee, 0xf7, 0x12, 0xaa, 0xed, 0x6b, 0x1f, 0x9f, 0x80, 0x31, 0xbc,
	0x81, 0xaa, 0x42, 0x46, 0x20, 0x7d, 0x1a, 0xb5, 0xac, 0x8e, 0xd5, 0x2b, 0x7b, 0xab, 0xa6, 0x3e,
	0x88, 0xf0, 0x26, 0xaa, 0x07, 0x44, 0x85, 0x27, 0x7e, 0x04, 0x5c, 0xc4, 0xad, 0x52, 0xc7, 0xea,
	0xd5, 0x3c, 0x64, 0x96, 0xde, 0xe8, 0x15, 0xdc, 0x46, 0xd5, 0xaf, 0x19, 0xe1, 0x8a, 0xaa, 0x51,
	0x6b, 0xd9, 0x74, 0x27, 0x35, 0x7e, 0x89, 0x6a, 0x24, 0x1d, 0xf8, 0x89, 0xa4, 0x21, 0xb4, 0xca,
	0x1d, 0xab, 0x57, 0x7f, 0xbe, 0xe1, 0xe4, 0xd6, 0x1d, 0x6d, 0xdd, 0x29, 0xac, 0x3b, 0x7b, 0x82,
	0x72, 0xaf, 0x4a, 0xd2, 0xc1, 0xa1, 0x96, 0x62, 0x07, 0xad, 0x47, 0x34, 0x25, 0x01, 0x03, 0x9f,
	0x64, 0x4a, 0xf8, 0x12, 0x14, 0x95, 0xd0, 0xaa, 0x74, 0xac, 0x5e, 0xd5, 0x7b, 0x58, 0xb4, 0x76,
	0x32, 0x25, 0x3c, 0xd3, 0xc0, 0xdb, 0x08, 0xc1, 0x59, 0x42, 0x25, 0x51, 0x54, 0xf0, 0xd6, 0x8a,
	0x39, 0xa8, 0xed, 0xe4, 0x0c, 0x9c, 0x31, 0x03, 0xe7, 0xf3, 0x98, 0xc1, 0x6e, 0xf9, 0xfc, 0xcf,
	0xa6, 0xe5, 0xcd, 0xec, 0xe9, 0xfe, 0x2c, 0xa1, 0xa6, 0xe1, 0xf1, 0x25, 0x89, 0x88, 0x02, 0x4d,
	0xe5, 0x83, 0x26, 0x80, 0x9b, 0xa8, 0x22, 0x86, 0x1c, 0xa4, 0xe1, 0x52, 0xf3, 0xf2, 0x02, 0x77,
	0x51, 0x23, 0x05, 0xc6, 0xfc, 0x09, 0xb5, 0x92, 0xa1, 0x56, 0x4f, 0xc7, 0xfb, 0x6e, 0x93, 0x5b,
	0xbe, 0x45, 0xee, 0x11, 0x5a, 0xe3, 0x30, 0xf4, 0x27, 0xf4, 0xca, 0x46, 0x51, 0xe7, 0x30, 0xfc,
	0x38, 0x06, 0xf8, 0x1a, 0x35, 0xb4, 0x64, 0x0a, 0xb1, 0x32, 0x0f, 0xa2, 0xde, 0xbe, 0x33, 0x87,
	0xe3, 0xca, 0x5d, 0x1c, 0xdf, 0xa1, 0x07, 0xfa, 0xb8, 0x19, 0x96, 0xab, 0x0b, 0xb2, 0xd4, 0x36,
	0xf7, 0xa7, 0x38, 0xbf, 0x2d, 0x17, 0x38, 0x77, 0xb3, 0x91, 0xe1, 0xb1, 0x27, 0x81, 0x28, 0x88,
	0x70, 0x07, 0xad, 0x05, 0xd9, 0xc8, 0xbf, 0x91, 0x36, 0x14, 0x14, 0xb2, 0x83, 0x68, 0x21, 0xb4,
	0x73, 0x32, 0x17, 0xd0, 0x68, 0xe1, 0xcc, 0x05, 0x34, 0xba, 0x5f, 0xe6, 0x9e, 0xa1, 0xe6, 0x58,
	0x9f, 0x10, 0xa9, 0x28, 0x61, 0xfe, 0x31, 0x65, 0xac, 0x80, 0x8b, 0x8b, 0xde, 0x61, 0xde, 0x7a,
	0x4b, 0x19, 0xc3, 0x2e, 0x5a, 0xcf, 0x1f, 0x1a, 0x03, 0x57, 0x3e, 0x13, 0xe1, 0x14, 0x71, 0xcd,
	0xc3, 0xd3, 0xd6, 0xfb, 0xa2, 0x73, 0x23, 0xd6, 0xd5, 0x7b, 0xc4, 0xfa, 0x97, 0x85, 0xd6, 0xaf,
	0xcd, 0x41, 0x1b, 0xf9, 0x6f, 0x63, 0x98, 0x9b, 0xf0, 0xd9, 0x39, 0x95, 0x6f, 0xcc, 0xe9, 0x15,
	0xaa, 0x2b, 0xa1, 0x08, 0x5b, 0x34, 0xd8, 0xc8, 0xa8, 0xcd, 0xac, 0xba, 0x03, 0x84, 0xcd, 0x5b,
	0xed, 0x30, 0x26, 0x74, 0xda, 0xf3, 0xd3, 0x9a, 0xa8, 0x92, 0x1b, 0x29, 0xfe, 0xaa, 0xa6, 0xc0,
	0x8f, 0x51, 0x23, 0xa2, 0x69, 0xc2, 0xc8, 0xe8, 0xda, 0x15, 0xb6, 0x56, 0x2c, 0x4e, 0x8c, 0xc2,
	0x59, 0x22, 0x38, 0x70, 0x65, 0x5e, 0xa3, 0xe1, 0x4d, 0xea, 0xdd, 0xa3, 0x1f, 0x97, 0xb6, 0x75,
	0x71, 0x69, 0x5b, 0x7f, 0x2f, 0x6d, 0xeb, 0xfc, 0xca, 0x5e, 0xba, 0xb8, 0xb2, 0x97, 0x7e, 0x5f,
	0xd9, 0x4b, 0x47, 0xdb, 0x7d, 0xaa, 0x4e, 0xb2, 0xc0, 0x09, 0x45, 0xec, 0x9a, 0x6b, 0xfc, 0x29,
	0x07, 0x35, 0x14, 0x72, 0x50, 0x54, 0x0c, 0xa2, 0x3e, 0x48, 0xf7, 0xec, 0xce, 0x4f, 0x41, 0xb0,
	0x62, 0xa6, 0xf8, 0xe2, 0x5f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xe3, 0x9f, 0x4e, 0x57, 0x33, 0x06,
	0x00, 0x00,
}

func (m *EventSell) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSell) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSell) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Expiration != nil {
		n1, err1 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.Expiration, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.Expiration):])
		if err1 != nil {
			return 0, err1
		}
		i -= n1
		i = encodeVarintEvents(dAtA, i, uint64(n1))
		i--
		dAtA[i] = 0x32
	}
	if m.DisableAutoRetire {
		i--
		if m.DisableAutoRetire {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.AskPrice != nil {
		{
			size, err := m.AskPrice.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Quantity) > 0 {
		i -= len(m.Quantity)
		copy(dAtA[i:], m.Quantity)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Quantity)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.BatchDenom) > 0 {
		i -= len(m.BatchDenom)
		copy(dAtA[i:], m.BatchDenom)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.BatchDenom)))
		i--
		dAtA[i] = 0x12
	}
	if m.OrderId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.OrderId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventUpdateSellOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventUpdateSellOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventUpdateSellOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NewExpiration != nil {
		n3, err3 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.NewExpiration, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.NewExpiration):])
		if err3 != nil {
			return 0, err3
		}
		i -= n3
		i = encodeVarintEvents(dAtA, i, uint64(n3))
		i--
		dAtA[i] = 0x3a
	}
	if m.DisableAutoRetire {
		i--
		if m.DisableAutoRetire {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.NewAskPrice != nil {
		{
			size, err := m.NewAskPrice.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.NewQuantity) > 0 {
		i -= len(m.NewQuantity)
		copy(dAtA[i:], m.NewQuantity)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.NewQuantity)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.BatchDenom) > 0 {
		i -= len(m.BatchDenom)
		copy(dAtA[i:], m.BatchDenom)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.BatchDenom)))
		i--
		dAtA[i] = 0x1a
	}
	if m.SellOrderId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.SellOrderId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventBuyOrderCreated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventBuyOrderCreated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventBuyOrderCreated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Expiration != nil {
		n5, err5 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.Expiration, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.Expiration):])
		if err5 != nil {
			return 0, err5
		}
		i -= n5
		i = encodeVarintEvents(dAtA, i, uint64(n5))
		i--
		dAtA[i] = 0x42
	}
	if len(m.RetirementLocation) > 0 {
		i -= len(m.RetirementLocation)
		copy(dAtA[i:], m.RetirementLocation)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.RetirementLocation)))
		i--
		dAtA[i] = 0x3a
	}
	if m.DisablePartialFill {
		i--
		if m.DisablePartialFill {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.DisableAutoRetire {
		i--
		if m.DisableAutoRetire {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.BidPrice != nil {
		{
			size, err := m.BidPrice.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Quantity) > 0 {
		i -= len(m.Quantity)
		copy(dAtA[i:], m.Quantity)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Quantity)))
		i--
		dAtA[i] = 0x1a
	}
	if m.SellOrderId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.SellOrderId))
		i--
		dAtA[i] = 0x10
	}
	if m.BuyOrderId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.BuyOrderId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventBuyOrderFilled) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventBuyOrderFilled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventBuyOrderFilled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TotalPrice != nil {
		{
			size, err := m.TotalPrice.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Quantity) > 0 {
		i -= len(m.Quantity)
		copy(dAtA[i:], m.Quantity)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Quantity)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.BatchDenom) > 0 {
		i -= len(m.BatchDenom)
		copy(dAtA[i:], m.BatchDenom)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.BatchDenom)))
		i--
		dAtA[i] = 0x1a
	}
	if m.SellOrderId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.SellOrderId))
		i--
		dAtA[i] = 0x10
	}
	if m.BuyOrderId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.BuyOrderId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventAllowAskDenom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventAllowAskDenom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventAllowAskDenom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Exponent != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Exponent))
		i--
		dAtA[i] = 0x18
	}
	if len(m.DisplayDenom) > 0 {
		i -= len(m.DisplayDenom)
		copy(dAtA[i:], m.DisplayDenom)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.DisplayDenom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintEvents(dAtA []byte, offset int, v uint64) int {
	offset -= sovEvents(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EventSell) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrderId != 0 {
		n += 1 + sovEvents(uint64(m.OrderId))
	}
	l = len(m.BatchDenom)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Quantity)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.AskPrice != nil {
		l = m.AskPrice.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.DisableAutoRetire {
		n += 2
	}
	if m.Expiration != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.Expiration)
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventUpdateSellOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.SellOrderId != 0 {
		n += 1 + sovEvents(uint64(m.SellOrderId))
	}
	l = len(m.BatchDenom)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.NewQuantity)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.NewAskPrice != nil {
		l = m.NewAskPrice.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.DisableAutoRetire {
		n += 2
	}
	if m.NewExpiration != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.NewExpiration)
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventBuyOrderCreated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BuyOrderId != 0 {
		n += 1 + sovEvents(uint64(m.BuyOrderId))
	}
	if m.SellOrderId != 0 {
		n += 1 + sovEvents(uint64(m.SellOrderId))
	}
	l = len(m.Quantity)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.BidPrice != nil {
		l = m.BidPrice.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.DisableAutoRetire {
		n += 2
	}
	if m.DisablePartialFill {
		n += 2
	}
	l = len(m.RetirementLocation)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Expiration != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.Expiration)
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventBuyOrderFilled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BuyOrderId != 0 {
		n += 1 + sovEvents(uint64(m.BuyOrderId))
	}
	if m.SellOrderId != 0 {
		n += 1 + sovEvents(uint64(m.SellOrderId))
	}
	l = len(m.BatchDenom)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Quantity)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.TotalPrice != nil {
		l = m.TotalPrice.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventAllowAskDenom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.DisplayDenom)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Exponent != 0 {
		n += 1 + sovEvents(uint64(m.Exponent))
	}
	return n
}

func sovEvents(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEvents(x uint64) (n int) {
	return sovEvents(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EventSell) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSell: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSell: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			m.OrderId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Quantity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AskPrice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AskPrice == nil {
				m.AskPrice = &types.Coin{}
			}
			if err := m.AskPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableAutoRetire", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableAutoRetire = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expiration == nil {
				m.Expiration = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.Expiration, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventUpdateSellOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventUpdateSellOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventUpdateSellOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SellOrderId", wireType)
			}
			m.SellOrderId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SellOrderId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewQuantity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewQuantity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewAskPrice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NewAskPrice == nil {
				m.NewAskPrice = &types.Coin{}
			}
			if err := m.NewAskPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableAutoRetire", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableAutoRetire = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewExpiration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NewExpiration == nil {
				m.NewExpiration = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.NewExpiration, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventBuyOrderCreated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventBuyOrderCreated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventBuyOrderCreated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyOrderId", wireType)
			}
			m.BuyOrderId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuyOrderId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SellOrderId", wireType)
			}
			m.SellOrderId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SellOrderId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Quantity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BidPrice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BidPrice == nil {
				m.BidPrice = &types.Coin{}
			}
			if err := m.BidPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableAutoRetire", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableAutoRetire = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisablePartialFill", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisablePartialFill = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetirementLocation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetirementLocation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expiration == nil {
				m.Expiration = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.Expiration, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventBuyOrderFilled) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventBuyOrderFilled: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventBuyOrderFilled: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyOrderId", wireType)
			}
			m.BuyOrderId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuyOrderId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SellOrderId", wireType)
			}
			m.SellOrderId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SellOrderId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Quantity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalPrice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TotalPrice == nil {
				m.TotalPrice = &types.Coin{}
			}
			if err := m.TotalPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventAllowAskDenom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventAllowAskDenom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventAllowAskDenom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exponent", wireType)
			}
			m.Exponent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exponent |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEvents(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEvents
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupEvents
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthEvents
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthEvents        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEvents          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupEvents = fmt.Errorf("proto: unexpected end of group")
)
