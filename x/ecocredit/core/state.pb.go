// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: regen/ecocredit/v1/state.proto

package core

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-sdk/api/cosmos/orm/v1alpha1"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// CreditType defines the measurement unit/precision of a certain credit type
// (e.g. carbon, biodiversity...)
type CreditType struct {
	// abbreviation is a 1-3 character uppercase abbreviation of the CreditType
	// name, used in batch denominations within the CreditType. It must be unique.
	Abbreviation string `protobuf:"bytes,1,opt,name=abbreviation,proto3" json:"abbreviation,omitempty"`
	// name is the name of the credit type (e.g. carbon, biodiversity).
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// unit is the measurement unit of the credit type (e.g. kg, ton).
	Unit string `protobuf:"bytes,3,opt,name=unit,proto3" json:"unit,omitempty"`
	// precision is the decimal precision of the credit type.
	Precision uint32 `protobuf:"varint,4,opt,name=precision,proto3" json:"precision,omitempty"`
}

func (m *CreditType) Reset()         { *m = CreditType{} }
func (m *CreditType) String() string { return proto.CompactTextString(m) }
func (*CreditType) ProtoMessage()    {}
func (*CreditType) Descriptor() ([]byte, []int) {
	return fileDescriptor_6cfdca0a4aaabb36, []int{0}
}
func (m *CreditType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreditType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreditType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreditType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreditType.Merge(m, src)
}
func (m *CreditType) XXX_Size() int {
	return m.Size()
}
func (m *CreditType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreditType.DiscardUnknown(m)
}

var xxx_messageInfo_CreditType proto.InternalMessageInfo

func (m *CreditType) GetAbbreviation() string {
	if m != nil {
		return m.Abbreviation
	}
	return ""
}

func (m *CreditType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CreditType) GetUnit() string {
	if m != nil {
		return m.Unit
	}
	return ""
}

func (m *CreditType) GetPrecision() uint32 {
	if m != nil {
		return m.Precision
	}
	return 0
}

// ClassInfo represents the high-level on-chain information for a credit class.
type ClassInfo struct {
	// key is the table row identifier of the credit class used internally for
	// efficient lookups. This identifier is auto-incrementing.
	Key uint64 `protobuf:"varint,1,opt,name=key,proto3" json:"key,omitempty"`
	// id is the unique identifier of the credit class auto-generated from the
	// credit type abbreviation and the credit class sequence number.
	Id string `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	// admin is the admin of the credit class.
	Admin []byte `protobuf:"bytes,3,opt,name=admin,proto3" json:"admin,omitempty"`
	// metadata is any arbitrary metadata to attached to the credit class.
	Metadata string `protobuf:"bytes,4,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// credit_type_abbrev is the abbreviation of the credit type.
	CreditTypeAbbrev string `protobuf:"bytes,5,opt,name=credit_type_abbrev,json=creditTypeAbbrev,proto3" json:"credit_type_abbrev,omitempty"`
}

func (m *ClassInfo) Reset()         { *m = ClassInfo{} }
func (m *ClassInfo) String() string { return proto.CompactTextString(m) }
func (*ClassInfo) ProtoMessage()    {}
func (*ClassInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_6cfdca0a4aaabb36, []int{1}
}
func (m *ClassInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClassInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClassInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClassInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClassInfo.Merge(m, src)
}
func (m *ClassInfo) XXX_Size() int {
	return m.Size()
}
func (m *ClassInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ClassInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ClassInfo proto.InternalMessageInfo

func (m *ClassInfo) GetKey() uint64 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *ClassInfo) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ClassInfo) GetAdmin() []byte {
	if m != nil {
		return m.Admin
	}
	return nil
}

func (m *ClassInfo) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

func (m *ClassInfo) GetCreditTypeAbbrev() string {
	if m != nil {
		return m.CreditTypeAbbrev
	}
	return ""
}

// ClassIssuers is a JOIN table for Class Info that stores the credit class
// issuers
type ClassIssuer struct {
	// class_key is the table row identifier of the credit class used internally
	// for efficient lookups. This links a class issuer to a credit class.
	ClassKey uint64 `protobuf:"varint,1,opt,name=class_key,json=classKey,proto3" json:"class_key,omitempty"`
	// issuer is the approved issuer of the credit class.
	Issuer []byte `protobuf:"bytes,2,opt,name=issuer,proto3" json:"issuer,omitempty"`
}

func (m *ClassIssuer) Reset()         { *m = ClassIssuer{} }
func (m *ClassIssuer) String() string { return proto.CompactTextString(m) }
func (*ClassIssuer) ProtoMessage()    {}
func (*ClassIssuer) Descriptor() ([]byte, []int) {
	return fileDescriptor_6cfdca0a4aaabb36, []int{2}
}
func (m *ClassIssuer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClassIssuer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClassIssuer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClassIssuer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClassIssuer.Merge(m, src)
}
func (m *ClassIssuer) XXX_Size() int {
	return m.Size()
}
func (m *ClassIssuer) XXX_DiscardUnknown() {
	xxx_messageInfo_ClassIssuer.DiscardUnknown(m)
}

var xxx_messageInfo_ClassIssuer proto.InternalMessageInfo

func (m *ClassIssuer) GetClassKey() uint64 {
	if m != nil {
		return m.ClassKey
	}
	return 0
}

func (m *ClassIssuer) GetIssuer() []byte {
	if m != nil {
		return m.Issuer
	}
	return nil
}

// ProjectInfo represents the high-level on-chain information for a project.
type ProjectInfo struct {
	// key is the table row identifier of the project used internally for
	// efficient lookups. This identifier is auto-incrementing.
	Key uint64 `protobuf:"varint,1,opt,name=key,proto3" json:"key,omitempty"`
	// id is the unique identifier of the project either auto-generated from the
	// credit class id and project sequence number or provided upon creation.
	Id string `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	// admin is the admin of the project.
	Admin []byte `protobuf:"bytes,3,opt,name=admin,proto3" json:"admin,omitempty"`
	// class_key is the table row identifier of the credit class used internally
	// for efficient lookups. This links a project to a credit class.
	ClassKey uint64 `protobuf:"varint,4,opt,name=class_key,json=classKey,proto3" json:"class_key,omitempty"`
	// project_location is the location of the project.
	// Full documentation can be found in MsgCreateProject.project_location.
	ProjectLocation string `protobuf:"bytes,5,opt,name=project_location,json=projectLocation,proto3" json:"project_location,omitempty"`
	// metadata is any arbitrary metadata attached to the project.
	Metadata string `protobuf:"bytes,6,opt,name=metadata,proto3" json:"metadata,omitempty"`
}

func (m *ProjectInfo) Reset()         { *m = ProjectInfo{} }
func (m *ProjectInfo) String() string { return proto.CompactTextString(m) }
func (*ProjectInfo) ProtoMessage()    {}
func (*ProjectInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_6cfdca0a4aaabb36, []int{3}
}
func (m *ProjectInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProjectInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProjectInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProjectInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProjectInfo.Merge(m, src)
}
func (m *ProjectInfo) XXX_Size() int {
	return m.Size()
}
func (m *ProjectInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ProjectInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ProjectInfo proto.InternalMessageInfo

func (m *ProjectInfo) GetKey() uint64 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *ProjectInfo) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ProjectInfo) GetAdmin() []byte {
	if m != nil {
		return m.Admin
	}
	return nil
}

func (m *ProjectInfo) GetClassKey() uint64 {
	if m != nil {
		return m.ClassKey
	}
	return 0
}

func (m *ProjectInfo) GetProjectLocation() string {
	if m != nil {
		return m.ProjectLocation
	}
	return ""
}

func (m *ProjectInfo) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

// BatchInfo represents the high-level on-chain information for a credit batch.
type BatchInfo struct {
	// key is the table row identifier of the credit batch used internally for
	// efficient lookups. This identifier is auto-incrementing.
	Key uint64 `protobuf:"varint,1,opt,name=key,proto3" json:"key,omitempty"`
	// issuer is the address that created the batch and which is
	// authorized to mint more credits if open=true.
	Issuer []byte `protobuf:"bytes,2,opt,name=issuer,proto3" json:"issuer,omitempty"`
	// project_key is the table row identifier of the credit class used internally
	// for efficient lookups. This links a credit batch to a project.
	ProjectKey uint64 `protobuf:"varint,3,opt,name=project_key,json=projectKey,proto3" json:"project_key,omitempty"`
	// batch_denom is the unique identifier of the credit batch formed from the
	// project id, the batch sequence number, and the start and end date of the
	// credit batch.
	BatchDenom string `protobuf:"bytes,4,opt,name=batch_denom,json=batchDenom,proto3" json:"batch_denom,omitempty"`
	// metadata is any arbitrary metadata attached to the credit batch.
	Metadata string `protobuf:"bytes,5,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// start_date is the beginning of the period during which this credit batch
	// was quantified and verified.
	StartDate *types.Timestamp `protobuf:"bytes,6,opt,name=start_date,json=startDate,proto3" json:"start_date,omitempty"`
	// end_date is the end of the period during which this credit batch was
	// quantified and verified.
	EndDate *types.Timestamp `protobuf:"bytes,7,opt,name=end_date,json=endDate,proto3" json:"end_date,omitempty"`
	// issuance_date is the timestamp when the credit batch was issued.
	IssuanceDate *types.Timestamp `protobuf:"bytes,8,opt,name=issuance_date,json=issuanceDate,proto3" json:"issuance_date,omitempty"`
	// open tells if it's possible to mint new credits in the future.
	// Once `open` is set to false, it can't be toggled any more.
	Open bool `protobuf:"varint,9,opt,name=open,proto3" json:"open,omitempty"`
}

func (m *BatchInfo) Reset()         { *m = BatchInfo{} }
func (m *BatchInfo) String() string { return proto.CompactTextString(m) }
func (*BatchInfo) ProtoMessage()    {}
func (*BatchInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_6cfdca0a4aaabb36, []int{4}
}
func (m *BatchInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchInfo.Merge(m, src)
}
func (m *BatchInfo) XXX_Size() int {
	return m.Size()
}
func (m *BatchInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchInfo.DiscardUnknown(m)
}

var xxx_messageInfo_BatchInfo proto.InternalMessageInfo

func (m *BatchInfo) GetKey() uint64 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *BatchInfo) GetIssuer() []byte {
	if m != nil {
		return m.Issuer
	}
	return nil
}

func (m *BatchInfo) GetProjectKey() uint64 {
	if m != nil {
		return m.ProjectKey
	}
	return 0
}

func (m *BatchInfo) GetBatchDenom() string {
	if m != nil {
		return m.BatchDenom
	}
	return ""
}

func (m *BatchInfo) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

func (m *BatchInfo) GetStartDate() *types.Timestamp {
	if m != nil {
		return m.StartDate
	}
	return nil
}

func (m *BatchInfo) GetEndDate() *types.Timestamp {
	if m != nil {
		return m.EndDate
	}
	return nil
}

func (m *BatchInfo) GetIssuanceDate() *types.Timestamp {
	if m != nil {
		return m.IssuanceDate
	}
	return nil
}

func (m *BatchInfo) GetOpen() bool {
	if m != nil {
		return m.Open
	}
	return false
}

// ClassSequence stores and increments the sequence number for credit classes
// within a credit type.
type ClassSequence struct {
	// credit_type_abbrev is the credit type abbreviation. This links a class
	// sequence to a credit type.
	CreditTypeAbbrev string `protobuf:"bytes,1,opt,name=credit_type_abbrev,json=creditTypeAbbrev,proto3" json:"credit_type_abbrev,omitempty"`
	// next_sequence is the next sequence number for a credit class within the
	// credit type. The sequence number is used to generate a class id.
	NextSequence uint64 `protobuf:"varint,2,opt,name=next_sequence,json=nextSequence,proto3" json:"next_sequence,omitempty"`
}

func (m *ClassSequence) Reset()         { *m = ClassSequence{} }
func (m *ClassSequence) String() string { return proto.CompactTextString(m) }
func (*ClassSequence) ProtoMessage()    {}
func (*ClassSequence) Descriptor() ([]byte, []int) {
	return fileDescriptor_6cfdca0a4aaabb36, []int{5}
}
func (m *ClassSequence) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClassSequence) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClassSequence.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClassSequence) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClassSequence.Merge(m, src)
}
func (m *ClassSequence) XXX_Size() int {
	return m.Size()
}
func (m *ClassSequence) XXX_DiscardUnknown() {
	xxx_messageInfo_ClassSequence.DiscardUnknown(m)
}

var xxx_messageInfo_ClassSequence proto.InternalMessageInfo

func (m *ClassSequence) GetCreditTypeAbbrev() string {
	if m != nil {
		return m.CreditTypeAbbrev
	}
	return ""
}

func (m *ClassSequence) GetNextSequence() uint64 {
	if m != nil {
		return m.NextSequence
	}
	return 0
}

// ProjectSequence stores and increments the sequence number for projects within
// a credit class.
type ProjectSequence struct {
	// class_key is the table row identifier of the credit class used internally
	// for efficient lookups. This links a project sequence to a credit class.
	ClassKey uint64 `protobuf:"varint,1,opt,name=class_key,json=classKey,proto3" json:"class_key,omitempty"`
	// next_sequence is the next sequence number for a project within the credit
	// class. The sequence number is used to generate a project id.
	NextSequence uint64 `protobuf:"varint,2,opt,name=next_sequence,json=nextSequence,proto3" json:"next_sequence,omitempty"`
}

func (m *ProjectSequence) Reset()         { *m = ProjectSequence{} }
func (m *ProjectSequence) String() string { return proto.CompactTextString(m) }
func (*ProjectSequence) ProtoMessage()    {}
func (*ProjectSequence) Descriptor() ([]byte, []int) {
	return fileDescriptor_6cfdca0a4aaabb36, []int{6}
}
func (m *ProjectSequence) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProjectSequence) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProjectSequence.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProjectSequence) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProjectSequence.Merge(m, src)
}
func (m *ProjectSequence) XXX_Size() int {
	return m.Size()
}
func (m *ProjectSequence) XXX_DiscardUnknown() {
	xxx_messageInfo_ProjectSequence.DiscardUnknown(m)
}

var xxx_messageInfo_ProjectSequence proto.InternalMessageInfo

func (m *ProjectSequence) GetClassKey() uint64 {
	if m != nil {
		return m.ClassKey
	}
	return 0
}

func (m *ProjectSequence) GetNextSequence() uint64 {
	if m != nil {
		return m.NextSequence
	}
	return 0
}

// BatchSequence stores and increments the sequence number for credit batches
// within a project.
type BatchSequence struct {
	// project_key is the table row identifier of the project used internally for
	// efficient lookups. This links a batch sequence to a project.
	ProjectKey uint64 `protobuf:"varint,1,opt,name=project_key,json=projectKey,proto3" json:"project_key,omitempty"`
	// next_sequence is the next sequence number for a credit batch within the
	// project. The sequence number is used to generate a batch denom.
	NextSequence uint64 `protobuf:"varint,2,opt,name=next_sequence,json=nextSequence,proto3" json:"next_sequence,omitempty"`
}

func (m *BatchSequence) Reset()         { *m = BatchSequence{} }
func (m *BatchSequence) String() string { return proto.CompactTextString(m) }
func (*BatchSequence) ProtoMessage()    {}
func (*BatchSequence) Descriptor() ([]byte, []int) {
	return fileDescriptor_6cfdca0a4aaabb36, []int{7}
}
func (m *BatchSequence) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchSequence) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchSequence.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchSequence) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchSequence.Merge(m, src)
}
func (m *BatchSequence) XXX_Size() int {
	return m.Size()
}
func (m *BatchSequence) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchSequence.DiscardUnknown(m)
}

var xxx_messageInfo_BatchSequence proto.InternalMessageInfo

func (m *BatchSequence) GetProjectKey() uint64 {
	if m != nil {
		return m.ProjectKey
	}
	return 0
}

func (m *BatchSequence) GetNextSequence() uint64 {
	if m != nil {
		return m.NextSequence
	}
	return 0
}

// BatchBalance stores each accounts credit balance.
type BatchBalance struct {
	// batch_key is the table row identifier of the credit batch used internally
	// for efficient lookups. This links a batch balance to a credit batch.
	BatchKey uint64 `protobuf:"varint,1,opt,name=batch_key,json=batchKey,proto3" json:"batch_key,omitempty"`
	// address is the address of the credit holder.
	Address []byte `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	// tradable is the tradable amount of credits.
	Tradable string `protobuf:"bytes,3,opt,name=tradable,proto3" json:"tradable,omitempty"`
	// retired is the retired amount of credits.
	Retired string `protobuf:"bytes,4,opt,name=retired,proto3" json:"retired,omitempty"`
	// escrowed is the amount of credits locked up in escrow for the marketplace.
	Escrowed string `protobuf:"bytes,5,opt,name=escrowed,proto3" json:"escrowed,omitempty"`
}

func (m *BatchBalance) Reset()         { *m = BatchBalance{} }
func (m *BatchBalance) String() string { return proto.CompactTextString(m) }
func (*BatchBalance) ProtoMessage()    {}
func (*BatchBalance) Descriptor() ([]byte, []int) {
	return fileDescriptor_6cfdca0a4aaabb36, []int{8}
}
func (m *BatchBalance) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchBalance) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchBalance.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchBalance) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchBalance.Merge(m, src)
}
func (m *BatchBalance) XXX_Size() int {
	return m.Size()
}
func (m *BatchBalance) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchBalance.DiscardUnknown(m)
}

var xxx_messageInfo_BatchBalance proto.InternalMessageInfo

func (m *BatchBalance) GetBatchKey() uint64 {
	if m != nil {
		return m.BatchKey
	}
	return 0
}

func (m *BatchBalance) GetAddress() []byte {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *BatchBalance) GetTradable() string {
	if m != nil {
		return m.Tradable
	}
	return ""
}

func (m *BatchBalance) GetRetired() string {
	if m != nil {
		return m.Retired
	}
	return ""
}

func (m *BatchBalance) GetEscrowed() string {
	if m != nil {
		return m.Escrowed
	}
	return ""
}

// BatchSupply stores the supply of credits for a credit batch.
type BatchSupply struct {
	// batch_key is the table row identifier of the credit batch used internally
	// for efficient lookups. This links a batch supply to a credit batch.
	BatchKey uint64 `protobuf:"varint,1,opt,name=batch_key,json=batchKey,proto3" json:"batch_key,omitempty"`
	// tradable_amount is the total number of tradable credits in the credit
	// batch. Some of the issued credits may be cancelled and will be removed from
	// tradable_amount and tracked in amount_cancelled. tradable_amount +
	// retired_amount + amount_cancelled will always sum to the original credit
	// issuance amount.
	TradableAmount string `protobuf:"bytes,2,opt,name=tradable_amount,json=tradableAmount,proto3" json:"tradable_amount,omitempty"`
	// retired_amount is the total amount of credits that have been retired from
	// the credit batch.
	RetiredAmount string `protobuf:"bytes,3,opt,name=retired_amount,json=retiredAmount,proto3" json:"retired_amount,omitempty"`
	// cancelled_amount is the number of credits in the batch that have been
	// cancelled, effectively undoing the issuance. The sum of total_amount and
	// amount_cancelled will always equal the original credit issuance amount.
	CancelledAmount string `protobuf:"bytes,4,opt,name=cancelled_amount,json=cancelledAmount,proto3" json:"cancelled_amount,omitempty"`
}

func (m *BatchSupply) Reset()         { *m = BatchSupply{} }
func (m *BatchSupply) String() string { return proto.CompactTextString(m) }
func (*BatchSupply) ProtoMessage()    {}
func (*BatchSupply) Descriptor() ([]byte, []int) {
	return fileDescriptor_6cfdca0a4aaabb36, []int{9}
}
func (m *BatchSupply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchSupply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchSupply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchSupply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchSupply.Merge(m, src)
}
func (m *BatchSupply) XXX_Size() int {
	return m.Size()
}
func (m *BatchSupply) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchSupply.DiscardUnknown(m)
}

var xxx_messageInfo_BatchSupply proto.InternalMessageInfo

func (m *BatchSupply) GetBatchKey() uint64 {
	if m != nil {
		return m.BatchKey
	}
	return 0
}

func (m *BatchSupply) GetTradableAmount() string {
	if m != nil {
		return m.TradableAmount
	}
	return ""
}

func (m *BatchSupply) GetRetiredAmount() string {
	if m != nil {
		return m.RetiredAmount
	}
	return ""
}

func (m *BatchSupply) GetCancelledAmount() string {
	if m != nil {
		return m.CancelledAmount
	}
	return ""
}

// BatchOrigTx will index batch mint operations using orig tx ID to handle
// potential double minting errors
type BatchOrigTx struct {
	// the id of an originating transaction or opeartion.
	TxId string `protobuf:"bytes,1,opt,name=tx_id,json=txId,proto3" json:"tx_id,omitempty"`
	// type of the transaction originating the mint process. Eg: Polygon,
	// Ethereum, Verra...
	Typ string `protobuf:"bytes,2,opt,name=typ,proto3" json:"typ,omitempty"`
	// reference note for accounting, will be passed to an event
	Note string `protobuf:"bytes,3,opt,name=note,proto3" json:"note,omitempty"`
	// batch_denom is the unique ID of the credit batch.
	BatchDenom string `protobuf:"bytes,4,opt,name=batch_denom,json=batchDenom,proto3" json:"batch_denom,omitempty"`
}

func (m *BatchOrigTx) Reset()         { *m = BatchOrigTx{} }
func (m *BatchOrigTx) String() string { return proto.CompactTextString(m) }
func (*BatchOrigTx) ProtoMessage()    {}
func (*BatchOrigTx) Descriptor() ([]byte, []int) {
	return fileDescriptor_6cfdca0a4aaabb36, []int{10}
}
func (m *BatchOrigTx) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchOrigTx) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchOrigTx.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchOrigTx) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchOrigTx.Merge(m, src)
}
func (m *BatchOrigTx) XXX_Size() int {
	return m.Size()
}
func (m *BatchOrigTx) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchOrigTx.DiscardUnknown(m)
}

var xxx_messageInfo_BatchOrigTx proto.InternalMessageInfo

func (m *BatchOrigTx) GetTxId() string {
	if m != nil {
		return m.TxId
	}
	return ""
}

func (m *BatchOrigTx) GetTyp() string {
	if m != nil {
		return m.Typ
	}
	return ""
}

func (m *BatchOrigTx) GetNote() string {
	if m != nil {
		return m.Note
	}
	return ""
}

func (m *BatchOrigTx) GetBatchDenom() string {
	if m != nil {
		return m.BatchDenom
	}
	return ""
}

func init() {
	proto.RegisterType((*CreditType)(nil), "regen.ecocredit.v1.CreditType")
	proto.RegisterType((*ClassInfo)(nil), "regen.ecocredit.v1.ClassInfo")
	proto.RegisterType((*ClassIssuer)(nil), "regen.ecocredit.v1.ClassIssuer")
	proto.RegisterType((*ProjectInfo)(nil), "regen.ecocredit.v1.ProjectInfo")
	proto.RegisterType((*BatchInfo)(nil), "regen.ecocredit.v1.BatchInfo")
	proto.RegisterType((*ClassSequence)(nil), "regen.ecocredit.v1.ClassSequence")
	proto.RegisterType((*ProjectSequence)(nil), "regen.ecocredit.v1.ProjectSequence")
	proto.RegisterType((*BatchSequence)(nil), "regen.ecocredit.v1.BatchSequence")
	proto.RegisterType((*BatchBalance)(nil), "regen.ecocredit.v1.BatchBalance")
	proto.RegisterType((*BatchSupply)(nil), "regen.ecocredit.v1.BatchSupply")
	proto.RegisterType((*BatchOrigTx)(nil), "regen.ecocredit.v1.BatchOrigTx")
}

func init() { proto.RegisterFile("regen/ecocredit/v1/state.proto", fileDescriptor_6cfdca0a4aaabb36) }

var fileDescriptor_6cfdca0a4aaabb36 = []byte{
	// 973 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0xdd, 0x6e, 0x1b, 0x45,
	0x14, 0xce, 0xda, 0x4e, 0xec, 0x3d, 0xb6, 0xe3, 0xcd, 0xb4, 0x0d, 0xab, 0x50, 0x9c, 0x68, 0x01,
	0x91, 0x4a, 0xc1, 0x56, 0xa0, 0x20, 0xf0, 0x05, 0xa8, 0x69, 0x6f, 0xaa, 0x22, 0x51, 0x4c, 0xae,
	0xb8, 0x31, 0xe3, 0xdd, 0x53, 0x67, 0xdb, 0xdd, 0x9d, 0x65, 0x77, 0x9c, 0xda, 0x12, 0x57, 0x3c,
	0x00, 0xe2, 0x01, 0x10, 0x6f, 0xc0, 0x1b, 0xf0, 0x00, 0xdc, 0x20, 0x55, 0xe2, 0x86, 0x4b, 0x94,
	0x88, 0x17, 0xe0, 0x09, 0xd0, 0x9c, 0x99, 0x5d, 0xdb, 0x21, 0x69, 0x2a, 0xf5, 0x6e, 0xce, 0xb7,
	0xe7, 0xe7, 0xfb, 0xce, 0x9c, 0x33, 0x36, 0x74, 0x33, 0x9c, 0x60, 0xd2, 0x47, 0x5f, 0xf8, 0x19,
	0x06, 0xa1, 0xec, 0x9f, 0x1e, 0xf6, 0x73, 0xc9, 0x25, 0xf6, 0xd2, 0x4c, 0x48, 0xc1, 0x18, 0x7d,
	0xef, 0x95, 0xdf, 0x7b, 0xa7, 0x87, 0x3b, 0x6f, 0xf9, 0x22, 0x8f, 0x45, 0xde, 0x17, 0x59, 0xdc,
	0x3f, 0x3d, 0xe4, 0x51, 0x7a, 0xc2, 0x0f, 0x95, 0xa1, 0x43, 0x76, 0x76, 0x27, 0x42, 0x4c, 0x22,
	0xec, 0x93, 0x35, 0x9e, 0x3e, 0xe9, 0xcb, 0x30, 0xc6, 0x5c, 0xf2, 0x38, 0xd5, 0x0e, 0xde, 0xcf,
	0x16, 0xc0, 0x7d, 0xca, 0x76, 0x3c, 0x4f, 0x91, 0x79, 0xd0, 0xe2, 0xe3, 0x71, 0x86, 0xa7, 0x21,
	0x97, 0xa1, 0x48, 0x5c, 0x6b, 0xcf, 0xda, 0xb7, 0x87, 0x2b, 0x18, 0x63, 0x50, 0x4b, 0x78, 0x8c,
	0x6e, 0x85, 0xbe, 0xd1, 0x59, 0x61, 0xd3, 0x24, 0x94, 0x6e, 0x55, 0x63, 0xea, 0xcc, 0x6e, 0x83,
	0x9d, 0x66, 0xe8, 0x87, 0xb9, 0x4a, 0x54, 0xdb, 0xb3, 0xf6, 0xdb, 0xc3, 0x05, 0x30, 0x78, 0xe7,
	0xdf, 0x5f, 0xfe, 0xfc, 0xb1, 0xda, 0x85, 0xcd, 0xd5, 0x8a, 0x0c, 0x74, 0x76, 0xc7, 0x72, 0x2d,
	0xd7, 0xf2, 0xfe, 0xb0, 0xc0, 0xbe, 0x1f, 0xf1, 0x3c, 0x7f, 0x98, 0x3c, 0x11, 0xcc, 0x81, 0xea,
	0x33, 0x9c, 0x13, 0xa9, 0xda, 0x50, 0x1d, 0xd9, 0x26, 0x54, 0xc2, 0xc0, 0x30, 0xa9, 0x84, 0x01,
	0xbb, 0x09, 0xeb, 0x3c, 0x88, 0xc3, 0x84, 0x88, 0xb4, 0x86, 0xda, 0x60, 0x3b, 0xd0, 0x88, 0x51,
	0xf2, 0x80, 0x4b, 0x4e, 0x44, 0xec, 0x61, 0x69, 0xb3, 0x03, 0x60, 0xba, 0x9b, 0x23, 0x39, 0x4f,
	0x71, 0xa4, 0xb9, 0xb8, 0xeb, 0xe4, 0xe5, 0xf8, 0x65, 0x67, 0xee, 0x11, 0x3e, 0xf8, 0x8c, 0x58,
	0x7f, 0x02, 0x75, 0x62, 0xe2, 0x58, 0xac, 0xa1, 0x08, 0x28, 0xb2, 0xcc, 0x36, 0xa5, 0x9d, 0x0a,
	0xdb, 0xbe, 0x2c, 0xa7, 0x53, 0x75, 0x2b, 0xde, 0xb7, 0xd0, 0xd4, 0x72, 0xf2, 0x7c, 0x8a, 0x19,
	0x7b, 0x13, 0x6c, 0x5f, 0x99, 0xa3, 0x85, 0xac, 0x06, 0x01, 0x8f, 0x70, 0xce, 0xb6, 0x61, 0x23,
	0x24, 0x37, 0xd2, 0xd7, 0x1a, 0x1a, 0x6b, 0x70, 0x9b, 0x38, 0x6c, 0x03, 0x03, 0xa7, 0x0c, 0x3e,
	0x30, 0x9e, 0x55, 0xef, 0x1f, 0x0b, 0x9a, 0x8f, 0x33, 0xf1, 0x14, 0x7d, 0xf9, 0x5a, 0x3d, 0x5b,
	0xa1, 0x56, 0xbb, 0x40, 0xed, 0x0e, 0x38, 0xa9, 0xae, 0x31, 0x8a, 0x84, 0xaf, 0x47, 0x45, 0xb7,
	0xac, 0x63, 0xf0, 0x2f, 0x0c, 0xbc, 0xd2, 0xfb, 0x8d, 0xd5, 0xde, 0x0f, 0x06, 0xa4, 0xe4, 0xee,
	0x65, 0xdd, 0x64, 0xd0, 0x5a, 0x12, 0x17, 0x38, 0x95, 0xe5, 0x0e, 0x57, 0xdd, 0x9a, 0xf7, 0x6b,
	0x15, 0xec, 0x23, 0x2e, 0xfd, 0x93, 0x2b, 0x54, 0x5e, 0xd1, 0x3d, 0xb6, 0x0b, 0xcd, 0x82, 0xba,
	0x8a, 0xa8, 0x52, 0x04, 0x18, 0x48, 0x69, 0xdb, 0x85, 0xe6, 0x58, 0xe5, 0x1d, 0x05, 0x98, 0x88,
	0xd8, 0xcc, 0x0b, 0x10, 0xf4, 0x40, 0x21, 0x2b, 0x8a, 0xd6, 0x2f, 0x4c, 0xd3, 0xa7, 0x00, 0xb9,
	0xe4, 0x99, 0x1c, 0x05, 0x5c, 0x22, 0xe9, 0x6d, 0x7e, 0xb0, 0xd3, 0xd3, 0x4b, 0xd8, 0x2b, 0x96,
	0xb0, 0x77, 0x5c, 0x2c, 0xe1, 0xd0, 0x26, 0xef, 0x07, 0x5c, 0x22, 0xfb, 0x08, 0x1a, 0x98, 0x04,
	0x3a, 0xb0, 0x7e, 0x6d, 0x60, 0x1d, 0x93, 0x80, 0xc2, 0x3e, 0x87, 0xb6, 0x52, 0xc6, 0x13, 0x1f,
	0x75, 0x6c, 0xe3, 0xda, 0xd8, 0x56, 0x11, 0x40, 0x09, 0x18, 0xd4, 0x44, 0x8a, 0x89, 0x6b, 0xef,
	0x59, 0xfb, 0x8d, 0x21, 0x9d, 0x07, 0x5f, 0xd1, 0xc5, 0x3c, 0x5a, 0x5c, 0xcc, 0xd6, 0x4a, 0x53,
	0xe8, 0x86, 0x3a, 0x2b, 0x8d, 0x74, 0x2a, 0x6c, 0x73, 0x59, 0xbb, 0x53, 0x65, 0x50, 0xdc, 0x80,
	0x53, 0x73, 0xd7, 0xbd, 0x1f, 0x2c, 0x68, 0xd3, 0xe8, 0x7f, 0x8d, 0xdf, 0x4d, 0x31, 0xf1, 0xf1,
	0x8a, 0xcd, 0xb3, 0x2e, 0xdf, 0x3c, 0xf6, 0x36, 0xb4, 0x13, 0x9c, 0xc9, 0x51, 0x6e, 0xc2, 0xe9,
	0x5a, 0x6b, 0xc3, 0x96, 0x02, 0x8b, 0x94, 0x83, 0x2e, 0xf1, 0x76, 0xe1, 0xe6, 0xa5, 0xa9, 0x37,
	0xbc, 0xa7, 0xd0, 0x31, 0xbb, 0x51, 0xb2, 0x78, 0xe9, 0x0a, 0xbe, 0x52, 0xd1, 0x5b, 0x54, 0xb4,
	0x03, 0xcd, 0xe5, 0x4c, 0x75, 0x2f, 0x81, 0x36, 0xcd, 0x67, 0x59, 0xe9, 0xc2, 0xe4, 0x59, 0xff,
	0x9b, 0xbc, 0x57, 0xaa, 0xf6, 0x06, 0x55, 0xdb, 0x82, 0xf6, 0x6a, 0xb6, 0x86, 0x7a, 0x2a, 0x5b,
	0x54, 0xf0, 0x88, 0x47, 0xdc, 0x28, 0xd3, 0x77, 0xb6, 0xa4, 0x8c, 0x00, 0x55, 0xcb, 0x85, 0x3a,
	0x0f, 0x82, 0x0c, 0xf3, 0xdc, 0xec, 0x47, 0x61, 0xaa, 0xf1, 0x96, 0x19, 0x0f, 0xf8, 0x38, 0x42,
	0xf3, 0x9c, 0x97, 0xb6, 0x8a, 0xca, 0x50, 0x86, 0x19, 0x06, 0x66, 0x2f, 0x0a, 0x53, 0x45, 0x61,
	0xee, 0x67, 0xe2, 0x39, 0x06, 0xc5, 0x52, 0x14, 0xf6, 0xe0, 0x2e, 0x51, 0xee, 0xc1, 0x0d, 0xd8,
	0x32, 0x45, 0x0e, 0x4a, 0x62, 0xec, 0x16, 0x6c, 0x95, 0xc6, 0x81, 0xf9, 0xec, 0x58, 0xae, 0xed,
	0xfd, 0x66, 0x41, 0x53, 0x37, 0x70, 0x9a, 0xa6, 0xd1, 0xfc, 0xe5, 0x72, 0xde, 0x83, 0x4e, 0x41,
	0x72, 0xc4, 0x63, 0x31, 0x4d, 0xa4, 0x79, 0xe0, 0x36, 0x0b, 0xf8, 0x1e, 0xa1, 0xec, 0x5d, 0xd8,
	0x34, 0x94, 0x0b, 0x3f, 0xad, 0xb1, 0x6d, 0x50, 0xe3, 0x76, 0x07, 0x1c, 0x5f, 0x35, 0x31, 0x8a,
	0x16, 0x8e, 0x5a, 0x71, 0xa7, 0xc4, 0xb5, 0xeb, 0xf2, 0xf5, 0x2f, 0xf8, 0x81, 0xf7, 0xbd, 0x61,
	0xff, 0x65, 0x16, 0x4e, 0x8e, 0x67, 0xec, 0x06, 0xac, 0xcb, 0xd9, 0x28, 0x0c, 0xcc, 0x7c, 0xd7,
	0xe4, 0xec, 0x61, 0xa0, 0x5e, 0x2d, 0x39, 0x4f, 0x0d, 0x53, 0x75, 0xa4, 0xdf, 0x56, 0x21, 0x8b,
	0xc6, 0xd3, 0xf9, 0xda, 0x07, 0x69, 0xb0, 0x45, 0x0c, 0x9a, 0x50, 0x2f, 0x6a, 0x34, 0x8f, 0x1e,
	0xff, 0x7e, 0xd6, 0xb5, 0x5e, 0x9c, 0x75, 0xad, 0xbf, 0xcf, 0xba, 0xd6, 0x4f, 0xe7, 0xdd, 0xb5,
	0x17, 0xe7, 0xdd, 0xb5, 0xbf, 0xce, 0xbb, 0x6b, 0xdf, 0x7c, 0x3c, 0x09, 0xe5, 0xc9, 0x74, 0xdc,
	0xf3, 0x45, 0xdc, 0xa7, 0xff, 0x13, 0xef, 0x27, 0x28, 0x9f, 0x8b, 0xec, 0x99, 0xb1, 0x22, 0x0c,
	0x26, 0x98, 0xf5, 0x67, 0x4b, 0x7f, 0x43, 0x7c, 0x91, 0xe1, 0x78, 0x83, 0x1e, 0x92, 0x0f, 0xff,
	0x0b, 0x00, 0x00, 0xff, 0xff, 0x11, 0x7f, 0x71, 0xfa, 0xa5, 0x08, 0x00, 0x00,
}

func (m *CreditType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreditType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreditType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Precision != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.Precision))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Unit) > 0 {
		i -= len(m.Unit)
		copy(dAtA[i:], m.Unit)
		i = encodeVarintState(dAtA, i, uint64(len(m.Unit)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintState(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Abbreviation) > 0 {
		i -= len(m.Abbreviation)
		copy(dAtA[i:], m.Abbreviation)
		i = encodeVarintState(dAtA, i, uint64(len(m.Abbreviation)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClassInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClassInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClassInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CreditTypeAbbrev) > 0 {
		i -= len(m.CreditTypeAbbrev)
		copy(dAtA[i:], m.CreditTypeAbbrev)
		i = encodeVarintState(dAtA, i, uint64(len(m.CreditTypeAbbrev)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Metadata) > 0 {
		i -= len(m.Metadata)
		copy(dAtA[i:], m.Metadata)
		i = encodeVarintState(dAtA, i, uint64(len(m.Metadata)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Admin) > 0 {
		i -= len(m.Admin)
		copy(dAtA[i:], m.Admin)
		i = encodeVarintState(dAtA, i, uint64(len(m.Admin)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintState(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x12
	}
	if m.Key != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.Key))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ClassIssuer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClassIssuer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClassIssuer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Issuer) > 0 {
		i -= len(m.Issuer)
		copy(dAtA[i:], m.Issuer)
		i = encodeVarintState(dAtA, i, uint64(len(m.Issuer)))
		i--
		dAtA[i] = 0x12
	}
	if m.ClassKey != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.ClassKey))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ProjectInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProjectInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProjectInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Metadata) > 0 {
		i -= len(m.Metadata)
		copy(dAtA[i:], m.Metadata)
		i = encodeVarintState(dAtA, i, uint64(len(m.Metadata)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ProjectLocation) > 0 {
		i -= len(m.ProjectLocation)
		copy(dAtA[i:], m.ProjectLocation)
		i = encodeVarintState(dAtA, i, uint64(len(m.ProjectLocation)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ClassKey != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.ClassKey))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Admin) > 0 {
		i -= len(m.Admin)
		copy(dAtA[i:], m.Admin)
		i = encodeVarintState(dAtA, i, uint64(len(m.Admin)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintState(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x12
	}
	if m.Key != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.Key))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BatchInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Open {
		i--
		if m.Open {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.IssuanceDate != nil {
		{
			size, err := m.IssuanceDate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintState(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.EndDate != nil {
		{
			size, err := m.EndDate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintState(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.StartDate != nil {
		{
			size, err := m.StartDate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintState(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Metadata) > 0 {
		i -= len(m.Metadata)
		copy(dAtA[i:], m.Metadata)
		i = encodeVarintState(dAtA, i, uint64(len(m.Metadata)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.BatchDenom) > 0 {
		i -= len(m.BatchDenom)
		copy(dAtA[i:], m.BatchDenom)
		i = encodeVarintState(dAtA, i, uint64(len(m.BatchDenom)))
		i--
		dAtA[i] = 0x22
	}
	if m.ProjectKey != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.ProjectKey))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Issuer) > 0 {
		i -= len(m.Issuer)
		copy(dAtA[i:], m.Issuer)
		i = encodeVarintState(dAtA, i, uint64(len(m.Issuer)))
		i--
		dAtA[i] = 0x12
	}
	if m.Key != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.Key))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ClassSequence) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClassSequence) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClassSequence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NextSequence != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.NextSequence))
		i--
		dAtA[i] = 0x10
	}
	if len(m.CreditTypeAbbrev) > 0 {
		i -= len(m.CreditTypeAbbrev)
		copy(dAtA[i:], m.CreditTypeAbbrev)
		i = encodeVarintState(dAtA, i, uint64(len(m.CreditTypeAbbrev)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProjectSequence) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProjectSequence) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProjectSequence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NextSequence != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.NextSequence))
		i--
		dAtA[i] = 0x10
	}
	if m.ClassKey != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.ClassKey))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BatchSequence) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchSequence) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchSequence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NextSequence != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.NextSequence))
		i--
		dAtA[i] = 0x10
	}
	if m.ProjectKey != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.ProjectKey))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BatchBalance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchBalance) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchBalance) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Escrowed) > 0 {
		i -= len(m.Escrowed)
		copy(dAtA[i:], m.Escrowed)
		i = encodeVarintState(dAtA, i, uint64(len(m.Escrowed)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Retired) > 0 {
		i -= len(m.Retired)
		copy(dAtA[i:], m.Retired)
		i = encodeVarintState(dAtA, i, uint64(len(m.Retired)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Tradable) > 0 {
		i -= len(m.Tradable)
		copy(dAtA[i:], m.Tradable)
		i = encodeVarintState(dAtA, i, uint64(len(m.Tradable)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintState(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x12
	}
	if m.BatchKey != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.BatchKey))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BatchSupply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchSupply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchSupply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CancelledAmount) > 0 {
		i -= len(m.CancelledAmount)
		copy(dAtA[i:], m.CancelledAmount)
		i = encodeVarintState(dAtA, i, uint64(len(m.CancelledAmount)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.RetiredAmount) > 0 {
		i -= len(m.RetiredAmount)
		copy(dAtA[i:], m.RetiredAmount)
		i = encodeVarintState(dAtA, i, uint64(len(m.RetiredAmount)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TradableAmount) > 0 {
		i -= len(m.TradableAmount)
		copy(dAtA[i:], m.TradableAmount)
		i = encodeVarintState(dAtA, i, uint64(len(m.TradableAmount)))
		i--
		dAtA[i] = 0x12
	}
	if m.BatchKey != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.BatchKey))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BatchOrigTx) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchOrigTx) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchOrigTx) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BatchDenom) > 0 {
		i -= len(m.BatchDenom)
		copy(dAtA[i:], m.BatchDenom)
		i = encodeVarintState(dAtA, i, uint64(len(m.BatchDenom)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Note) > 0 {
		i -= len(m.Note)
		copy(dAtA[i:], m.Note)
		i = encodeVarintState(dAtA, i, uint64(len(m.Note)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Typ) > 0 {
		i -= len(m.Typ)
		copy(dAtA[i:], m.Typ)
		i = encodeVarintState(dAtA, i, uint64(len(m.Typ)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TxId) > 0 {
		i -= len(m.TxId)
		copy(dAtA[i:], m.TxId)
		i = encodeVarintState(dAtA, i, uint64(len(m.TxId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintState(dAtA []byte, offset int, v uint64) int {
	offset -= sovState(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CreditType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Abbreviation)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.Unit)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if m.Precision != 0 {
		n += 1 + sovState(uint64(m.Precision))
	}
	return n
}

func (m *ClassInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != 0 {
		n += 1 + sovState(uint64(m.Key))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.CreditTypeAbbrev)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	return n
}

func (m *ClassIssuer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClassKey != 0 {
		n += 1 + sovState(uint64(m.ClassKey))
	}
	l = len(m.Issuer)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	return n
}

func (m *ProjectInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != 0 {
		n += 1 + sovState(uint64(m.Key))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if m.ClassKey != 0 {
		n += 1 + sovState(uint64(m.ClassKey))
	}
	l = len(m.ProjectLocation)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	return n
}

func (m *BatchInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != 0 {
		n += 1 + sovState(uint64(m.Key))
	}
	l = len(m.Issuer)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if m.ProjectKey != 0 {
		n += 1 + sovState(uint64(m.ProjectKey))
	}
	l = len(m.BatchDenom)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if m.StartDate != nil {
		l = m.StartDate.Size()
		n += 1 + l + sovState(uint64(l))
	}
	if m.EndDate != nil {
		l = m.EndDate.Size()
		n += 1 + l + sovState(uint64(l))
	}
	if m.IssuanceDate != nil {
		l = m.IssuanceDate.Size()
		n += 1 + l + sovState(uint64(l))
	}
	if m.Open {
		n += 2
	}
	return n
}

func (m *ClassSequence) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CreditTypeAbbrev)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if m.NextSequence != 0 {
		n += 1 + sovState(uint64(m.NextSequence))
	}
	return n
}

func (m *ProjectSequence) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClassKey != 0 {
		n += 1 + sovState(uint64(m.ClassKey))
	}
	if m.NextSequence != 0 {
		n += 1 + sovState(uint64(m.NextSequence))
	}
	return n
}

func (m *BatchSequence) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProjectKey != 0 {
		n += 1 + sovState(uint64(m.ProjectKey))
	}
	if m.NextSequence != 0 {
		n += 1 + sovState(uint64(m.NextSequence))
	}
	return n
}

func (m *BatchBalance) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchKey != 0 {
		n += 1 + sovState(uint64(m.BatchKey))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.Tradable)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.Retired)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.Escrowed)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	return n
}

func (m *BatchSupply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchKey != 0 {
		n += 1 + sovState(uint64(m.BatchKey))
	}
	l = len(m.TradableAmount)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.RetiredAmount)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.CancelledAmount)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	return n
}

func (m *BatchOrigTx) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TxId)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.Typ)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.Note)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.BatchDenom)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	return n
}

func sovState(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozState(x uint64) (n int) {
	return sovState(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CreditType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreditType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreditType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Abbreviation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Abbreviation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Unit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Precision", wireType)
			}
			m.Precision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Precision |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClassInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClassInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClassInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = append(m.Admin[:0], dAtA[iNdEx:postIndex]...)
			if m.Admin == nil {
				m.Admin = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreditTypeAbbrev", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreditTypeAbbrev = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClassIssuer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClassIssuer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClassIssuer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassKey", wireType)
			}
			m.ClassKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClassKey |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issuer", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Issuer = append(m.Issuer[:0], dAtA[iNdEx:postIndex]...)
			if m.Issuer == nil {
				m.Issuer = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProjectInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProjectInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProjectInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = append(m.Admin[:0], dAtA[iNdEx:postIndex]...)
			if m.Admin == nil {
				m.Admin = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassKey", wireType)
			}
			m.ClassKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClassKey |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectLocation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectLocation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issuer", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Issuer = append(m.Issuer[:0], dAtA[iNdEx:postIndex]...)
			if m.Issuer == nil {
				m.Issuer = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectKey", wireType)
			}
			m.ProjectKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProjectKey |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartDate == nil {
				m.StartDate = &types.Timestamp{}
			}
			if err := m.StartDate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndDate == nil {
				m.EndDate = &types.Timestamp{}
			}
			if err := m.EndDate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IssuanceDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IssuanceDate == nil {
				m.IssuanceDate = &types.Timestamp{}
			}
			if err := m.IssuanceDate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Open", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Open = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClassSequence) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClassSequence: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClassSequence: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreditTypeAbbrev", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreditTypeAbbrev = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextSequence", wireType)
			}
			m.NextSequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextSequence |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProjectSequence) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProjectSequence: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProjectSequence: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassKey", wireType)
			}
			m.ClassKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClassKey |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextSequence", wireType)
			}
			m.NextSequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextSequence |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchSequence) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchSequence: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchSequence: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectKey", wireType)
			}
			m.ProjectKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProjectKey |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextSequence", wireType)
			}
			m.NextSequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextSequence |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchBalance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchBalance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchBalance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchKey", wireType)
			}
			m.BatchKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchKey |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = append(m.Address[:0], dAtA[iNdEx:postIndex]...)
			if m.Address == nil {
				m.Address = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tradable", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tradable = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Retired", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Retired = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Escrowed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Escrowed = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchSupply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchSupply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchSupply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchKey", wireType)
			}
			m.BatchKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchKey |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradableAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TradableAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetiredAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetiredAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CancelledAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CancelledAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchOrigTx) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchOrigTx: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchOrigTx: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Typ", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Typ = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Note", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Note = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipState(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowState
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowState
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowState
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthState
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupState
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthState
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthState        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowState          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupState = fmt.Errorf("proto: unexpected end of group")
)
