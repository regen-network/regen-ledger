// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: regen/ecocredit/v1/state.proto

package core

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-sdk/api/cosmos/orm/v1alpha1"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// CreditType defines the measurement unit/precision of a certain credit type
// (e.g. carbon, biodiversity...)
type CreditType struct {
	// abbreviation is a 1-3 character uppercase abbreviation of the CreditType
	// name, used in batch denominations within the CreditType. It must be unique.
	Abbreviation string `protobuf:"bytes,1,opt,name=abbreviation,proto3" json:"abbreviation,omitempty"`
	// name is the name of the credit type (e.g. carbon, biodiversity).
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// unit is the measurement unit of the credit type (e.g. kg, ton).
	Unit string `protobuf:"bytes,3,opt,name=unit,proto3" json:"unit,omitempty"`
	// precision is the decimal precision of the credit type.
	Precision uint32 `protobuf:"varint,4,opt,name=precision,proto3" json:"precision,omitempty"`
}

func (m *CreditType) Reset()         { *m = CreditType{} }
func (m *CreditType) String() string { return proto.CompactTextString(m) }
func (*CreditType) ProtoMessage()    {}
func (*CreditType) Descriptor() ([]byte, []int) {
	return fileDescriptor_6cfdca0a4aaabb36, []int{0}
}
func (m *CreditType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreditType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreditType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreditType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreditType.Merge(m, src)
}
func (m *CreditType) XXX_Size() int {
	return m.Size()
}
func (m *CreditType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreditType.DiscardUnknown(m)
}

var xxx_messageInfo_CreditType proto.InternalMessageInfo

func (m *CreditType) GetAbbreviation() string {
	if m != nil {
		return m.Abbreviation
	}
	return ""
}

func (m *CreditType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CreditType) GetUnit() string {
	if m != nil {
		return m.Unit
	}
	return ""
}

func (m *CreditType) GetPrecision() uint32 {
	if m != nil {
		return m.Precision
	}
	return 0
}

// Class represents the high-level on-chain information for a credit class.
type Class struct {
	// key is the table row identifier of the credit class used internally for
	// efficient lookups. This identifier is auto-incrementing.
	Key uint64 `protobuf:"varint,1,opt,name=key,proto3" json:"key,omitempty"`
	// id is the unique identifier of the credit class auto-generated from the
	// credit type abbreviation and the credit class sequence number.
	Id string `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	// admin is the admin of the credit class.
	Admin []byte `protobuf:"bytes,3,opt,name=admin,proto3" json:"admin,omitempty"`
	// metadata is any arbitrary metadata to attached to the credit class.
	Metadata string `protobuf:"bytes,4,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// credit_type_abbrev is the abbreviation of the credit type.
	CreditTypeAbbrev string `protobuf:"bytes,5,opt,name=credit_type_abbrev,json=creditTypeAbbrev,proto3" json:"credit_type_abbrev,omitempty"`
}

func (m *Class) Reset()         { *m = Class{} }
func (m *Class) String() string { return proto.CompactTextString(m) }
func (*Class) ProtoMessage()    {}
func (*Class) Descriptor() ([]byte, []int) {
	return fileDescriptor_6cfdca0a4aaabb36, []int{1}
}
func (m *Class) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Class) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Class.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Class) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Class.Merge(m, src)
}
func (m *Class) XXX_Size() int {
	return m.Size()
}
func (m *Class) XXX_DiscardUnknown() {
	xxx_messageInfo_Class.DiscardUnknown(m)
}

var xxx_messageInfo_Class proto.InternalMessageInfo

func (m *Class) GetKey() uint64 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *Class) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Class) GetAdmin() []byte {
	if m != nil {
		return m.Admin
	}
	return nil
}

func (m *Class) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

func (m *Class) GetCreditTypeAbbrev() string {
	if m != nil {
		return m.CreditTypeAbbrev
	}
	return ""
}

// ClassIssuers is a JOIN table for Class Info that stores the credit class
// issuers
type ClassIssuer struct {
	// class_key is the table row identifier of the credit class used internally
	// for efficient lookups. This links a class issuer to a credit class.
	ClassKey uint64 `protobuf:"varint,1,opt,name=class_key,json=classKey,proto3" json:"class_key,omitempty"`
	// issuer is the approved issuer of the credit class.
	Issuer []byte `protobuf:"bytes,2,opt,name=issuer,proto3" json:"issuer,omitempty"`
}

func (m *ClassIssuer) Reset()         { *m = ClassIssuer{} }
func (m *ClassIssuer) String() string { return proto.CompactTextString(m) }
func (*ClassIssuer) ProtoMessage()    {}
func (*ClassIssuer) Descriptor() ([]byte, []int) {
	return fileDescriptor_6cfdca0a4aaabb36, []int{2}
}
func (m *ClassIssuer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClassIssuer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClassIssuer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClassIssuer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClassIssuer.Merge(m, src)
}
func (m *ClassIssuer) XXX_Size() int {
	return m.Size()
}
func (m *ClassIssuer) XXX_DiscardUnknown() {
	xxx_messageInfo_ClassIssuer.DiscardUnknown(m)
}

var xxx_messageInfo_ClassIssuer proto.InternalMessageInfo

func (m *ClassIssuer) GetClassKey() uint64 {
	if m != nil {
		return m.ClassKey
	}
	return 0
}

func (m *ClassIssuer) GetIssuer() []byte {
	if m != nil {
		return m.Issuer
	}
	return nil
}

// Project represents the high-level on-chain information for a project.
type Project struct {
	// key is the table row identifier of the project used internally for
	// efficient lookups. This identifier is auto-incrementing.
	Key uint64 `protobuf:"varint,1,opt,name=key,proto3" json:"key,omitempty"`
	// id is the unique identifier of the project either auto-generated from the
	// credit class id and project sequence number or provided upon creation.
	Id string `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	// admin is the admin of the project.
	Admin []byte `protobuf:"bytes,3,opt,name=admin,proto3" json:"admin,omitempty"`
	// class_key is the table row identifier of the credit class used internally
	// for efficient lookups. This links a project to a credit class.
	ClassKey uint64 `protobuf:"varint,4,opt,name=class_key,json=classKey,proto3" json:"class_key,omitempty"`
	// jurisdiction is the jurisdiction of the project.
	// Full documentation can be found in MsgCreateProject.jurisdiction.
	Jurisdiction string `protobuf:"bytes,5,opt,name=jurisdiction,proto3" json:"jurisdiction,omitempty"`
	// metadata is any arbitrary metadata attached to the project.
	Metadata string `protobuf:"bytes,6,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// reference_id is any arbitrary string used to reference the project.
	ReferenceId string `protobuf:"bytes,7,opt,name=reference_id,json=referenceId,proto3" json:"reference_id,omitempty"`
}

func (m *Project) Reset()         { *m = Project{} }
func (m *Project) String() string { return proto.CompactTextString(m) }
func (*Project) ProtoMessage()    {}
func (*Project) Descriptor() ([]byte, []int) {
	return fileDescriptor_6cfdca0a4aaabb36, []int{3}
}
func (m *Project) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Project) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Project.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Project) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Project.Merge(m, src)
}
func (m *Project) XXX_Size() int {
	return m.Size()
}
func (m *Project) XXX_DiscardUnknown() {
	xxx_messageInfo_Project.DiscardUnknown(m)
}

var xxx_messageInfo_Project proto.InternalMessageInfo

func (m *Project) GetKey() uint64 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *Project) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Project) GetAdmin() []byte {
	if m != nil {
		return m.Admin
	}
	return nil
}

func (m *Project) GetClassKey() uint64 {
	if m != nil {
		return m.ClassKey
	}
	return 0
}

func (m *Project) GetJurisdiction() string {
	if m != nil {
		return m.Jurisdiction
	}
	return ""
}

func (m *Project) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

func (m *Project) GetReferenceId() string {
	if m != nil {
		return m.ReferenceId
	}
	return ""
}

// Batch represents the high-level on-chain information for a credit batch.
type Batch struct {
	// key is the table row identifier of the credit batch used internally for
	// efficient lookups. This identifier is auto-incrementing.
	Key uint64 `protobuf:"varint,1,opt,name=key,proto3" json:"key,omitempty"`
	// issuer is the address that created the batch and which is
	// authorized to mint more credits if open=true.
	Issuer []byte `protobuf:"bytes,2,opt,name=issuer,proto3" json:"issuer,omitempty"`
	// project_key is the table row identifier of the credit class used internally
	// for efficient lookups. This links a credit batch to a project.
	ProjectKey uint64 `protobuf:"varint,3,opt,name=project_key,json=projectKey,proto3" json:"project_key,omitempty"`
	// denom is the unique identifier of the credit batch formed from the
	// project id, the batch sequence number, and the start and end date of the
	// credit batch.
	Denom string `protobuf:"bytes,4,opt,name=denom,proto3" json:"denom,omitempty"`
	// metadata is any arbitrary metadata attached to the credit batch.
	Metadata string `protobuf:"bytes,5,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// start_date is the beginning of the period during which this credit batch
	// was quantified and verified.
	StartDate *types.Timestamp `protobuf:"bytes,6,opt,name=start_date,json=startDate,proto3" json:"start_date,omitempty"`
	// end_date is the end of the period during which this credit batch was
	// quantified and verified.
	EndDate *types.Timestamp `protobuf:"bytes,7,opt,name=end_date,json=endDate,proto3" json:"end_date,omitempty"`
	// issuance_date is the timestamp when the credit batch was issued.
	IssuanceDate *types.Timestamp `protobuf:"bytes,8,opt,name=issuance_date,json=issuanceDate,proto3" json:"issuance_date,omitempty"`
	// open tells if it's possible to mint new credits in the future.
	// Once `open` is set to false, it can't be toggled any more.
	Open bool `protobuf:"varint,9,opt,name=open,proto3" json:"open,omitempty"`
}

func (m *Batch) Reset()         { *m = Batch{} }
func (m *Batch) String() string { return proto.CompactTextString(m) }
func (*Batch) ProtoMessage()    {}
func (*Batch) Descriptor() ([]byte, []int) {
	return fileDescriptor_6cfdca0a4aaabb36, []int{4}
}
func (m *Batch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Batch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Batch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Batch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Batch.Merge(m, src)
}
func (m *Batch) XXX_Size() int {
	return m.Size()
}
func (m *Batch) XXX_DiscardUnknown() {
	xxx_messageInfo_Batch.DiscardUnknown(m)
}

var xxx_messageInfo_Batch proto.InternalMessageInfo

func (m *Batch) GetKey() uint64 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *Batch) GetIssuer() []byte {
	if m != nil {
		return m.Issuer
	}
	return nil
}

func (m *Batch) GetProjectKey() uint64 {
	if m != nil {
		return m.ProjectKey
	}
	return 0
}

func (m *Batch) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *Batch) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

func (m *Batch) GetStartDate() *types.Timestamp {
	if m != nil {
		return m.StartDate
	}
	return nil
}

func (m *Batch) GetEndDate() *types.Timestamp {
	if m != nil {
		return m.EndDate
	}
	return nil
}

func (m *Batch) GetIssuanceDate() *types.Timestamp {
	if m != nil {
		return m.IssuanceDate
	}
	return nil
}

func (m *Batch) GetOpen() bool {
	if m != nil {
		return m.Open
	}
	return false
}

// ClassSequence stores and increments the sequence number for credit classes
// within a credit type.
type ClassSequence struct {
	// credit_type_abbrev is the credit type abbreviation. This links a class
	// sequence to a credit type.
	CreditTypeAbbrev string `protobuf:"bytes,1,opt,name=credit_type_abbrev,json=creditTypeAbbrev,proto3" json:"credit_type_abbrev,omitempty"`
	// next_sequence is the next sequence number for a credit class within the
	// credit type. The sequence number is used to generate a class id.
	NextSequence uint64 `protobuf:"varint,2,opt,name=next_sequence,json=nextSequence,proto3" json:"next_sequence,omitempty"`
}

func (m *ClassSequence) Reset()         { *m = ClassSequence{} }
func (m *ClassSequence) String() string { return proto.CompactTextString(m) }
func (*ClassSequence) ProtoMessage()    {}
func (*ClassSequence) Descriptor() ([]byte, []int) {
	return fileDescriptor_6cfdca0a4aaabb36, []int{5}
}
func (m *ClassSequence) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClassSequence) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClassSequence.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClassSequence) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClassSequence.Merge(m, src)
}
func (m *ClassSequence) XXX_Size() int {
	return m.Size()
}
func (m *ClassSequence) XXX_DiscardUnknown() {
	xxx_messageInfo_ClassSequence.DiscardUnknown(m)
}

var xxx_messageInfo_ClassSequence proto.InternalMessageInfo

func (m *ClassSequence) GetCreditTypeAbbrev() string {
	if m != nil {
		return m.CreditTypeAbbrev
	}
	return ""
}

func (m *ClassSequence) GetNextSequence() uint64 {
	if m != nil {
		return m.NextSequence
	}
	return 0
}

// ProjectSequence stores and increments the sequence number for projects within
// a credit class.
type ProjectSequence struct {
	// class_key is the table row identifier of the credit class used internally
	// for efficient lookups. This links a project sequence to a credit class.
	ClassKey uint64 `protobuf:"varint,1,opt,name=class_key,json=classKey,proto3" json:"class_key,omitempty"`
	// next_sequence is the next sequence number for a project within the credit
	// class. The sequence number is used to generate a project id.
	NextSequence uint64 `protobuf:"varint,2,opt,name=next_sequence,json=nextSequence,proto3" json:"next_sequence,omitempty"`
}

func (m *ProjectSequence) Reset()         { *m = ProjectSequence{} }
func (m *ProjectSequence) String() string { return proto.CompactTextString(m) }
func (*ProjectSequence) ProtoMessage()    {}
func (*ProjectSequence) Descriptor() ([]byte, []int) {
	return fileDescriptor_6cfdca0a4aaabb36, []int{6}
}
func (m *ProjectSequence) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProjectSequence) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProjectSequence.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProjectSequence) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProjectSequence.Merge(m, src)
}
func (m *ProjectSequence) XXX_Size() int {
	return m.Size()
}
func (m *ProjectSequence) XXX_DiscardUnknown() {
	xxx_messageInfo_ProjectSequence.DiscardUnknown(m)
}

var xxx_messageInfo_ProjectSequence proto.InternalMessageInfo

func (m *ProjectSequence) GetClassKey() uint64 {
	if m != nil {
		return m.ClassKey
	}
	return 0
}

func (m *ProjectSequence) GetNextSequence() uint64 {
	if m != nil {
		return m.NextSequence
	}
	return 0
}

// BatchSequence stores and increments the sequence number for credit batches
// within a project.
type BatchSequence struct {
	// project_key is the table row identifier of the project used internally for
	// efficient lookups. This links a batch sequence to a project.
	ProjectKey uint64 `protobuf:"varint,1,opt,name=project_key,json=projectKey,proto3" json:"project_key,omitempty"`
	// next_sequence is the next sequence number for a credit batch within the
	// project. The sequence number is used to generate a batch denom.
	NextSequence uint64 `protobuf:"varint,2,opt,name=next_sequence,json=nextSequence,proto3" json:"next_sequence,omitempty"`
}

func (m *BatchSequence) Reset()         { *m = BatchSequence{} }
func (m *BatchSequence) String() string { return proto.CompactTextString(m) }
func (*BatchSequence) ProtoMessage()    {}
func (*BatchSequence) Descriptor() ([]byte, []int) {
	return fileDescriptor_6cfdca0a4aaabb36, []int{7}
}
func (m *BatchSequence) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchSequence) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchSequence.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchSequence) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchSequence.Merge(m, src)
}
func (m *BatchSequence) XXX_Size() int {
	return m.Size()
}
func (m *BatchSequence) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchSequence.DiscardUnknown(m)
}

var xxx_messageInfo_BatchSequence proto.InternalMessageInfo

func (m *BatchSequence) GetProjectKey() uint64 {
	if m != nil {
		return m.ProjectKey
	}
	return 0
}

func (m *BatchSequence) GetNextSequence() uint64 {
	if m != nil {
		return m.NextSequence
	}
	return 0
}

// BatchBalance stores each accounts credit balance.
type BatchBalance struct {
	// batch_key is the table row identifier of the credit batch used internally
	// for efficient lookups. This links a batch balance to a credit batch.
	BatchKey uint64 `protobuf:"varint,1,opt,name=batch_key,json=batchKey,proto3" json:"batch_key,omitempty"`
	// address is the address of the account that owns the credits.
	Address []byte `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	// tradable_amount is the total number of tradable credits owned by address.
	TradableAmount string `protobuf:"bytes,3,opt,name=tradable_amount,json=tradableAmount,proto3" json:"tradable_amount,omitempty"`
	// retired_amount is the total number of retired credits owned by address.
	RetiredAmount string `protobuf:"bytes,4,opt,name=retired_amount,json=retiredAmount,proto3" json:"retired_amount,omitempty"`
	// escrowed_amount is the total number of escrowed credits owned by address
	// and held in escrow by the marketplace. Credits are held in escrow when a
	// sell order is created and taken out of escrow when the sell order is either
	// cancelled, updated with a reduced quantity, or processed.
	EscrowedAmount string `protobuf:"bytes,5,opt,name=escrowed_amount,json=escrowedAmount,proto3" json:"escrowed_amount,omitempty"`
}

func (m *BatchBalance) Reset()         { *m = BatchBalance{} }
func (m *BatchBalance) String() string { return proto.CompactTextString(m) }
func (*BatchBalance) ProtoMessage()    {}
func (*BatchBalance) Descriptor() ([]byte, []int) {
	return fileDescriptor_6cfdca0a4aaabb36, []int{8}
}
func (m *BatchBalance) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchBalance) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchBalance.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchBalance) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchBalance.Merge(m, src)
}
func (m *BatchBalance) XXX_Size() int {
	return m.Size()
}
func (m *BatchBalance) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchBalance.DiscardUnknown(m)
}

var xxx_messageInfo_BatchBalance proto.InternalMessageInfo

func (m *BatchBalance) GetBatchKey() uint64 {
	if m != nil {
		return m.BatchKey
	}
	return 0
}

func (m *BatchBalance) GetAddress() []byte {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *BatchBalance) GetTradableAmount() string {
	if m != nil {
		return m.TradableAmount
	}
	return ""
}

func (m *BatchBalance) GetRetiredAmount() string {
	if m != nil {
		return m.RetiredAmount
	}
	return ""
}

func (m *BatchBalance) GetEscrowedAmount() string {
	if m != nil {
		return m.EscrowedAmount
	}
	return ""
}

// BatchSupply stores the supply of credits for a credit batch.
type BatchSupply struct {
	// batch_key is the table row identifier of the credit batch used internally
	// for efficient lookups. This links a batch supply to a credit batch.
	BatchKey uint64 `protobuf:"varint,1,opt,name=batch_key,json=batchKey,proto3" json:"batch_key,omitempty"`
	// tradable_amount is the total number of tradable credits in the credit
	// batch. Tradable credits may be retired in which case they will be removed
	// from tradable_amount and tracked in retired_amount. Tradable credits may
	// also be cancelled in which case they will be removed from tradable_amount
	// and tracked in cancelled_amount. The sum of the tradable, retired, and
	// cancelled amounts will always equal the original credit issuance amount.
	TradableAmount string `protobuf:"bytes,2,opt,name=tradable_amount,json=tradableAmount,proto3" json:"tradable_amount,omitempty"`
	// retired_amount is the total amount of credits that have been retired in the
	// credit batch. The sum of the tradable, retired, and cancelled amounts will
	// always equal the original credit issuance amount.
	RetiredAmount string `protobuf:"bytes,3,opt,name=retired_amount,json=retiredAmount,proto3" json:"retired_amount,omitempty"`
	// cancelled_amount is the number of credits in the batch that have been
	// cancelled, effectively undoing the issuance. The sum of the tradable,
	// retired, and cancelled amounts will always equal the original credit
	// issuance amount.
	CancelledAmount string `protobuf:"bytes,4,opt,name=cancelled_amount,json=cancelledAmount,proto3" json:"cancelled_amount,omitempty"`
}

func (m *BatchSupply) Reset()         { *m = BatchSupply{} }
func (m *BatchSupply) String() string { return proto.CompactTextString(m) }
func (*BatchSupply) ProtoMessage()    {}
func (*BatchSupply) Descriptor() ([]byte, []int) {
	return fileDescriptor_6cfdca0a4aaabb36, []int{9}
}
func (m *BatchSupply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchSupply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchSupply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchSupply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchSupply.Merge(m, src)
}
func (m *BatchSupply) XXX_Size() int {
	return m.Size()
}
func (m *BatchSupply) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchSupply.DiscardUnknown(m)
}

var xxx_messageInfo_BatchSupply proto.InternalMessageInfo

func (m *BatchSupply) GetBatchKey() uint64 {
	if m != nil {
		return m.BatchKey
	}
	return 0
}

func (m *BatchSupply) GetTradableAmount() string {
	if m != nil {
		return m.TradableAmount
	}
	return ""
}

func (m *BatchSupply) GetRetiredAmount() string {
	if m != nil {
		return m.RetiredAmount
	}
	return ""
}

func (m *BatchSupply) GetCancelledAmount() string {
	if m != nil {
		return m.CancelledAmount
	}
	return ""
}

// OriginTxIndex indexes the transaction ID and source from the OriginTx
// included in Msg/CreateBatch and Msg/MintBatchCredits to prevent double
// minting errors. The index is scoped to a credit class (it includes the
// class_key) to prevent malicious credit class issuers from blocking any
// bridge operations taking place within another credit class.
type OriginTxIndex struct {
	// class_key is the table row identifier of the credit class within which the
	// credits were issued or minted. The class_key is included within the index
	// to prevent malicious credit class issuers from blocking bridge operations
	// taking place within another credit class.
	ClassKey uint64 `protobuf:"varint,1,opt,name=class_key,json=classKey,proto3" json:"class_key,omitempty"`
	// id is the transaction ID of an originating transaction or operation
	// based on a type (i.e. transaction ID, serial number).
	Id string `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	// source is the source chain or registry of the transaction originating
	// the mint process (e.g. polygon, ethereum, verra).
	Source string `protobuf:"bytes,3,opt,name=source,proto3" json:"source,omitempty"`
}

func (m *OriginTxIndex) Reset()         { *m = OriginTxIndex{} }
func (m *OriginTxIndex) String() string { return proto.CompactTextString(m) }
func (*OriginTxIndex) ProtoMessage()    {}
func (*OriginTxIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_6cfdca0a4aaabb36, []int{10}
}
func (m *OriginTxIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OriginTxIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OriginTxIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OriginTxIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OriginTxIndex.Merge(m, src)
}
func (m *OriginTxIndex) XXX_Size() int {
	return m.Size()
}
func (m *OriginTxIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_OriginTxIndex.DiscardUnknown(m)
}

var xxx_messageInfo_OriginTxIndex proto.InternalMessageInfo

func (m *OriginTxIndex) GetClassKey() uint64 {
	if m != nil {
		return m.ClassKey
	}
	return 0
}

func (m *OriginTxIndex) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *OriginTxIndex) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func init() {
	proto.RegisterType((*CreditType)(nil), "regen.ecocredit.v1.CreditType")
	proto.RegisterType((*Class)(nil), "regen.ecocredit.v1.Class")
	proto.RegisterType((*ClassIssuer)(nil), "regen.ecocredit.v1.ClassIssuer")
	proto.RegisterType((*Project)(nil), "regen.ecocredit.v1.Project")
	proto.RegisterType((*Batch)(nil), "regen.ecocredit.v1.Batch")
	proto.RegisterType((*ClassSequence)(nil), "regen.ecocredit.v1.ClassSequence")
	proto.RegisterType((*ProjectSequence)(nil), "regen.ecocredit.v1.ProjectSequence")
	proto.RegisterType((*BatchSequence)(nil), "regen.ecocredit.v1.BatchSequence")
	proto.RegisterType((*BatchBalance)(nil), "regen.ecocredit.v1.BatchBalance")
	proto.RegisterType((*BatchSupply)(nil), "regen.ecocredit.v1.BatchSupply")
	proto.RegisterType((*OriginTxIndex)(nil), "regen.ecocredit.v1.OriginTxIndex")
}

func init() { proto.RegisterFile("regen/ecocredit/v1/state.proto", fileDescriptor_6cfdca0a4aaabb36) }

var fileDescriptor_6cfdca0a4aaabb36 = []byte{
	// 981 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0xcd, 0x6e, 0xe3, 0x54,
	0x14, 0x1e, 0xc7, 0x49, 0x93, 0x9c, 0xfc, 0xb9, 0x77, 0xda, 0x62, 0xc2, 0x90, 0x16, 0x03, 0x9a,
	0x22, 0x85, 0x44, 0xe5, 0x4f, 0x90, 0x05, 0x68, 0x3a, 0xb0, 0xa8, 0x66, 0xc1, 0x28, 0x74, 0xc5,
	0x26, 0xdc, 0xd8, 0x67, 0x52, 0x77, 0xe2, 0x1f, 0xae, 0xaf, 0x3b, 0xcd, 0x96, 0x07, 0x40, 0x2c,
	0x59, 0x20, 0x5e, 0x80, 0x57, 0xe0, 0x01, 0x60, 0x37, 0x12, 0x1b, 0x96, 0xa8, 0x7d, 0x03, 0xc4,
	0x03, 0x20, 0x1f, 0x5f, 0x3b, 0x71, 0xc8, 0x74, 0x2a, 0x76, 0xf7, 0x7c, 0xf7, 0xfc, 0x7c, 0xe7,
	0xbb, 0xe7, 0x38, 0x81, 0x9e, 0xc0, 0x19, 0xfa, 0x43, 0xb4, 0x03, 0x5b, 0xa0, 0xe3, 0xca, 0xe1,
	0xc5, 0xd1, 0x30, 0x92, 0x5c, 0xe2, 0x20, 0x14, 0x81, 0x0c, 0x18, 0xa3, 0xfb, 0x41, 0x7e, 0x3f,
	0xb8, 0x38, 0xea, 0xbe, 0x6e, 0x07, 0x91, 0x17, 0x44, 0xc3, 0x40, 0x78, 0xc3, 0x8b, 0x23, 0x3e,
	0x0f, 0xcf, 0xf8, 0x51, 0x62, 0xa4, 0x21, 0xdd, 0xfd, 0x59, 0x10, 0xcc, 0xe6, 0x38, 0x24, 0x6b,
	0x1a, 0x3f, 0x19, 0x4a, 0xd7, 0xc3, 0x48, 0x72, 0x2f, 0x4c, 0x1d, 0xac, 0x9f, 0x34, 0x80, 0x87,
	0x94, 0xed, 0x74, 0x11, 0x22, 0xb3, 0xa0, 0xc9, 0xa7, 0x53, 0x81, 0x17, 0x2e, 0x97, 0x6e, 0xe0,
	0x9b, 0xda, 0x81, 0x76, 0x58, 0x1f, 0x17, 0x30, 0xc6, 0xa0, 0xec, 0x73, 0x0f, 0xcd, 0x12, 0xdd,
	0xd1, 0x39, 0xc1, 0x62, 0xdf, 0x95, 0xa6, 0x9e, 0x62, 0xc9, 0x99, 0xdd, 0x83, 0x7a, 0x28, 0xd0,
	0x76, 0xa3, 0x24, 0x51, 0xf9, 0x40, 0x3b, 0x6c, 0x8d, 0x97, 0xc0, 0xe8, 0xad, 0xbf, 0x7f, 0xfe,
	0xe3, 0x7b, 0xbd, 0x07, 0xed, 0x62, 0x45, 0x06, 0x69, 0x76, 0x43, 0x33, 0x35, 0x53, 0xb3, 0x7e,
	0xd7, 0xa0, 0xf2, 0x70, 0xce, 0xa3, 0x88, 0x19, 0xa0, 0x3f, 0xc5, 0x05, 0x11, 0x2a, 0x8f, 0x93,
	0x23, 0x6b, 0x43, 0xc9, 0x75, 0x14, 0x8b, 0x92, 0xeb, 0xb0, 0x1d, 0xa8, 0x70, 0xc7, 0x73, 0x7d,
	0x22, 0xd1, 0x1c, 0xa7, 0x06, 0xeb, 0x42, 0xcd, 0x43, 0xc9, 0x1d, 0x2e, 0x39, 0x91, 0xa8, 0x8f,
	0x73, 0x9b, 0xf5, 0x81, 0xa5, 0x4a, 0x4e, 0xe4, 0x22, 0xc4, 0x49, 0xca, 0xc3, 0xac, 0x90, 0x97,
	0x61, 0xe7, 0xaa, 0x3c, 0x20, 0x7c, 0xf4, 0x29, 0x31, 0xfe, 0x18, 0xaa, 0xc4, 0xc4, 0xd0, 0x58,
	0x2d, 0x21, 0x90, 0x10, 0x65, 0x75, 0x55, 0xda, 0x28, 0xb1, 0xbd, 0x4d, 0x39, 0x0d, 0xdd, 0x2c,
	0x59, 0xdf, 0x40, 0x83, 0x5a, 0x39, 0x89, 0xa2, 0x18, 0x05, 0x7b, 0x0d, 0xea, 0x76, 0x62, 0x4e,
	0x96, 0x6d, 0xd5, 0x08, 0x78, 0x84, 0x0b, 0xb6, 0x07, 0x5b, 0x2e, 0xb9, 0x51, 0x7f, 0xcd, 0xb1,
	0xb2, 0x46, 0xf7, 0x88, 0xc3, 0x1e, 0x30, 0x30, 0xf2, 0xe0, 0xbe, 0xf2, 0xd4, 0xad, 0x5f, 0x4a,
	0x50, 0x7d, 0x2c, 0x82, 0x73, 0xb4, 0xe5, 0xff, 0xd6, 0xab, 0x40, 0xab, 0xbc, 0x46, 0xcb, 0x82,
	0xe6, 0x79, 0x2c, 0xdc, 0xc8, 0x71, 0x6d, 0x1a, 0x8f, 0x54, 0xaa, 0x02, 0x56, 0x10, 0x7c, 0x6b,
	0x4d, 0xf0, 0x37, 0xa0, 0x29, 0xf0, 0x09, 0x0a, 0xf4, 0x6d, 0x9c, 0xb8, 0x8e, 0x59, 0xa5, 0xfb,
	0x46, 0x8e, 0x9d, 0x38, 0xa3, 0x33, 0xea, 0x70, 0xba, 0x49, 0x65, 0x06, 0xcd, 0x95, 0xa6, 0x1d,
	0xa3, 0xb4, 0xaa, 0xbc, 0xce, 0x8c, 0x62, 0x72, 0xa3, 0xcc, 0xba, 0xb0, 0xb7, 0x0c, 0x28, 0xdc,
	0x55, 0xcc, 0xb2, 0xf5, 0xa3, 0x0e, 0x95, 0x63, 0x2e, 0xed, 0xb3, 0x0d, 0x5a, 0xbd, 0x40, 0x7f,
	0xb6, 0x0f, 0x8d, 0x30, 0x15, 0x98, 0xf4, 0xd1, 0x29, 0x02, 0x14, 0x94, 0x28, 0xb4, 0x03, 0x15,
	0x07, 0xfd, 0xc0, 0x53, 0xb3, 0x96, 0x1a, 0x05, 0x4d, 0x2a, 0x6b, 0x9a, 0x7c, 0x02, 0x10, 0x49,
	0x2e, 0xe4, 0xc4, 0xe1, 0x12, 0x49, 0xb1, 0xc6, 0x7b, 0xdd, 0x41, 0xba, 0xb7, 0x83, 0x6c, 0x6f,
	0x07, 0xa7, 0xd9, 0xde, 0x8e, 0xeb, 0xe4, 0xfd, 0x39, 0x97, 0xc8, 0x3e, 0x84, 0x1a, 0xfa, 0x4e,
	0x1a, 0x58, 0x7d, 0x69, 0x60, 0x15, 0x7d, 0x87, 0xc2, 0x3e, 0x83, 0x56, 0xd2, 0x0e, 0x4f, 0xb4,
	0xa0, 0xd8, 0xda, 0x4b, 0x63, 0x9b, 0x59, 0x00, 0x25, 0x60, 0x50, 0x0e, 0x42, 0xf4, 0xcd, 0xfa,
	0x81, 0x76, 0x58, 0x1b, 0xd3, 0x79, 0xf4, 0x88, 0xde, 0xed, 0x8b, 0xe5, 0xbb, 0x35, 0x94, 0x12,
	0xf4, 0x74, 0x9d, 0x82, 0x6e, 0x46, 0x89, 0xb5, 0x57, 0xbb, 0x36, 0x74, 0x06, 0x99, 0xe0, 0x46,
	0xd9, 0xac, 0x58, 0xdf, 0x69, 0xd0, 0xa2, 0x5d, 0xf9, 0x0a, 0xbf, 0x8d, 0x93, 0x37, 0x7b, 0xc1,
	0xaa, 0x6a, 0x9b, 0x57, 0x95, 0xbd, 0x09, 0x2d, 0x1f, 0x2f, 0xe5, 0x24, 0x52, 0xe1, 0xf4, 0x8a,
	0xe5, 0x71, 0x33, 0x01, 0xb3, 0x94, 0xa3, 0x1e, 0x31, 0x36, 0x61, 0x67, 0x63, 0xea, 0x2d, 0xeb,
	0x1c, 0x3a, 0x6a, 0x99, 0x72, 0x16, 0x37, 0xee, 0xec, 0xad, 0x8a, 0xee, 0x52, 0xd1, 0x0e, 0x34,
	0x56, 0x33, 0x55, 0x2d, 0x1f, 0x5a, 0x34, 0x8a, 0x79, 0xa5, 0xb5, 0x41, 0xd3, 0xfe, 0x33, 0x68,
	0xb7, 0xaa, 0xf6, 0x0a, 0x55, 0xdb, 0x86, 0x56, 0x31, 0x5b, 0xcd, 0xfa, 0x47, 0x83, 0x26, 0x15,
	0x3c, 0xe6, 0x73, 0xae, 0x3a, 0x9b, 0x26, 0xf6, 0x6a, 0x67, 0x04, 0x24, 0xb5, 0x4c, 0xa8, 0x72,
	0xc7, 0x11, 0x18, 0x45, 0x6a, 0x1d, 0x32, 0x93, 0xdd, 0x87, 0x8e, 0x14, 0xdc, 0xe1, 0xd3, 0x39,
	0x4e, 0xb8, 0x17, 0xc4, 0x7e, 0xf6, 0x13, 0xd0, 0xce, 0xe0, 0x07, 0x84, 0xb2, 0xb7, 0xa1, 0x2d,
	0x50, 0xba, 0x02, 0x9d, 0xcc, 0x2f, 0x5d, 0x90, 0x96, 0x42, 0x95, 0xdb, 0x7d, 0xe8, 0x60, 0x64,
	0x8b, 0xe0, 0xd9, 0xd2, 0x2f, 0xdd, 0x97, 0x76, 0x06, 0xa7, 0x8e, 0xa3, 0x0f, 0xa8, 0xb3, 0x01,
	0xdc, 0x85, 0x6d, 0xc5, 0xa5, 0x9f, 0xf3, 0x67, 0xbb, 0xb0, 0x9d, 0x1b, 0x7d, 0x75, 0x6d, 0x68,
	0x66, 0xdd, 0xfa, 0x55, 0x83, 0x46, 0xaa, 0x73, 0x1c, 0x86, 0xf3, 0xc5, 0xcd, 0x5d, 0x6f, 0xe8,
	0xad, 0x74, 0xcb, 0xde, 0xf4, 0x4d, 0xbd, 0xbd, 0x03, 0x86, 0x9d, 0x68, 0x3d, 0x9f, 0xaf, 0x8b,
	0xd0, 0xc9, 0x71, 0xd5, 0xdd, 0xca, 0x94, 0x2c, 0xf9, 0x81, 0x15, 0x43, 0xeb, 0x4b, 0xe1, 0xce,
	0x5c, 0xff, 0xf4, 0xf2, 0xc4, 0x77, 0xf0, 0xf2, 0xe6, 0x79, 0x5c, 0xff, 0xde, 0xef, 0xc1, 0x56,
	0x14, 0xc4, 0xc2, 0x46, 0x45, 0x4f, 0x59, 0xa3, 0x7d, 0x2a, 0xf6, 0x2a, 0xec, 0xc2, 0xdd, 0xd5,
	0xcf, 0x6b, 0x5f, 0x39, 0x37, 0x8e, 0x1f, 0xff, 0x76, 0xd5, 0xd3, 0x9e, 0x5f, 0xf5, 0xb4, 0xbf,
	0xae, 0x7a, 0xda, 0x0f, 0xd7, 0xbd, 0x3b, 0xcf, 0xaf, 0x7b, 0x77, 0xfe, 0xbc, 0xee, 0xdd, 0xf9,
	0xfa, 0xa3, 0x99, 0x2b, 0xcf, 0xe2, 0xe9, 0xc0, 0x0e, 0xbc, 0x21, 0xfd, 0x39, 0x79, 0xd7, 0x47,
	0xf9, 0x2c, 0x10, 0x4f, 0x95, 0x35, 0x47, 0x67, 0x86, 0x62, 0x78, 0xb9, 0xf2, 0x9f, 0xc6, 0x0e,
	0x04, 0x4e, 0xb7, 0xe8, 0x13, 0xf3, 0xfe, 0xbf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x59, 0x3c, 0x28,
	0xde, 0xf2, 0x08, 0x00, 0x00,
}

func (m *CreditType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreditType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreditType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Precision != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.Precision))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Unit) > 0 {
		i -= len(m.Unit)
		copy(dAtA[i:], m.Unit)
		i = encodeVarintState(dAtA, i, uint64(len(m.Unit)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintState(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Abbreviation) > 0 {
		i -= len(m.Abbreviation)
		copy(dAtA[i:], m.Abbreviation)
		i = encodeVarintState(dAtA, i, uint64(len(m.Abbreviation)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Class) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Class) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Class) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CreditTypeAbbrev) > 0 {
		i -= len(m.CreditTypeAbbrev)
		copy(dAtA[i:], m.CreditTypeAbbrev)
		i = encodeVarintState(dAtA, i, uint64(len(m.CreditTypeAbbrev)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Metadata) > 0 {
		i -= len(m.Metadata)
		copy(dAtA[i:], m.Metadata)
		i = encodeVarintState(dAtA, i, uint64(len(m.Metadata)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Admin) > 0 {
		i -= len(m.Admin)
		copy(dAtA[i:], m.Admin)
		i = encodeVarintState(dAtA, i, uint64(len(m.Admin)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintState(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x12
	}
	if m.Key != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.Key))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ClassIssuer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClassIssuer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClassIssuer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Issuer) > 0 {
		i -= len(m.Issuer)
		copy(dAtA[i:], m.Issuer)
		i = encodeVarintState(dAtA, i, uint64(len(m.Issuer)))
		i--
		dAtA[i] = 0x12
	}
	if m.ClassKey != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.ClassKey))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Project) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Project) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Project) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ReferenceId) > 0 {
		i -= len(m.ReferenceId)
		copy(dAtA[i:], m.ReferenceId)
		i = encodeVarintState(dAtA, i, uint64(len(m.ReferenceId)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Metadata) > 0 {
		i -= len(m.Metadata)
		copy(dAtA[i:], m.Metadata)
		i = encodeVarintState(dAtA, i, uint64(len(m.Metadata)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Jurisdiction) > 0 {
		i -= len(m.Jurisdiction)
		copy(dAtA[i:], m.Jurisdiction)
		i = encodeVarintState(dAtA, i, uint64(len(m.Jurisdiction)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ClassKey != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.ClassKey))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Admin) > 0 {
		i -= len(m.Admin)
		copy(dAtA[i:], m.Admin)
		i = encodeVarintState(dAtA, i, uint64(len(m.Admin)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintState(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x12
	}
	if m.Key != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.Key))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Batch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Batch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Batch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Open {
		i--
		if m.Open {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.IssuanceDate != nil {
		{
			size, err := m.IssuanceDate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintState(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.EndDate != nil {
		{
			size, err := m.EndDate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintState(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.StartDate != nil {
		{
			size, err := m.StartDate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintState(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Metadata) > 0 {
		i -= len(m.Metadata)
		copy(dAtA[i:], m.Metadata)
		i = encodeVarintState(dAtA, i, uint64(len(m.Metadata)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintState(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x22
	}
	if m.ProjectKey != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.ProjectKey))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Issuer) > 0 {
		i -= len(m.Issuer)
		copy(dAtA[i:], m.Issuer)
		i = encodeVarintState(dAtA, i, uint64(len(m.Issuer)))
		i--
		dAtA[i] = 0x12
	}
	if m.Key != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.Key))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ClassSequence) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClassSequence) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClassSequence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NextSequence != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.NextSequence))
		i--
		dAtA[i] = 0x10
	}
	if len(m.CreditTypeAbbrev) > 0 {
		i -= len(m.CreditTypeAbbrev)
		copy(dAtA[i:], m.CreditTypeAbbrev)
		i = encodeVarintState(dAtA, i, uint64(len(m.CreditTypeAbbrev)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProjectSequence) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProjectSequence) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProjectSequence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NextSequence != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.NextSequence))
		i--
		dAtA[i] = 0x10
	}
	if m.ClassKey != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.ClassKey))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BatchSequence) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchSequence) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchSequence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NextSequence != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.NextSequence))
		i--
		dAtA[i] = 0x10
	}
	if m.ProjectKey != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.ProjectKey))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BatchBalance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchBalance) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchBalance) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EscrowedAmount) > 0 {
		i -= len(m.EscrowedAmount)
		copy(dAtA[i:], m.EscrowedAmount)
		i = encodeVarintState(dAtA, i, uint64(len(m.EscrowedAmount)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.RetiredAmount) > 0 {
		i -= len(m.RetiredAmount)
		copy(dAtA[i:], m.RetiredAmount)
		i = encodeVarintState(dAtA, i, uint64(len(m.RetiredAmount)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TradableAmount) > 0 {
		i -= len(m.TradableAmount)
		copy(dAtA[i:], m.TradableAmount)
		i = encodeVarintState(dAtA, i, uint64(len(m.TradableAmount)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintState(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x12
	}
	if m.BatchKey != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.BatchKey))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BatchSupply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchSupply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchSupply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CancelledAmount) > 0 {
		i -= len(m.CancelledAmount)
		copy(dAtA[i:], m.CancelledAmount)
		i = encodeVarintState(dAtA, i, uint64(len(m.CancelledAmount)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.RetiredAmount) > 0 {
		i -= len(m.RetiredAmount)
		copy(dAtA[i:], m.RetiredAmount)
		i = encodeVarintState(dAtA, i, uint64(len(m.RetiredAmount)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TradableAmount) > 0 {
		i -= len(m.TradableAmount)
		copy(dAtA[i:], m.TradableAmount)
		i = encodeVarintState(dAtA, i, uint64(len(m.TradableAmount)))
		i--
		dAtA[i] = 0x12
	}
	if m.BatchKey != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.BatchKey))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OriginTxIndex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OriginTxIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OriginTxIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Source) > 0 {
		i -= len(m.Source)
		copy(dAtA[i:], m.Source)
		i = encodeVarintState(dAtA, i, uint64(len(m.Source)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintState(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x12
	}
	if m.ClassKey != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.ClassKey))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintState(dAtA []byte, offset int, v uint64) int {
	offset -= sovState(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CreditType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Abbreviation)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.Unit)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if m.Precision != 0 {
		n += 1 + sovState(uint64(m.Precision))
	}
	return n
}

func (m *Class) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != 0 {
		n += 1 + sovState(uint64(m.Key))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.CreditTypeAbbrev)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	return n
}

func (m *ClassIssuer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClassKey != 0 {
		n += 1 + sovState(uint64(m.ClassKey))
	}
	l = len(m.Issuer)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	return n
}

func (m *Project) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != 0 {
		n += 1 + sovState(uint64(m.Key))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if m.ClassKey != 0 {
		n += 1 + sovState(uint64(m.ClassKey))
	}
	l = len(m.Jurisdiction)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.ReferenceId)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	return n
}

func (m *Batch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != 0 {
		n += 1 + sovState(uint64(m.Key))
	}
	l = len(m.Issuer)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if m.ProjectKey != 0 {
		n += 1 + sovState(uint64(m.ProjectKey))
	}
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if m.StartDate != nil {
		l = m.StartDate.Size()
		n += 1 + l + sovState(uint64(l))
	}
	if m.EndDate != nil {
		l = m.EndDate.Size()
		n += 1 + l + sovState(uint64(l))
	}
	if m.IssuanceDate != nil {
		l = m.IssuanceDate.Size()
		n += 1 + l + sovState(uint64(l))
	}
	if m.Open {
		n += 2
	}
	return n
}

func (m *ClassSequence) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CreditTypeAbbrev)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if m.NextSequence != 0 {
		n += 1 + sovState(uint64(m.NextSequence))
	}
	return n
}

func (m *ProjectSequence) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClassKey != 0 {
		n += 1 + sovState(uint64(m.ClassKey))
	}
	if m.NextSequence != 0 {
		n += 1 + sovState(uint64(m.NextSequence))
	}
	return n
}

func (m *BatchSequence) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProjectKey != 0 {
		n += 1 + sovState(uint64(m.ProjectKey))
	}
	if m.NextSequence != 0 {
		n += 1 + sovState(uint64(m.NextSequence))
	}
	return n
}

func (m *BatchBalance) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchKey != 0 {
		n += 1 + sovState(uint64(m.BatchKey))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.TradableAmount)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.RetiredAmount)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.EscrowedAmount)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	return n
}

func (m *BatchSupply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchKey != 0 {
		n += 1 + sovState(uint64(m.BatchKey))
	}
	l = len(m.TradableAmount)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.RetiredAmount)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.CancelledAmount)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	return n
}

func (m *OriginTxIndex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClassKey != 0 {
		n += 1 + sovState(uint64(m.ClassKey))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	return n
}

func sovState(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozState(x uint64) (n int) {
	return sovState(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CreditType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreditType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreditType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Abbreviation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Abbreviation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Unit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Precision", wireType)
			}
			m.Precision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Precision |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Class) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Class: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Class: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = append(m.Admin[:0], dAtA[iNdEx:postIndex]...)
			if m.Admin == nil {
				m.Admin = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreditTypeAbbrev", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreditTypeAbbrev = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClassIssuer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClassIssuer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClassIssuer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassKey", wireType)
			}
			m.ClassKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClassKey |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issuer", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Issuer = append(m.Issuer[:0], dAtA[iNdEx:postIndex]...)
			if m.Issuer == nil {
				m.Issuer = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Project) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Project: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Project: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = append(m.Admin[:0], dAtA[iNdEx:postIndex]...)
			if m.Admin == nil {
				m.Admin = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassKey", wireType)
			}
			m.ClassKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClassKey |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jurisdiction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Jurisdiction = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReferenceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Batch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Batch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Batch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issuer", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Issuer = append(m.Issuer[:0], dAtA[iNdEx:postIndex]...)
			if m.Issuer == nil {
				m.Issuer = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectKey", wireType)
			}
			m.ProjectKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProjectKey |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartDate == nil {
				m.StartDate = &types.Timestamp{}
			}
			if err := m.StartDate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndDate == nil {
				m.EndDate = &types.Timestamp{}
			}
			if err := m.EndDate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IssuanceDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IssuanceDate == nil {
				m.IssuanceDate = &types.Timestamp{}
			}
			if err := m.IssuanceDate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Open", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Open = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClassSequence) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClassSequence: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClassSequence: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreditTypeAbbrev", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreditTypeAbbrev = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextSequence", wireType)
			}
			m.NextSequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextSequence |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProjectSequence) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProjectSequence: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProjectSequence: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassKey", wireType)
			}
			m.ClassKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClassKey |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextSequence", wireType)
			}
			m.NextSequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextSequence |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchSequence) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchSequence: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchSequence: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectKey", wireType)
			}
			m.ProjectKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProjectKey |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextSequence", wireType)
			}
			m.NextSequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextSequence |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchBalance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchBalance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchBalance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchKey", wireType)
			}
			m.BatchKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchKey |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = append(m.Address[:0], dAtA[iNdEx:postIndex]...)
			if m.Address == nil {
				m.Address = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradableAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TradableAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetiredAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetiredAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EscrowedAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EscrowedAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchSupply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchSupply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchSupply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchKey", wireType)
			}
			m.BatchKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchKey |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradableAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TradableAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetiredAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetiredAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CancelledAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CancelledAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OriginTxIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OriginTxIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OriginTxIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassKey", wireType)
			}
			m.ClassKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClassKey |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipState(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowState
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowState
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowState
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthState
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupState
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthState
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthState        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowState          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupState = fmt.Errorf("proto: unexpected end of group")
)
