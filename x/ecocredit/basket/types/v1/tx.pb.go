// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: regen/ecocredit/basket/v1/tx.proto

package v1

import (
	context "context"
	fmt "fmt"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/cosmos-sdk/types/msgservice"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/gogo/protobuf/grpc"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MsgCreateBasket is the Msg/CreateBasket request type.
type MsgCreate struct {
	// curator is the address of the basket curator who is able to change certain
	// basket settings.
	Curator string `protobuf:"bytes,1,opt,name=curator,proto3" json:"curator,omitempty"`
	// name will be used to together with prefix to create a bank denom for this
	// basket token. It can be between 3-8 alphanumeric characters, with the
	// first character being alphabetic.
	//
	// The bank denom will be formed from name and credit type with the format
	// `eco.<prefix><credit_type_abbrev>.<name>` where prefix is the prefix of
	// a standard SI unit derived from credit type precision.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// description is a human-readable description of the basket denom that should
	// be at most 256 characters.
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// Deprecated (Since Revision 1): This field is no longer used and will be
	// removed in the next version. The value of credit type precision is always
	// used as the exponent when determining the prefix for basket denom, defining
	// bank denom metadata, and converting credits to/from basket tokens.
	Exponent uint32 `protobuf:"varint,4,opt,name=exponent,proto3" json:"exponent,omitempty"` // Deprecated: Do not use.
	// disable_auto_retire allows auto-retirement to be disabled.
	// The credits will be auto-retired if disable_auto_retire is
	// false unless the credits were previously put into the basket by the
	// address picking them from the basket, in which case they will remain
	// tradable.
	DisableAutoRetire bool `protobuf:"varint,5,opt,name=disable_auto_retire,json=disableAutoRetire,proto3" json:"disable_auto_retire,omitempty"`
	// credit_type_abbrev is the abbreviation of the credit type this basket is
	// able to hold.
	CreditTypeAbbrev string `protobuf:"bytes,6,opt,name=credit_type_abbrev,json=creditTypeAbbrev,proto3" json:"credit_type_abbrev,omitempty"`
	// allowed_classes are the credit classes allowed to be put in the basket
	AllowedClasses []string `protobuf:"bytes,7,rep,name=allowed_classes,json=allowedClasses,proto3" json:"allowed_classes,omitempty"`
	// date_criteria is the date criteria for batches admitted to the basket.
	// At most, only one of the date criteria fields can be set.
	DateCriteria *DateCriteria `protobuf:"bytes,8,opt,name=date_criteria,json=dateCriteria,proto3" json:"date_criteria,omitempty"`
	// fee is the basket creation fee. A fee is not required if no fee exists
	// in the basket fee parameter. The fee must be greater than or equal to the
	// fee param. The curator will be charged the amount specified in the fee
	// parameter, even if a greater amount is provided.
	//
	// Note (Since Revision 1): Although this field supports a list of fees, the
	// basket creator must provide no more than one fee (i.e. one Coin in a list
	// of Coins). Providing more than one fee will fail basic message validation.
	// This field will be updated to a single fee rather than a list of fees in
	// the next version to reflect these requirements.
	Fee github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,9,rep,name=fee,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"fee"`
}

func (m *MsgCreate) Reset()         { *m = MsgCreate{} }
func (m *MsgCreate) String() string { return proto.CompactTextString(m) }
func (*MsgCreate) ProtoMessage()    {}
func (*MsgCreate) Descriptor() ([]byte, []int) {
	return fileDescriptor_a60f962a3c61f018, []int{0}
}
func (m *MsgCreate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreate.Merge(m, src)
}
func (m *MsgCreate) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreate) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreate.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreate proto.InternalMessageInfo

func (m *MsgCreate) GetCurator() string {
	if m != nil {
		return m.Curator
	}
	return ""
}

func (m *MsgCreate) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MsgCreate) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

// Deprecated: Do not use.
func (m *MsgCreate) GetExponent() uint32 {
	if m != nil {
		return m.Exponent
	}
	return 0
}

func (m *MsgCreate) GetDisableAutoRetire() bool {
	if m != nil {
		return m.DisableAutoRetire
	}
	return false
}

func (m *MsgCreate) GetCreditTypeAbbrev() string {
	if m != nil {
		return m.CreditTypeAbbrev
	}
	return ""
}

func (m *MsgCreate) GetAllowedClasses() []string {
	if m != nil {
		return m.AllowedClasses
	}
	return nil
}

func (m *MsgCreate) GetDateCriteria() *DateCriteria {
	if m != nil {
		return m.DateCriteria
	}
	return nil
}

func (m *MsgCreate) GetFee() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.Fee
	}
	return nil
}

// MsgCreateBasketResponse is the Msg/CreateBasket response type.
type MsgCreateResponse struct {
	// basket_denom is the unique denomination ID of the newly created basket.
	BasketDenom string `protobuf:"bytes,1,opt,name=basket_denom,json=basketDenom,proto3" json:"basket_denom,omitempty"`
}

func (m *MsgCreateResponse) Reset()         { *m = MsgCreateResponse{} }
func (m *MsgCreateResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateResponse) ProtoMessage()    {}
func (*MsgCreateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a60f962a3c61f018, []int{1}
}
func (m *MsgCreateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateResponse.Merge(m, src)
}
func (m *MsgCreateResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateResponse proto.InternalMessageInfo

func (m *MsgCreateResponse) GetBasketDenom() string {
	if m != nil {
		return m.BasketDenom
	}
	return ""
}

// MsgAddToBasket is the Msg/AddToBasket request type.
type MsgPut struct {
	// owner is the owner of credits being put into the basket.
	Owner string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	// basket_denom is the basket denom to add credits to.
	BasketDenom string `protobuf:"bytes,2,opt,name=basket_denom,json=basketDenom,proto3" json:"basket_denom,omitempty"`
	// credits are credits to add to the basket. If they do not match the basket's
	// admission criteria, the operation will fail.
	Credits []*BasketCredit `protobuf:"bytes,3,rep,name=credits,proto3" json:"credits,omitempty"`
}

func (m *MsgPut) Reset()         { *m = MsgPut{} }
func (m *MsgPut) String() string { return proto.CompactTextString(m) }
func (*MsgPut) ProtoMessage()    {}
func (*MsgPut) Descriptor() ([]byte, []int) {
	return fileDescriptor_a60f962a3c61f018, []int{2}
}
func (m *MsgPut) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPut) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPut.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPut) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPut.Merge(m, src)
}
func (m *MsgPut) XXX_Size() int {
	return m.Size()
}
func (m *MsgPut) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPut.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPut proto.InternalMessageInfo

func (m *MsgPut) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *MsgPut) GetBasketDenom() string {
	if m != nil {
		return m.BasketDenom
	}
	return ""
}

func (m *MsgPut) GetCredits() []*BasketCredit {
	if m != nil {
		return m.Credits
	}
	return nil
}

// MsgAddToBasketResponse is the Msg/AddToBasket response type.
type MsgPutResponse struct {
	// amount_received is the integer amount of basket tokens received.
	AmountReceived string `protobuf:"bytes,1,opt,name=amount_received,json=amountReceived,proto3" json:"amount_received,omitempty"`
}

func (m *MsgPutResponse) Reset()         { *m = MsgPutResponse{} }
func (m *MsgPutResponse) String() string { return proto.CompactTextString(m) }
func (*MsgPutResponse) ProtoMessage()    {}
func (*MsgPutResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a60f962a3c61f018, []int{3}
}
func (m *MsgPutResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPutResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPutResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPutResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPutResponse.Merge(m, src)
}
func (m *MsgPutResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgPutResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPutResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPutResponse proto.InternalMessageInfo

func (m *MsgPutResponse) GetAmountReceived() string {
	if m != nil {
		return m.AmountReceived
	}
	return ""
}

// MsgTakeFromBasket is the Msg/TakeFromBasket request type.
type MsgTake struct {
	// owner is the owner of the basket tokens.
	Owner string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	// basket_denom is the basket bank denom to take credits from.
	BasketDenom string `protobuf:"bytes,2,opt,name=basket_denom,json=basketDenom,proto3" json:"basket_denom,omitempty"`
	// amount is the integer number of basket tokens to convert into credits.
	Amount string `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount,omitempty"`
	// retirement_location is the optional retirement jurisdiction for the
	// credits which will be used only if retire_on_take is true.
	//
	// Deprecated (Since Revision 1): This field will be removed in the next
	// version in favor of retirement_jurisdiction. Only one of these need to be
	// set and retirement_jurisdiction will be used if both are set.
	RetirementLocation string `protobuf:"bytes,4,opt,name=retirement_location,json=retirementLocation,proto3" json:"retirement_location,omitempty"` // Deprecated: Do not use.
	// retire_on_take is a boolean that dictates whether the ecocredits
	// received in exchange for the basket tokens will be received as
	// retired or tradable credits. If the basket has disable_auto_retire set to
	// false, retire_on_take MUST be set to true, and a retirement jurisdiction
	// must be provided.
	RetireOnTake bool `protobuf:"varint,5,opt,name=retire_on_take,json=retireOnTake,proto3" json:"retire_on_take,omitempty"`
	// retirement_jurisdiction is the optional retirement jurisdiction for the
	// credits which will be used only if retire_on_take is true.
	//
	// Since Revision 1
	RetirementJurisdiction string `protobuf:"bytes,6,opt,name=retirement_jurisdiction,json=retirementJurisdiction,proto3" json:"retirement_jurisdiction,omitempty"`
	// retirement_reason is any arbitrary string that specifies the reason for
	// retiring credits. The reason will be included in EventRetire and is not
	// stored in state.
	//
	// Since Revision 2
	RetirementReason string `protobuf:"bytes,7,opt,name=retirement_reason,json=retirementReason,proto3" json:"retirement_reason,omitempty"`
}

func (m *MsgTake) Reset()         { *m = MsgTake{} }
func (m *MsgTake) String() string { return proto.CompactTextString(m) }
func (*MsgTake) ProtoMessage()    {}
func (*MsgTake) Descriptor() ([]byte, []int) {
	return fileDescriptor_a60f962a3c61f018, []int{4}
}
func (m *MsgTake) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgTake) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgTake.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgTake) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgTake.Merge(m, src)
}
func (m *MsgTake) XXX_Size() int {
	return m.Size()
}
func (m *MsgTake) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgTake.DiscardUnknown(m)
}

var xxx_messageInfo_MsgTake proto.InternalMessageInfo

func (m *MsgTake) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *MsgTake) GetBasketDenom() string {
	if m != nil {
		return m.BasketDenom
	}
	return ""
}

func (m *MsgTake) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

// Deprecated: Do not use.
func (m *MsgTake) GetRetirementLocation() string {
	if m != nil {
		return m.RetirementLocation
	}
	return ""
}

func (m *MsgTake) GetRetireOnTake() bool {
	if m != nil {
		return m.RetireOnTake
	}
	return false
}

func (m *MsgTake) GetRetirementJurisdiction() string {
	if m != nil {
		return m.RetirementJurisdiction
	}
	return ""
}

func (m *MsgTake) GetRetirementReason() string {
	if m != nil {
		return m.RetirementReason
	}
	return ""
}

// MsgTakeFromBasketResponse is the Msg/TakeFromBasket response type.
type MsgTakeResponse struct {
	// credits are the credits taken out of the basket.
	Credits []*BasketCredit `protobuf:"bytes,1,rep,name=credits,proto3" json:"credits,omitempty"`
}

func (m *MsgTakeResponse) Reset()         { *m = MsgTakeResponse{} }
func (m *MsgTakeResponse) String() string { return proto.CompactTextString(m) }
func (*MsgTakeResponse) ProtoMessage()    {}
func (*MsgTakeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a60f962a3c61f018, []int{5}
}
func (m *MsgTakeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgTakeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgTakeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgTakeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgTakeResponse.Merge(m, src)
}
func (m *MsgTakeResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgTakeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgTakeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgTakeResponse proto.InternalMessageInfo

func (m *MsgTakeResponse) GetCredits() []*BasketCredit {
	if m != nil {
		return m.Credits
	}
	return nil
}

// MsgUpdateBasketFee is the Msg/UpdateBasketFee request type.
//
// Since Revision 2
type MsgUpdateBasketFee struct {
	// authority is the address of the governance account.
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// fee is the basket creation fee. If not set, the basket creation fee will be
	// removed and no fee will be required to create a basket.
	Fee *types.Coin `protobuf:"bytes,2,opt,name=fee,proto3" json:"fee,omitempty"`
}

func (m *MsgUpdateBasketFee) Reset()         { *m = MsgUpdateBasketFee{} }
func (m *MsgUpdateBasketFee) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateBasketFee) ProtoMessage()    {}
func (*MsgUpdateBasketFee) Descriptor() ([]byte, []int) {
	return fileDescriptor_a60f962a3c61f018, []int{6}
}
func (m *MsgUpdateBasketFee) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateBasketFee) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateBasketFee.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateBasketFee) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateBasketFee.Merge(m, src)
}
func (m *MsgUpdateBasketFee) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateBasketFee) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateBasketFee.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateBasketFee proto.InternalMessageInfo

func (m *MsgUpdateBasketFee) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgUpdateBasketFee) GetFee() *types.Coin {
	if m != nil {
		return m.Fee
	}
	return nil
}

// MsgUpdateBasketFeeResponse is the Msg/UpdateBasketFee response type.
//
// Since Revision 2
type MsgUpdateBasketFeeResponse struct {
}

func (m *MsgUpdateBasketFeeResponse) Reset()         { *m = MsgUpdateBasketFeeResponse{} }
func (m *MsgUpdateBasketFeeResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateBasketFeeResponse) ProtoMessage()    {}
func (*MsgUpdateBasketFeeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a60f962a3c61f018, []int{7}
}
func (m *MsgUpdateBasketFeeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateBasketFeeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateBasketFeeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateBasketFeeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateBasketFeeResponse.Merge(m, src)
}
func (m *MsgUpdateBasketFeeResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateBasketFeeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateBasketFeeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateBasketFeeResponse proto.InternalMessageInfo

// MsgUpdateCurator is the Msg/UpdateCurator request type.
//
// Since Revision 2
type MsgUpdateCurator struct {
	// curator is the address of the basket curator.
	Curator string `protobuf:"bytes,1,opt,name=curator,proto3" json:"curator,omitempty"`
	// denom is the unique identifier of the basket.
	Denom string `protobuf:"bytes,2,opt,name=denom,proto3" json:"denom,omitempty"`
	// new_curator is the address of the account that will become the
	// new curator of the basket.
	NewCurator string `protobuf:"bytes,3,opt,name=new_curator,json=newCurator,proto3" json:"new_curator,omitempty"`
}

func (m *MsgUpdateCurator) Reset()         { *m = MsgUpdateCurator{} }
func (m *MsgUpdateCurator) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateCurator) ProtoMessage()    {}
func (*MsgUpdateCurator) Descriptor() ([]byte, []int) {
	return fileDescriptor_a60f962a3c61f018, []int{8}
}
func (m *MsgUpdateCurator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateCurator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateCurator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateCurator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateCurator.Merge(m, src)
}
func (m *MsgUpdateCurator) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateCurator) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateCurator.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateCurator proto.InternalMessageInfo

func (m *MsgUpdateCurator) GetCurator() string {
	if m != nil {
		return m.Curator
	}
	return ""
}

func (m *MsgUpdateCurator) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *MsgUpdateCurator) GetNewCurator() string {
	if m != nil {
		return m.NewCurator
	}
	return ""
}

// MsgUpdateCuratorResponse is the Msg/UpdateCurator response type.
//
// Since Revision 2
type MsgUpdateCuratorResponse struct {
}

func (m *MsgUpdateCuratorResponse) Reset()         { *m = MsgUpdateCuratorResponse{} }
func (m *MsgUpdateCuratorResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateCuratorResponse) ProtoMessage()    {}
func (*MsgUpdateCuratorResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a60f962a3c61f018, []int{9}
}
func (m *MsgUpdateCuratorResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateCuratorResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateCuratorResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateCuratorResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateCuratorResponse.Merge(m, src)
}
func (m *MsgUpdateCuratorResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateCuratorResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateCuratorResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateCuratorResponse proto.InternalMessageInfo

// MsgUpdateDateCriteria is the Msg/UpdateDateCriteria request type.
//
// Since Revision 3
type MsgUpdateDateCriteria struct {
	// authority is the address of the governance account.
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// denom is the unique identifier of the basket.
	Denom string `protobuf:"bytes,2,opt,name=denom,proto3" json:"denom,omitempty"`
	// new_date_criteria is the new date criteria for batches admitted to the
	// basket. At most, only one of the date criteria fields can be set.
	NewDateCriteria *DateCriteria `protobuf:"bytes,8,opt,name=new_date_criteria,json=newDateCriteria,proto3" json:"new_date_criteria,omitempty"`
}

func (m *MsgUpdateDateCriteria) Reset()         { *m = MsgUpdateDateCriteria{} }
func (m *MsgUpdateDateCriteria) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateDateCriteria) ProtoMessage()    {}
func (*MsgUpdateDateCriteria) Descriptor() ([]byte, []int) {
	return fileDescriptor_a60f962a3c61f018, []int{10}
}
func (m *MsgUpdateDateCriteria) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateDateCriteria) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateDateCriteria.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateDateCriteria) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateDateCriteria.Merge(m, src)
}
func (m *MsgUpdateDateCriteria) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateDateCriteria) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateDateCriteria.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateDateCriteria proto.InternalMessageInfo

func (m *MsgUpdateDateCriteria) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgUpdateDateCriteria) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *MsgUpdateDateCriteria) GetNewDateCriteria() *DateCriteria {
	if m != nil {
		return m.NewDateCriteria
	}
	return nil
}

// MsgUpdateDateCriteriaResponse is the Msg/UpdateDateCriteria response type.
//
// Since Revision 3
type MsgUpdateDateCriteriaResponse struct {
}

func (m *MsgUpdateDateCriteriaResponse) Reset()         { *m = MsgUpdateDateCriteriaResponse{} }
func (m *MsgUpdateDateCriteriaResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateDateCriteriaResponse) ProtoMessage()    {}
func (*MsgUpdateDateCriteriaResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a60f962a3c61f018, []int{11}
}
func (m *MsgUpdateDateCriteriaResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateDateCriteriaResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateDateCriteriaResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateDateCriteriaResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateDateCriteriaResponse.Merge(m, src)
}
func (m *MsgUpdateDateCriteriaResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateDateCriteriaResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateDateCriteriaResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateDateCriteriaResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*MsgCreate)(nil), "regen.ecocredit.basket.v1.MsgCreate")
	proto.RegisterType((*MsgCreateResponse)(nil), "regen.ecocredit.basket.v1.MsgCreateResponse")
	proto.RegisterType((*MsgPut)(nil), "regen.ecocredit.basket.v1.MsgPut")
	proto.RegisterType((*MsgPutResponse)(nil), "regen.ecocredit.basket.v1.MsgPutResponse")
	proto.RegisterType((*MsgTake)(nil), "regen.ecocredit.basket.v1.MsgTake")
	proto.RegisterType((*MsgTakeResponse)(nil), "regen.ecocredit.basket.v1.MsgTakeResponse")
	proto.RegisterType((*MsgUpdateBasketFee)(nil), "regen.ecocredit.basket.v1.MsgUpdateBasketFee")
	proto.RegisterType((*MsgUpdateBasketFeeResponse)(nil), "regen.ecocredit.basket.v1.MsgUpdateBasketFeeResponse")
	proto.RegisterType((*MsgUpdateCurator)(nil), "regen.ecocredit.basket.v1.MsgUpdateCurator")
	proto.RegisterType((*MsgUpdateCuratorResponse)(nil), "regen.ecocredit.basket.v1.MsgUpdateCuratorResponse")
	proto.RegisterType((*MsgUpdateDateCriteria)(nil), "regen.ecocredit.basket.v1.MsgUpdateDateCriteria")
	proto.RegisterType((*MsgUpdateDateCriteriaResponse)(nil), "regen.ecocredit.basket.v1.MsgUpdateDateCriteriaResponse")
}

func init() {
	proto.RegisterFile("regen/ecocredit/basket/v1/tx.proto", fileDescriptor_a60f962a3c61f018)
}

var fileDescriptor_a60f962a3c61f018 = []byte{
	// 958 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0xcd, 0x6e, 0xdb, 0x46,
	0x10, 0x36, 0x2d, 0xff, 0x69, 0x64, 0xcb, 0xf1, 0xc6, 0x4d, 0x18, 0x22, 0x95, 0x15, 0x22, 0x45,
	0xd4, 0x38, 0xa6, 0x62, 0x1b, 0xfd, 0xcb, 0xcd, 0x56, 0xd0, 0x43, 0x11, 0xa1, 0x01, 0xe3, 0xf6,
	0xd0, 0x1f, 0x10, 0x14, 0x39, 0x65, 0x58, 0x49, 0xbb, 0x0a, 0x77, 0x25, 0xd9, 0xb7, 0xa2, 0x4f,
	0x90, 0xb7, 0x28, 0xd0, 0x43, 0xd1, 0x17, 0xe8, 0x3d, 0xc7, 0x1c, 0x7b, 0x6a, 0x0b, 0xfb, 0xd0,
	0xc7, 0x68, 0xc1, 0xdd, 0x15, 0xc5, 0xc8, 0xb6, 0x6c, 0x27, 0x27, 0xed, 0x7e, 0xf3, 0xcd, 0xec,
	0xcc, 0xce, 0x37, 0x2b, 0x82, 0x9d, 0x60, 0x84, 0xb4, 0x8e, 0x01, 0x0b, 0x12, 0x0c, 0x63, 0x51,
	0x6f, 0xf9, 0xbc, 0x8d, 0xa2, 0x3e, 0xd8, 0xae, 0x8b, 0x43, 0xa7, 0x97, 0x30, 0xc1, 0xc8, 0x2d,
	0xc9, 0x71, 0x32, 0x8e, 0xa3, 0x38, 0xce, 0x60, 0xdb, 0xaa, 0x04, 0x8c, 0x77, 0x19, 0x4f, 0xbd,
	0xb0, 0x3e, 0xd8, 0x6e, 0xa1, 0xf0, 0xb7, 0xeb, 0x01, 0x8b, 0xa9, 0x72, 0xb5, 0x6e, 0x6a, 0x7b,
	0x97, 0x47, 0x69, 0xc8, 0x2e, 0x8f, 0xb4, 0x61, 0x3d, 0x62, 0x11, 0x93, 0xcb, 0x7a, 0xba, 0xd2,
	0xe8, 0x07, 0x53, 0xb2, 0x39, 0xea, 0x21, 0x57, 0x34, 0xfb, 0x8f, 0x02, 0x14, 0x9b, 0x3c, 0x6a,
	0x24, 0xe8, 0x0b, 0x24, 0x26, 0x2c, 0x06, 0xfd, 0xc4, 0x17, 0x2c, 0x31, 0x8d, 0xaa, 0x51, 0x2b,
	0xba, 0xa3, 0x2d, 0x21, 0x30, 0x47, 0xfd, 0x2e, 0x9a, 0xb3, 0x12, 0x96, 0x6b, 0x52, 0x85, 0x52,
	0x88, 0x3c, 0x48, 0xe2, 0x9e, 0x88, 0x19, 0x35, 0x0b, 0xd2, 0x94, 0x87, 0x48, 0x05, 0x96, 0xf0,
	0xb0, 0xc7, 0x28, 0x52, 0x61, 0xce, 0x55, 0x8d, 0xda, 0xca, 0xfe, 0xac, 0x69, 0xb8, 0x19, 0x46,
	0x1c, 0xb8, 0x1e, 0xc6, 0xdc, 0x6f, 0x75, 0xd0, 0xf3, 0xfb, 0x82, 0x79, 0x09, 0x8a, 0x38, 0x41,
	0x73, 0xbe, 0x6a, 0xd4, 0x96, 0xdc, 0x35, 0x6d, 0xda, 0xeb, 0x0b, 0xe6, 0x4a, 0x03, 0x79, 0x00,
	0x44, 0x55, 0xe3, 0xa5, 0x35, 0x78, 0x7e, 0xab, 0x95, 0xe0, 0xc0, 0x5c, 0x90, 0x07, 0x5f, 0x53,
	0x96, 0x83, 0xa3, 0x1e, 0xee, 0x49, 0x9c, 0xdc, 0x83, 0x55, 0xbf, 0xd3, 0x61, 0x43, 0x0c, 0xbd,
	0xa0, 0xe3, 0x73, 0x8e, 0xdc, 0x5c, 0xac, 0x16, 0x6a, 0x45, 0xb7, 0xac, 0xe1, 0x86, 0x42, 0xc9,
	0x13, 0x58, 0x09, 0x7d, 0x81, 0x5e, 0x90, 0xc4, 0x02, 0x93, 0xd8, 0x37, 0x97, 0xaa, 0x46, 0xad,
	0xb4, 0x73, 0xcf, 0x39, 0xb7, 0x5b, 0xce, 0x63, 0x5f, 0x60, 0x43, 0xd3, 0xdd, 0xe5, 0x30, 0xb7,
	0x23, 0xdf, 0x43, 0xe1, 0x07, 0x44, 0xb3, 0x58, 0x2d, 0xd4, 0x4a, 0x3b, 0xb7, 0x1c, 0xd5, 0xb6,
	0xd4, 0x15, 0x1d, 0xdd, 0x56, 0xa7, 0xc1, 0x62, 0xba, 0xff, 0xf0, 0xd5, 0x5f, 0x1b, 0x33, 0xbf,
	0xfe, 0xbd, 0x51, 0x8b, 0x62, 0xf1, 0xbc, 0xdf, 0x72, 0x02, 0xd6, 0xad, 0xeb, 0x1e, 0xab, 0x9f,
	0x2d, 0x1e, 0xb6, 0x75, 0xb3, 0x52, 0x07, 0xee, 0xa6, 0x71, 0x1f, 0x2d, 0xff, 0xfc, 0xef, 0xef,
	0xf7, 0x47, 0x7d, 0xb1, 0x3f, 0x86, 0xb5, 0xac, 0x7d, 0x2e, 0xf2, 0x1e, 0xa3, 0x1c, 0xc9, 0x1d,
	0x58, 0x56, 0x99, 0x7a, 0x21, 0x52, 0xd6, 0xd5, 0xbd, 0x2c, 0x29, 0xec, 0x71, 0x0a, 0xd9, 0x2f,
	0x0d, 0x58, 0x68, 0xf2, 0xe8, 0x69, 0x5f, 0x90, 0x75, 0x98, 0x67, 0x43, 0x8a, 0xa3, 0x96, 0xab,
	0xcd, 0xa9, 0x18, 0xb3, 0xa7, 0x62, 0x90, 0x3d, 0x58, 0x54, 0xf7, 0xc2, 0xcd, 0x82, 0x2c, 0x76,
	0xda, 0x85, 0xed, 0xcb, 0x55, 0x43, 0xc2, 0xee, 0xc8, 0xef, 0x11, 0xa4, 0xc5, 0xa8, 0x13, 0xed,
	0xcf, 0xa0, 0xac, 0x32, 0xca, 0xea, 0x48, 0x1b, 0xd8, 0x65, 0x7d, 0x2a, 0xbc, 0x04, 0x03, 0x8c,
	0x07, 0x18, 0xea, 0x1c, 0xcb, 0x0a, 0x76, 0x35, 0x6a, 0xff, 0x32, 0x0b, 0x8b, 0x4d, 0x1e, 0x1d,
	0xf8, 0x6d, 0x7c, 0xfb, 0x72, 0x6e, 0xc0, 0x82, 0x0a, 0xab, 0x95, 0xac, 0x77, 0x64, 0x17, 0xae,
	0x2b, 0x5d, 0x76, 0x91, 0x0a, 0xaf, 0xc3, 0x02, 0x5f, 0xca, 0x3d, 0xd5, 0x73, 0x51, 0xea, 0x99,
	0x8c, 0xcd, 0x4f, 0xb4, 0x95, 0xdc, 0x85, 0xb2, 0x42, 0x3d, 0x46, 0x3d, 0xe1, 0xb7, 0x47, 0xa2,
	0x5e, 0x56, 0xe8, 0x97, 0x54, 0xe6, 0xfa, 0x09, 0xdc, 0xcc, 0x85, 0xfe, 0xb1, 0x9f, 0xc4, 0x3c,
	0x8c, 0x03, 0x19, 0x5e, 0x89, 0xfa, 0xc6, 0xd8, 0xfc, 0x45, 0xce, 0x4a, 0x36, 0x61, 0x2d, 0xe7,
	0x98, 0xa0, 0xcf, 0x19, 0x35, 0x17, 0xd5, 0x1c, 0x8c, 0x0d, 0xae, 0xc4, 0xdf, 0xb8, 0xe4, 0x03,
	0x58, 0xd5, 0x17, 0x95, 0xdd, 0x72, 0xae, 0x8d, 0xc6, 0xdb, 0xb5, 0xd1, 0x66, 0x40, 0x9a, 0x3c,
	0xfa, 0xaa, 0x97, 0xce, 0x81, 0x62, 0x7c, 0x8e, 0x48, 0x6e, 0x43, 0xd1, 0xef, 0x8b, 0xe7, 0x2c,
	0x89, 0xc5, 0x91, 0xee, 0xc6, 0x18, 0x20, 0x9b, 0x6a, 0x4c, 0x66, 0xe5, 0xa8, 0x9d, 0x3f, 0x26,
	0x4a, 0xf4, 0xe5, 0xb4, 0x84, 0xb1, 0xb3, 0x7d, 0x1b, 0xac, 0xd3, 0x07, 0x8e, 0x2a, 0xb2, 0x5f,
	0xc0, 0xb5, 0xcc, 0xda, 0xd0, 0x0f, 0xd8, 0xf9, 0x4f, 0xdb, 0x3a, 0xcc, 0xe7, 0x35, 0xa1, 0x36,
	0x64, 0x03, 0x4a, 0x14, 0x87, 0xde, 0xc8, 0x47, 0x49, 0x02, 0x28, 0x0e, 0x75, 0xc0, 0x89, 0x39,
	0xb4, 0xc0, 0x9c, 0x3c, 0x32, 0x4b, 0xe7, 0x37, 0x03, 0xde, 0xcb, 0x8c, 0xf9, 0x87, 0xe3, 0x82,
	0x1b, 0x3a, 0x3b, 0xb1, 0x67, 0xb0, 0x96, 0x26, 0xf6, 0x4e, 0x0f, 0xd6, 0x2a, 0xc5, 0x61, 0x1e,
	0x98, 0x28, 0x66, 0x03, 0xde, 0x3f, 0x33, 0xdf, 0x51, 0x45, 0x3b, 0xff, 0xcd, 0x41, 0xa1, 0xc9,
	0x23, 0xf2, 0x1d, 0x2c, 0xe8, 0x7f, 0x8e, 0xbb, 0x53, 0x8e, 0xce, 0x1e, 0x28, 0xeb, 0xc1, 0x65,
	0x58, 0x99, 0x30, 0x9f, 0x41, 0x21, 0x7d, 0x9f, 0xee, 0x4c, 0x77, 0x7a, 0xda, 0x17, 0xd6, 0x87,
	0x17, 0x52, 0xb2, 0xa0, 0x5f, 0xc3, 0x9c, 0x1c, 0x3d, 0x7b, 0xba, 0x4b, 0xca, 0xb1, 0xee, 0x5f,
	0xcc, 0xc9, 0xe2, 0x0e, 0x61, 0x75, 0x52, 0xff, 0x5b, 0xd3, 0xdd, 0x27, 0xe8, 0xd6, 0x47, 0x57,
	0xa2, 0x67, 0x07, 0xbf, 0x80, 0x95, 0x37, 0x95, 0xbe, 0x79, 0x99, 0x38, 0x9a, 0x6c, 0xed, 0x5e,
	0x81, 0x9c, 0x1d, 0xf9, 0x93, 0x01, 0xe4, 0x0c, 0x35, 0x3f, 0xbc, 0x4c, 0xac, 0xbc, 0x87, 0xf5,
	0xe9, 0x55, 0x3d, 0x46, 0x29, 0xec, 0x7f, 0xfb, 0xea, 0xb8, 0x62, 0xbc, 0x3e, 0xae, 0x18, 0xff,
	0x1c, 0x57, 0x8c, 0x97, 0x27, 0x95, 0x99, 0xd7, 0x27, 0x95, 0x99, 0x3f, 0x4f, 0x2a, 0x33, 0xdf,
	0xec, 0xe5, 0xfe, 0x4e, 0x65, 0xf4, 0x2d, 0x8a, 0x62, 0xc8, 0x92, 0xb6, 0xde, 0x75, 0x30, 0x8c,
	0x30, 0xa9, 0x1f, 0x9e, 0xfe, 0x34, 0x92, 0x7f, 0xb5, 0xe9, 0xa7, 0xd7, 0x82, 0xfc, 0x36, 0xda,
	0xfd, 0x3f, 0x00, 0x00, 0xff, 0xff, 0xbf, 0x7e, 0x39, 0x56, 0xd2, 0x09, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	// Create creates a basket that can hold different types of ecocredits that
	// meet the basket's criteria. Upon depositing ecocredits into the basket,
	// basket tokens are minted and sent to depositor using the Cosmos SDK Bank
	// module. This allows basket tokens to be utilized within IBC. Basket tokens
	// are fully fungible with other basket tokens from the same basket. The
	// basket token denom is derived from the basket name, credit type
	// abbreviation, and credit type precision (i.e. basket name "foo", credit
	// type exponent 6, and credit type abbreviation "C" generates the denom
	// eco.uC.foo). Baskets can limit credit acceptance criteria based on a
	// combination of credit type, credit classes, and credit batch start date.
	// Credits can be taken from the basket in exchange for basket tokens. Taken
	// credits will be immediately retired, unless disable_auto_retire is set to
	// true. When set to true, credits may be received in either a tradable or
	// retired state, depending on the taker's request. If the basket fee
	// governance parameter is set, a fee of equal or greater value must be
	// provided in the request. Only the amount specified in the fee parameter
	// will be charged, even if a greater value fee is provided. Fees from
	// creating a basket are burned.
	Create(ctx context.Context, in *MsgCreate, opts ...grpc.CallOption) (*MsgCreateResponse, error)
	// Put deposits credits into the basket from the holder's tradable balance in
	// exchange for basket tokens. The amount of tokens received is calculated by
	// the following formula: sum(credits_deposited) * 10^credit_type_exponent.
	// The credits being deposited MUST adhere to the criteria of the basket.
	Put(ctx context.Context, in *MsgPut, opts ...grpc.CallOption) (*MsgPutResponse, error)
	// Take exchanges basket tokens for credits from the specified basket. Credits
	// are taken deterministically, ordered by oldest batch start date to the most
	// recent batch start date. If the basket has disable_auto_retire set to
	// false, both retirement_jurisdiction and retire_on_take must be set, and the
	// taken credits will be retired immediately upon receipt. Otherwise, credits
	// may be received as tradable or retired, based on the request.
	Take(ctx context.Context, in *MsgTake, opts ...grpc.CallOption) (*MsgTakeResponse, error)
	// UpdateBasketFee is a governance method that allows for updating the basket
	// creation fee. If not set, the basket creation fee will be removed and no
	// fee will be required to create a basket.
	//
	// Since Revision 2
	UpdateBasketFee(ctx context.Context, in *MsgUpdateBasketFee, opts ...grpc.CallOption) (*MsgUpdateBasketFeeResponse, error)
	// UpdateCurator updates basket curator.
	//
	// Since Revision 2
	UpdateCurator(ctx context.Context, in *MsgUpdateCurator, opts ...grpc.CallOption) (*MsgUpdateCuratorResponse, error)
	// UpdateDateCriteria is a governance method that allows for updating the date
	// criteria of a basket. Updating basket date criteria could affect the value
	// of basket tokens and therefore requires a network-wide governance process.
	//
	// Since Revision 3
	UpdateDateCriteria(ctx context.Context, in *MsgUpdateDateCriteria, opts ...grpc.CallOption) (*MsgUpdateDateCriteriaResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) Create(ctx context.Context, in *MsgCreate, opts ...grpc.CallOption) (*MsgCreateResponse, error) {
	out := new(MsgCreateResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.basket.v1.Msg/Create", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Put(ctx context.Context, in *MsgPut, opts ...grpc.CallOption) (*MsgPutResponse, error) {
	out := new(MsgPutResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.basket.v1.Msg/Put", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Take(ctx context.Context, in *MsgTake, opts ...grpc.CallOption) (*MsgTakeResponse, error) {
	out := new(MsgTakeResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.basket.v1.Msg/Take", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateBasketFee(ctx context.Context, in *MsgUpdateBasketFee, opts ...grpc.CallOption) (*MsgUpdateBasketFeeResponse, error) {
	out := new(MsgUpdateBasketFeeResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.basket.v1.Msg/UpdateBasketFee", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateCurator(ctx context.Context, in *MsgUpdateCurator, opts ...grpc.CallOption) (*MsgUpdateCuratorResponse, error) {
	out := new(MsgUpdateCuratorResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.basket.v1.Msg/UpdateCurator", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateDateCriteria(ctx context.Context, in *MsgUpdateDateCriteria, opts ...grpc.CallOption) (*MsgUpdateDateCriteriaResponse, error) {
	out := new(MsgUpdateDateCriteriaResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.basket.v1.Msg/UpdateDateCriteria", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	// Create creates a basket that can hold different types of ecocredits that
	// meet the basket's criteria. Upon depositing ecocredits into the basket,
	// basket tokens are minted and sent to depositor using the Cosmos SDK Bank
	// module. This allows basket tokens to be utilized within IBC. Basket tokens
	// are fully fungible with other basket tokens from the same basket. The
	// basket token denom is derived from the basket name, credit type
	// abbreviation, and credit type precision (i.e. basket name "foo", credit
	// type exponent 6, and credit type abbreviation "C" generates the denom
	// eco.uC.foo). Baskets can limit credit acceptance criteria based on a
	// combination of credit type, credit classes, and credit batch start date.
	// Credits can be taken from the basket in exchange for basket tokens. Taken
	// credits will be immediately retired, unless disable_auto_retire is set to
	// true. When set to true, credits may be received in either a tradable or
	// retired state, depending on the taker's request. If the basket fee
	// governance parameter is set, a fee of equal or greater value must be
	// provided in the request. Only the amount specified in the fee parameter
	// will be charged, even if a greater value fee is provided. Fees from
	// creating a basket are burned.
	Create(context.Context, *MsgCreate) (*MsgCreateResponse, error)
	// Put deposits credits into the basket from the holder's tradable balance in
	// exchange for basket tokens. The amount of tokens received is calculated by
	// the following formula: sum(credits_deposited) * 10^credit_type_exponent.
	// The credits being deposited MUST adhere to the criteria of the basket.
	Put(context.Context, *MsgPut) (*MsgPutResponse, error)
	// Take exchanges basket tokens for credits from the specified basket. Credits
	// are taken deterministically, ordered by oldest batch start date to the most
	// recent batch start date. If the basket has disable_auto_retire set to
	// false, both retirement_jurisdiction and retire_on_take must be set, and the
	// taken credits will be retired immediately upon receipt. Otherwise, credits
	// may be received as tradable or retired, based on the request.
	Take(context.Context, *MsgTake) (*MsgTakeResponse, error)
	// UpdateBasketFee is a governance method that allows for updating the basket
	// creation fee. If not set, the basket creation fee will be removed and no
	// fee will be required to create a basket.
	//
	// Since Revision 2
	UpdateBasketFee(context.Context, *MsgUpdateBasketFee) (*MsgUpdateBasketFeeResponse, error)
	// UpdateCurator updates basket curator.
	//
	// Since Revision 2
	UpdateCurator(context.Context, *MsgUpdateCurator) (*MsgUpdateCuratorResponse, error)
	// UpdateDateCriteria is a governance method that allows for updating the date
	// criteria of a basket. Updating basket date criteria could affect the value
	// of basket tokens and therefore requires a network-wide governance process.
	//
	// Since Revision 3
	UpdateDateCriteria(context.Context, *MsgUpdateDateCriteria) (*MsgUpdateDateCriteriaResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) Create(ctx context.Context, req *MsgCreate) (*MsgCreateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (*UnimplementedMsgServer) Put(ctx context.Context, req *MsgPut) (*MsgPutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Put not implemented")
}
func (*UnimplementedMsgServer) Take(ctx context.Context, req *MsgTake) (*MsgTakeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Take not implemented")
}
func (*UnimplementedMsgServer) UpdateBasketFee(ctx context.Context, req *MsgUpdateBasketFee) (*MsgUpdateBasketFeeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateBasketFee not implemented")
}
func (*UnimplementedMsgServer) UpdateCurator(ctx context.Context, req *MsgUpdateCurator) (*MsgUpdateCuratorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCurator not implemented")
}
func (*UnimplementedMsgServer) UpdateDateCriteria(ctx context.Context, req *MsgUpdateDateCriteria) (*MsgUpdateDateCriteriaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateDateCriteria not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.basket.v1.Msg/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Create(ctx, req.(*MsgCreate))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Put_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgPut)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Put(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.basket.v1.Msg/Put",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Put(ctx, req.(*MsgPut))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Take_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgTake)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Take(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.basket.v1.Msg/Take",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Take(ctx, req.(*MsgTake))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateBasketFee_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateBasketFee)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateBasketFee(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.basket.v1.Msg/UpdateBasketFee",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateBasketFee(ctx, req.(*MsgUpdateBasketFee))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateCurator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateCurator)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateCurator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.basket.v1.Msg/UpdateCurator",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateCurator(ctx, req.(*MsgUpdateCurator))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateDateCriteria_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateDateCriteria)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateDateCriteria(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.basket.v1.Msg/UpdateDateCriteria",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateDateCriteria(ctx, req.(*MsgUpdateDateCriteria))
	}
	return interceptor(ctx, in, info, handler)
}

var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "regen.ecocredit.basket.v1.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _Msg_Create_Handler,
		},
		{
			MethodName: "Put",
			Handler:    _Msg_Put_Handler,
		},
		{
			MethodName: "Take",
			Handler:    _Msg_Take_Handler,
		},
		{
			MethodName: "UpdateBasketFee",
			Handler:    _Msg_UpdateBasketFee_Handler,
		},
		{
			MethodName: "UpdateCurator",
			Handler:    _Msg_UpdateCurator_Handler,
		},
		{
			MethodName: "UpdateDateCriteria",
			Handler:    _Msg_UpdateDateCriteria_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "regen/ecocredit/basket/v1/tx.proto",
}

func (m *MsgCreate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Fee) > 0 {
		for iNdEx := len(m.Fee) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Fee[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.DateCriteria != nil {
		{
			size, err := m.DateCriteria.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.AllowedClasses) > 0 {
		for iNdEx := len(m.AllowedClasses) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AllowedClasses[iNdEx])
			copy(dAtA[i:], m.AllowedClasses[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.AllowedClasses[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.CreditTypeAbbrev) > 0 {
		i -= len(m.CreditTypeAbbrev)
		copy(dAtA[i:], m.CreditTypeAbbrev)
		i = encodeVarintTx(dAtA, i, uint64(len(m.CreditTypeAbbrev)))
		i--
		dAtA[i] = 0x32
	}
	if m.DisableAutoRetire {
		i--
		if m.DisableAutoRetire {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Exponent != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Exponent))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Curator) > 0 {
		i -= len(m.Curator)
		copy(dAtA[i:], m.Curator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Curator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BasketDenom) > 0 {
		i -= len(m.BasketDenom)
		copy(dAtA[i:], m.BasketDenom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.BasketDenom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgPut) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPut) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPut) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Credits) > 0 {
		for iNdEx := len(m.Credits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Credits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.BasketDenom) > 0 {
		i -= len(m.BasketDenom)
		copy(dAtA[i:], m.BasketDenom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.BasketDenom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgPutResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPutResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPutResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AmountReceived) > 0 {
		i -= len(m.AmountReceived)
		copy(dAtA[i:], m.AmountReceived)
		i = encodeVarintTx(dAtA, i, uint64(len(m.AmountReceived)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgTake) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgTake) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgTake) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RetirementReason) > 0 {
		i -= len(m.RetirementReason)
		copy(dAtA[i:], m.RetirementReason)
		i = encodeVarintTx(dAtA, i, uint64(len(m.RetirementReason)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.RetirementJurisdiction) > 0 {
		i -= len(m.RetirementJurisdiction)
		copy(dAtA[i:], m.RetirementJurisdiction)
		i = encodeVarintTx(dAtA, i, uint64(len(m.RetirementJurisdiction)))
		i--
		dAtA[i] = 0x32
	}
	if m.RetireOnTake {
		i--
		if m.RetireOnTake {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.RetirementLocation) > 0 {
		i -= len(m.RetirementLocation)
		copy(dAtA[i:], m.RetirementLocation)
		i = encodeVarintTx(dAtA, i, uint64(len(m.RetirementLocation)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.BasketDenom) > 0 {
		i -= len(m.BasketDenom)
		copy(dAtA[i:], m.BasketDenom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.BasketDenom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgTakeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgTakeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgTakeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Credits) > 0 {
		for iNdEx := len(m.Credits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Credits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateBasketFee) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateBasketFee) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateBasketFee) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Fee != nil {
		{
			size, err := m.Fee.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateBasketFeeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateBasketFeeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateBasketFeeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgUpdateCurator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateCurator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateCurator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewCurator) > 0 {
		i -= len(m.NewCurator)
		copy(dAtA[i:], m.NewCurator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NewCurator)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Curator) > 0 {
		i -= len(m.Curator)
		copy(dAtA[i:], m.Curator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Curator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateCuratorResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateCuratorResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateCuratorResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgUpdateDateCriteria) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateDateCriteria) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateDateCriteria) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NewDateCriteria != nil {
		{
			size, err := m.NewDateCriteria.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateDateCriteriaResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateDateCriteriaResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateDateCriteriaResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgCreate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Curator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Exponent != 0 {
		n += 1 + sovTx(uint64(m.Exponent))
	}
	if m.DisableAutoRetire {
		n += 2
	}
	l = len(m.CreditTypeAbbrev)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.AllowedClasses) > 0 {
		for _, s := range m.AllowedClasses {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.DateCriteria != nil {
		l = m.DateCriteria.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Fee) > 0 {
		for _, e := range m.Fee {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgCreateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BasketDenom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgPut) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.BasketDenom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Credits) > 0 {
		for _, e := range m.Credits {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgPutResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AmountReceived)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgTake) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.BasketDenom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.RetirementLocation)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.RetireOnTake {
		n += 2
	}
	l = len(m.RetirementJurisdiction)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.RetirementReason)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgTakeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Credits) > 0 {
		for _, e := range m.Credits {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgUpdateBasketFee) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Fee != nil {
		l = m.Fee.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateBasketFeeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgUpdateCurator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Curator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.NewCurator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateCuratorResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgUpdateDateCriteria) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.NewDateCriteria != nil {
		l = m.NewDateCriteria.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateDateCriteriaResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgCreate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Curator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Curator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exponent", wireType)
			}
			m.Exponent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exponent |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableAutoRetire", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableAutoRetire = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreditTypeAbbrev", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreditTypeAbbrev = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedClasses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedClasses = append(m.AllowedClasses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateCriteria", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DateCriteria == nil {
				m.DateCriteria = &DateCriteria{}
			}
			if err := m.DateCriteria.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fee = append(m.Fee, types.Coin{})
			if err := m.Fee[len(m.Fee)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasketDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BasketDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPut) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPut: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPut: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasketDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BasketDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Credits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Credits = append(m.Credits, &BasketCredit{})
			if err := m.Credits[len(m.Credits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPutResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPutResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPutResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountReceived", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AmountReceived = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgTake) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgTake: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgTake: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasketDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BasketDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetirementLocation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetirementLocation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetireOnTake", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RetireOnTake = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetirementJurisdiction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetirementJurisdiction = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetirementReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetirementReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgTakeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgTakeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgTakeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Credits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Credits = append(m.Credits, &BasketCredit{})
			if err := m.Credits[len(m.Credits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateBasketFee) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateBasketFee: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateBasketFee: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fee == nil {
				m.Fee = &types.Coin{}
			}
			if err := m.Fee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateBasketFeeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateBasketFeeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateBasketFeeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateCurator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateCurator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateCurator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Curator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Curator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewCurator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewCurator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateCuratorResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateCuratorResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateCuratorResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateDateCriteria) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateDateCriteria: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateDateCriteria: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewDateCriteria", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NewDateCriteria == nil {
				m.NewDateCriteria = &DateCriteria{}
			}
			if err := m.NewDateCriteria.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateDateCriteriaResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateDateCriteriaResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateDateCriteriaResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
