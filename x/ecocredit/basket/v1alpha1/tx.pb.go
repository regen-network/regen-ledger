// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: regen/ecocredit/basket/v1alpha1/tx.proto

package v1alpha1

import (
	context "context"
	fmt "fmt"
	grpc1 "github.com/gogo/protobuf/grpc"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MsgCreateBasket is the Msg/CreateBasket request type.
type MsgCreateBasket struct {
	// curator is the address of the basket curator who is able to change certain
	// basket settings.
	Curator string `protobuf:"bytes,1,opt,name=curator,proto3" json:"curator,omitempty"`
	// name will be used to create a bank denom for this basket token of the form
	// ecocredit:{curator}:{name}.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// display_name will be used to create a bank Metadata display name for this
	// basket token of the form ecocredit:{curator}:{display_name}.
	DisplayName string `protobuf:"bytes,3,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	// exponent is the exponent that will be used for denom metadata. An exponent
	// of 6 will mean that 10^6 units of a basket token should be displayed
	// as one unit in user interfaces.
	Exponent uint32 `protobuf:"varint,4,opt,name=exponent,proto3" json:"exponent,omitempty"`
	// disable_auto_retire allows auto-retirement to be disabled.
	// The credits will be auto-retired if disable_auto_retire is
	// false unless the credits were previously put into the basket by the
	// address picking them from the basket, in which case they will remain
	// tradable.
	DisableAutoRetire bool `protobuf:"varint,5,opt,name=disable_auto_retire,json=disableAutoRetire,proto3" json:"disable_auto_retire,omitempty"`
	// credit_type_name filters against credits from this credit type name.
	CreditTypeName string           `protobuf:"bytes,6,opt,name=credit_type_name,json=creditTypeName,proto3" json:"credit_type_name,omitempty"`
	AllowedClasses []string         `protobuf:"bytes,7,rep,name=allowed_classes,json=allowedClasses,proto3" json:"allowed_classes,omitempty"`
	MinStartDate   *types.Timestamp `protobuf:"bytes,8,opt,name=min_start_date,json=minStartDate,proto3" json:"min_start_date,omitempty"`
	// multiplier is an integer number which is applied to credit units when
	// converting to basket units. For example if the multiplier is 2000, then
	// 1.1 credits will result in 2200 basket tokens. If there are any fractional
	// amounts left over in this calculation when adding credits to a basket,
	// those fractional amounts will not get added to the basket.
	Multiplier string `protobuf:"bytes,9,opt,name=multiplier,proto3" json:"multiplier,omitempty"`
}

func (m *MsgCreateBasket) Reset()         { *m = MsgCreateBasket{} }
func (m *MsgCreateBasket) String() string { return proto.CompactTextString(m) }
func (*MsgCreateBasket) ProtoMessage()    {}
func (*MsgCreateBasket) Descriptor() ([]byte, []int) {
	return fileDescriptor_5e8bc890392e7a4b, []int{0}
}
func (m *MsgCreateBasket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateBasket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateBasket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateBasket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateBasket.Merge(m, src)
}
func (m *MsgCreateBasket) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateBasket) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateBasket.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateBasket proto.InternalMessageInfo

func (m *MsgCreateBasket) GetCurator() string {
	if m != nil {
		return m.Curator
	}
	return ""
}

func (m *MsgCreateBasket) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MsgCreateBasket) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *MsgCreateBasket) GetExponent() uint32 {
	if m != nil {
		return m.Exponent
	}
	return 0
}

func (m *MsgCreateBasket) GetDisableAutoRetire() bool {
	if m != nil {
		return m.DisableAutoRetire
	}
	return false
}

func (m *MsgCreateBasket) GetCreditTypeName() string {
	if m != nil {
		return m.CreditTypeName
	}
	return ""
}

func (m *MsgCreateBasket) GetAllowedClasses() []string {
	if m != nil {
		return m.AllowedClasses
	}
	return nil
}

func (m *MsgCreateBasket) GetMinStartDate() *types.Timestamp {
	if m != nil {
		return m.MinStartDate
	}
	return nil
}

func (m *MsgCreateBasket) GetMultiplier() string {
	if m != nil {
		return m.Multiplier
	}
	return ""
}

// MsgCreateBasketResponse is the Msg/CreateBasket response type.
type MsgCreateBasketResponse struct {
	// basket_denom is the unique denomination ID of the newly created basket.
	BasketDenom string `protobuf:"bytes,1,opt,name=basket_denom,json=basketDenom,proto3" json:"basket_denom,omitempty"`
}

func (m *MsgCreateBasketResponse) Reset()         { *m = MsgCreateBasketResponse{} }
func (m *MsgCreateBasketResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateBasketResponse) ProtoMessage()    {}
func (*MsgCreateBasketResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5e8bc890392e7a4b, []int{1}
}
func (m *MsgCreateBasketResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateBasketResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateBasketResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateBasketResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateBasketResponse.Merge(m, src)
}
func (m *MsgCreateBasketResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateBasketResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateBasketResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateBasketResponse proto.InternalMessageInfo

func (m *MsgCreateBasketResponse) GetBasketDenom() string {
	if m != nil {
		return m.BasketDenom
	}
	return ""
}

// MsgAddToBasket is the Msg/AddToBasket request type.
type MsgAddToBasket struct {
	// owner is the owner of credits being added to the basket.
	Owner string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	// basket_denom is the basket denom to add credits to.
	BasketDenom string `protobuf:"bytes,2,opt,name=basket_denom,json=basketDenom,proto3" json:"basket_denom,omitempty"`
	// credits are credits to add to the basket. If they do not match the basket's
	// admission criteria the operation will fail.
	Credits []*BasketCredit `protobuf:"bytes,3,rep,name=credits,proto3" json:"credits,omitempty"`
}

func (m *MsgAddToBasket) Reset()         { *m = MsgAddToBasket{} }
func (m *MsgAddToBasket) String() string { return proto.CompactTextString(m) }
func (*MsgAddToBasket) ProtoMessage()    {}
func (*MsgAddToBasket) Descriptor() ([]byte, []int) {
	return fileDescriptor_5e8bc890392e7a4b, []int{2}
}
func (m *MsgAddToBasket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAddToBasket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAddToBasket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAddToBasket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAddToBasket.Merge(m, src)
}
func (m *MsgAddToBasket) XXX_Size() int {
	return m.Size()
}
func (m *MsgAddToBasket) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAddToBasket.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAddToBasket proto.InternalMessageInfo

func (m *MsgAddToBasket) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *MsgAddToBasket) GetBasketDenom() string {
	if m != nil {
		return m.BasketDenom
	}
	return ""
}

func (m *MsgAddToBasket) GetCredits() []*BasketCredit {
	if m != nil {
		return m.Credits
	}
	return nil
}

// MsgAddToBasketResponse is the Msg/AddToBasket response type.
type MsgAddToBasketResponse struct {
	// amount_received is the amount of basket tokens received.
	AmountReceived string `protobuf:"bytes,1,opt,name=amount_received,json=amountReceived,proto3" json:"amount_received,omitempty"`
}

func (m *MsgAddToBasketResponse) Reset()         { *m = MsgAddToBasketResponse{} }
func (m *MsgAddToBasketResponse) String() string { return proto.CompactTextString(m) }
func (*MsgAddToBasketResponse) ProtoMessage()    {}
func (*MsgAddToBasketResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5e8bc890392e7a4b, []int{3}
}
func (m *MsgAddToBasketResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAddToBasketResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAddToBasketResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAddToBasketResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAddToBasketResponse.Merge(m, src)
}
func (m *MsgAddToBasketResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgAddToBasketResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAddToBasketResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAddToBasketResponse proto.InternalMessageInfo

func (m *MsgAddToBasketResponse) GetAmountReceived() string {
	if m != nil {
		return m.AmountReceived
	}
	return ""
}

// MsgTakeFromBasket is the Msg/TakeFromBasket request type.
type MsgTakeFromBasket struct {
	// owner is the owner of the basket tokens.
	Owner string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	// basket_denom is the basket denom to take credits from.
	BasketDenom string `protobuf:"bytes,2,opt,name=basket_denom,json=basketDenom,proto3" json:"basket_denom,omitempty"`
	// amount is the number of credits to take from the basket.
	Amount string `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount,omitempty"`
	// retirement_location is the optional retirement location for the credits
	// which will be used only if retire_on_take is true for this basket.
	RetirementLocation string `protobuf:"bytes,4,opt,name=retirement_location,json=retirementLocation,proto3" json:"retirement_location,omitempty"`
}

func (m *MsgTakeFromBasket) Reset()         { *m = MsgTakeFromBasket{} }
func (m *MsgTakeFromBasket) String() string { return proto.CompactTextString(m) }
func (*MsgTakeFromBasket) ProtoMessage()    {}
func (*MsgTakeFromBasket) Descriptor() ([]byte, []int) {
	return fileDescriptor_5e8bc890392e7a4b, []int{4}
}
func (m *MsgTakeFromBasket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgTakeFromBasket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgTakeFromBasket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgTakeFromBasket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgTakeFromBasket.Merge(m, src)
}
func (m *MsgTakeFromBasket) XXX_Size() int {
	return m.Size()
}
func (m *MsgTakeFromBasket) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgTakeFromBasket.DiscardUnknown(m)
}

var xxx_messageInfo_MsgTakeFromBasket proto.InternalMessageInfo

func (m *MsgTakeFromBasket) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *MsgTakeFromBasket) GetBasketDenom() string {
	if m != nil {
		return m.BasketDenom
	}
	return ""
}

func (m *MsgTakeFromBasket) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *MsgTakeFromBasket) GetRetirementLocation() string {
	if m != nil {
		return m.RetirementLocation
	}
	return ""
}

// MsgTakeFromBasketResponse is the Msg/TakeFromBasket response type.
type MsgTakeFromBasketResponse struct {
	// credits are the credits taken out of the basket.
	Credits []*BasketCredit `protobuf:"bytes,1,rep,name=credits,proto3" json:"credits,omitempty"`
}

func (m *MsgTakeFromBasketResponse) Reset()         { *m = MsgTakeFromBasketResponse{} }
func (m *MsgTakeFromBasketResponse) String() string { return proto.CompactTextString(m) }
func (*MsgTakeFromBasketResponse) ProtoMessage()    {}
func (*MsgTakeFromBasketResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5e8bc890392e7a4b, []int{5}
}
func (m *MsgTakeFromBasketResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgTakeFromBasketResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgTakeFromBasketResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgTakeFromBasketResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgTakeFromBasketResponse.Merge(m, src)
}
func (m *MsgTakeFromBasketResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgTakeFromBasketResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgTakeFromBasketResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgTakeFromBasketResponse proto.InternalMessageInfo

func (m *MsgTakeFromBasketResponse) GetCredits() []*BasketCredit {
	if m != nil {
		return m.Credits
	}
	return nil
}

func init() {
	proto.RegisterType((*MsgCreateBasket)(nil), "regen.ecocredit.basket.v1alpha1.MsgCreateBasket")
	proto.RegisterType((*MsgCreateBasketResponse)(nil), "regen.ecocredit.basket.v1alpha1.MsgCreateBasketResponse")
	proto.RegisterType((*MsgAddToBasket)(nil), "regen.ecocredit.basket.v1alpha1.MsgAddToBasket")
	proto.RegisterType((*MsgAddToBasketResponse)(nil), "regen.ecocredit.basket.v1alpha1.MsgAddToBasketResponse")
	proto.RegisterType((*MsgTakeFromBasket)(nil), "regen.ecocredit.basket.v1alpha1.MsgTakeFromBasket")
	proto.RegisterType((*MsgTakeFromBasketResponse)(nil), "regen.ecocredit.basket.v1alpha1.MsgTakeFromBasketResponse")
}

func init() {
	proto.RegisterFile("regen/ecocredit/basket/v1alpha1/tx.proto", fileDescriptor_5e8bc890392e7a4b)
}

var fileDescriptor_5e8bc890392e7a4b = []byte{
	// 642 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x54, 0x4d, 0x6f, 0xd3, 0x4c,
	0x10, 0xae, 0x93, 0x7e, 0x6e, 0xfa, 0xa6, 0x6f, 0xb7, 0xa8, 0x18, 0x1f, 0xdc, 0x90, 0x0b, 0x96,
	0x50, 0x6d, 0x1a, 0x0e, 0x20, 0xc4, 0x81, 0xb4, 0x15, 0x5c, 0x08, 0x07, 0x93, 0x13, 0x1c, 0xac,
	0x8d, 0x3d, 0xb8, 0x56, 0xed, 0x5d, 0x6b, 0x77, 0xdd, 0xb4, 0x9c, 0xf8, 0x09, 0x08, 0x89, 0xff,
	0xc4, 0xb1, 0x47, 0x8e, 0xa8, 0xf9, 0x1d, 0x48, 0x28, 0xbb, 0xb6, 0x49, 0x5b, 0xa1, 0x36, 0xea,
	0xcd, 0xf3, 0xcc, 0x33, 0x5f, 0xcf, 0x8c, 0x17, 0x39, 0x1c, 0x62, 0xa0, 0x1e, 0x84, 0x2c, 0xe4,
	0x10, 0x25, 0xd2, 0x1b, 0x11, 0x71, 0x0c, 0xd2, 0x3b, 0xd9, 0x23, 0x69, 0x7e, 0x44, 0xf6, 0x3c,
	0x79, 0xea, 0xe6, 0x9c, 0x49, 0x86, 0x77, 0x14, 0xd3, 0xad, 0x99, 0xae, 0x66, 0xba, 0x15, 0xd3,
	0xda, 0x89, 0x19, 0x8b, 0x53, 0xf0, 0x14, 0x7d, 0x54, 0x7c, 0xf2, 0x64, 0x92, 0x81, 0x90, 0x24,
	0xcb, 0x75, 0x06, 0xeb, 0xf1, 0x8d, 0xb5, 0xce, 0x72, 0x10, 0x9a, 0xdc, 0x9d, 0x34, 0xd0, 0xc6,
	0x40, 0xc4, 0x07, 0x1c, 0x88, 0x84, 0x7d, 0x45, 0xc4, 0x26, 0x5a, 0x09, 0x0b, 0x4e, 0x24, 0xe3,
	0xa6, 0xd1, 0x31, 0x9c, 0x35, 0xbf, 0x32, 0x31, 0x46, 0x8b, 0x94, 0x64, 0x60, 0x36, 0x14, 0xac,
	0xbe, 0xf1, 0x43, 0xb4, 0x1e, 0x25, 0x22, 0x4f, 0xc9, 0x59, 0xa0, 0x7c, 0x4d, 0xe5, 0x6b, 0x95,
	0xd8, 0xbb, 0x29, 0xc5, 0x42, 0xab, 0x70, 0x9a, 0x33, 0x0a, 0x54, 0x9a, 0x8b, 0x1d, 0xc3, 0xf9,
	0xcf, 0xaf, 0x6d, 0xec, 0xa2, 0xad, 0x28, 0x11, 0x64, 0x94, 0x42, 0x40, 0x0a, 0xc9, 0x02, 0x0e,
	0x32, 0xe1, 0x60, 0x2e, 0x75, 0x0c, 0x67, 0xd5, 0xdf, 0x2c, 0x5d, 0xfd, 0x42, 0x32, 0x5f, 0x39,
	0xb0, 0x83, 0xfe, 0xd7, 0x63, 0x05, 0xd3, 0x31, 0x74, 0xc9, 0x65, 0x55, 0xb2, 0xad, 0xf1, 0xe1,
	0x59, 0x0e, 0xaa, 0xea, 0x23, 0xb4, 0x41, 0xd2, 0x94, 0x8d, 0x21, 0x0a, 0xc2, 0x94, 0x08, 0x01,
	0xc2, 0x5c, 0xe9, 0x34, 0xa7, 0xc4, 0x12, 0x3e, 0xd0, 0x28, 0x7e, 0x85, 0xda, 0x59, 0x42, 0x03,
	0x21, 0x09, 0x97, 0x41, 0x44, 0x24, 0x98, 0xab, 0x1d, 0xc3, 0x69, 0xf5, 0x2c, 0x57, 0x4b, 0xed,
	0x56, 0x52, 0xbb, 0xc3, 0x4a, 0x6a, 0x7f, 0x3d, 0x4b, 0xe8, 0xfb, 0x69, 0xc0, 0x21, 0x91, 0x80,
	0x6d, 0x84, 0xb2, 0x22, 0x95, 0x49, 0x9e, 0x26, 0xc0, 0xcd, 0x35, 0xd5, 0xce, 0x0c, 0xd2, 0x7d,
	0x89, 0xee, 0x5f, 0x11, 0xd9, 0x07, 0x91, 0x33, 0x2a, 0x94, 0x7c, 0x7a, 0x3f, 0x41, 0x04, 0x94,
	0x65, 0xa5, 0xe2, 0x2d, 0x8d, 0x1d, 0x4e, 0xa1, 0xee, 0x37, 0x03, 0xb5, 0x07, 0x22, 0xee, 0x47,
	0xd1, 0x90, 0x95, 0x2b, 0xba, 0x87, 0x96, 0xd8, 0x98, 0x42, 0xb5, 0x20, 0x6d, 0x5c, 0xcb, 0xd5,
	0xb8, 0x96, 0x0b, 0xbf, 0x41, 0x2b, 0x5a, 0x26, 0x61, 0x36, 0x3b, 0x4d, 0xa7, 0xd5, 0xdb, 0x75,
	0x6f, 0x38, 0x38, 0x57, 0x97, 0x3c, 0x50, 0x4e, 0xbf, 0x8a, 0xee, 0xf6, 0xd1, 0xf6, 0xe5, 0x9e,
	0xea, 0x89, 0xa6, 0xba, 0x67, 0xac, 0xa0, 0x32, 0xe0, 0x10, 0x42, 0x72, 0x02, 0x51, 0xd9, 0x65,
	0x5b, 0xc3, 0x7e, 0x89, 0x76, 0xbf, 0x1b, 0x68, 0x73, 0x20, 0xe2, 0x21, 0x39, 0x86, 0xd7, 0x9c,
	0x65, 0x77, 0x1d, 0x6d, 0x1b, 0x2d, 0xeb, 0x02, 0xe5, 0x09, 0x96, 0x16, 0xf6, 0xd0, 0x96, 0x3e,
	0xaa, 0x0c, 0xa8, 0x0c, 0x52, 0x16, 0x12, 0x99, 0x30, 0xaa, 0x0e, 0x71, 0xcd, 0xc7, 0x7f, 0x5d,
	0x6f, 0x4b, 0x4f, 0x37, 0x42, 0x0f, 0xae, 0xb5, 0x55, 0x4f, 0x37, 0x23, 0xa0, 0x71, 0x17, 0x01,
	0x7b, 0xbf, 0x1b, 0xa8, 0x39, 0x10, 0x31, 0xfe, 0x8c, 0xd6, 0x2f, 0xfd, 0x7d, 0x4f, 0x6e, 0xcc,
	0x77, 0xe5, 0x94, 0xac, 0xe7, 0xf3, 0x46, 0xd4, 0xc3, 0x8c, 0x51, 0x6b, 0xf6, 0xaa, 0xbc, 0xdb,
	0x24, 0x9a, 0x09, 0xb0, 0x9e, 0xcd, 0x19, 0x50, 0x17, 0xfe, 0x62, 0xa0, 0xf6, 0x95, 0xbd, 0xf7,
	0x6e, 0x93, 0xeb, 0x72, 0x8c, 0xf5, 0x62, 0xfe, 0x98, 0xaa, 0x85, 0xfd, 0x8f, 0x3f, 0x2e, 0x6c,
	0xe3, 0xfc, 0xc2, 0x36, 0x7e, 0x5d, 0xd8, 0xc6, 0xd7, 0x89, 0xbd, 0x70, 0x3e, 0xb1, 0x17, 0x7e,
	0x4e, 0xec, 0x85, 0x0f, 0xfd, 0x38, 0x91, 0x47, 0xc5, 0xc8, 0x0d, 0x59, 0xe6, 0xa9, 0xfc, 0xbb,
	0x14, 0xe4, 0x98, 0xf1, 0xe3, 0xd2, 0x4a, 0x21, 0x8a, 0x81, 0x7b, 0xa7, 0xff, 0x7e, 0x62, 0x47,
	0xcb, 0xea, 0xc9, 0x78, 0xfa, 0x27, 0x00, 0x00, 0xff, 0xff, 0x5d, 0xad, 0xb0, 0xe2, 0xf8, 0x05,
	0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	// CreateBasket creates a bank denom which wraps credits.
	CreateBasket(ctx context.Context, in *MsgCreateBasket, opts ...grpc.CallOption) (*MsgCreateBasketResponse, error)
	// AddToBasket adds credits to a basket in return for basket tokens.
	AddToBasket(ctx context.Context, in *MsgAddToBasket, opts ...grpc.CallOption) (*MsgAddToBasketResponse, error)
	// TakeFromBasket takes credits from a basket starting from the oldest
	// credits first.
	TakeFromBasket(ctx context.Context, in *MsgTakeFromBasket, opts ...grpc.CallOption) (*MsgTakeFromBasketResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) CreateBasket(ctx context.Context, in *MsgCreateBasket, opts ...grpc.CallOption) (*MsgCreateBasketResponse, error) {
	out := new(MsgCreateBasketResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.basket.v1alpha1.Msg/CreateBasket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) AddToBasket(ctx context.Context, in *MsgAddToBasket, opts ...grpc.CallOption) (*MsgAddToBasketResponse, error) {
	out := new(MsgAddToBasketResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.basket.v1alpha1.Msg/AddToBasket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) TakeFromBasket(ctx context.Context, in *MsgTakeFromBasket, opts ...grpc.CallOption) (*MsgTakeFromBasketResponse, error) {
	out := new(MsgTakeFromBasketResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.basket.v1alpha1.Msg/TakeFromBasket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	// CreateBasket creates a bank denom which wraps credits.
	CreateBasket(context.Context, *MsgCreateBasket) (*MsgCreateBasketResponse, error)
	// AddToBasket adds credits to a basket in return for basket tokens.
	AddToBasket(context.Context, *MsgAddToBasket) (*MsgAddToBasketResponse, error)
	// TakeFromBasket takes credits from a basket starting from the oldest
	// credits first.
	TakeFromBasket(context.Context, *MsgTakeFromBasket) (*MsgTakeFromBasketResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) CreateBasket(ctx context.Context, req *MsgCreateBasket) (*MsgCreateBasketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBasket not implemented")
}
func (*UnimplementedMsgServer) AddToBasket(ctx context.Context, req *MsgAddToBasket) (*MsgAddToBasketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddToBasket not implemented")
}
func (*UnimplementedMsgServer) TakeFromBasket(ctx context.Context, req *MsgTakeFromBasket) (*MsgTakeFromBasketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TakeFromBasket not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_CreateBasket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateBasket)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateBasket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.basket.v1alpha1.Msg/CreateBasket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateBasket(ctx, req.(*MsgCreateBasket))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_AddToBasket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgAddToBasket)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).AddToBasket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.basket.v1alpha1.Msg/AddToBasket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).AddToBasket(ctx, req.(*MsgAddToBasket))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_TakeFromBasket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgTakeFromBasket)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).TakeFromBasket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.basket.v1alpha1.Msg/TakeFromBasket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).TakeFromBasket(ctx, req.(*MsgTakeFromBasket))
	}
	return interceptor(ctx, in, info, handler)
}

var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "regen.ecocredit.basket.v1alpha1.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateBasket",
			Handler:    _Msg_CreateBasket_Handler,
		},
		{
			MethodName: "AddToBasket",
			Handler:    _Msg_AddToBasket_Handler,
		},
		{
			MethodName: "TakeFromBasket",
			Handler:    _Msg_TakeFromBasket_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "regen/ecocredit/basket/v1alpha1/tx.proto",
}

func (m *MsgCreateBasket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateBasket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateBasket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Multiplier) > 0 {
		i -= len(m.Multiplier)
		copy(dAtA[i:], m.Multiplier)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Multiplier)))
		i--
		dAtA[i] = 0x4a
	}
	if m.MinStartDate != nil {
		{
			size, err := m.MinStartDate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.AllowedClasses) > 0 {
		for iNdEx := len(m.AllowedClasses) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AllowedClasses[iNdEx])
			copy(dAtA[i:], m.AllowedClasses[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.AllowedClasses[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.CreditTypeName) > 0 {
		i -= len(m.CreditTypeName)
		copy(dAtA[i:], m.CreditTypeName)
		i = encodeVarintTx(dAtA, i, uint64(len(m.CreditTypeName)))
		i--
		dAtA[i] = 0x32
	}
	if m.DisableAutoRetire {
		i--
		if m.DisableAutoRetire {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Exponent != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Exponent))
		i--
		dAtA[i] = 0x20
	}
	if len(m.DisplayName) > 0 {
		i -= len(m.DisplayName)
		copy(dAtA[i:], m.DisplayName)
		i = encodeVarintTx(dAtA, i, uint64(len(m.DisplayName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Curator) > 0 {
		i -= len(m.Curator)
		copy(dAtA[i:], m.Curator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Curator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateBasketResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateBasketResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateBasketResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BasketDenom) > 0 {
		i -= len(m.BasketDenom)
		copy(dAtA[i:], m.BasketDenom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.BasketDenom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgAddToBasket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAddToBasket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAddToBasket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Credits) > 0 {
		for iNdEx := len(m.Credits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Credits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.BasketDenom) > 0 {
		i -= len(m.BasketDenom)
		copy(dAtA[i:], m.BasketDenom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.BasketDenom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgAddToBasketResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAddToBasketResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAddToBasketResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AmountReceived) > 0 {
		i -= len(m.AmountReceived)
		copy(dAtA[i:], m.AmountReceived)
		i = encodeVarintTx(dAtA, i, uint64(len(m.AmountReceived)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgTakeFromBasket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgTakeFromBasket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgTakeFromBasket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RetirementLocation) > 0 {
		i -= len(m.RetirementLocation)
		copy(dAtA[i:], m.RetirementLocation)
		i = encodeVarintTx(dAtA, i, uint64(len(m.RetirementLocation)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.BasketDenom) > 0 {
		i -= len(m.BasketDenom)
		copy(dAtA[i:], m.BasketDenom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.BasketDenom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgTakeFromBasketResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgTakeFromBasketResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgTakeFromBasketResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Credits) > 0 {
		for iNdEx := len(m.Credits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Credits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgCreateBasket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Curator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Exponent != 0 {
		n += 1 + sovTx(uint64(m.Exponent))
	}
	if m.DisableAutoRetire {
		n += 2
	}
	l = len(m.CreditTypeName)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.AllowedClasses) > 0 {
		for _, s := range m.AllowedClasses {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.MinStartDate != nil {
		l = m.MinStartDate.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Multiplier)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgCreateBasketResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BasketDenom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgAddToBasket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.BasketDenom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Credits) > 0 {
		for _, e := range m.Credits {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgAddToBasketResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AmountReceived)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgTakeFromBasket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.BasketDenom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.RetirementLocation)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgTakeFromBasketResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Credits) > 0 {
		for _, e := range m.Credits {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgCreateBasket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateBasket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateBasket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Curator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Curator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exponent", wireType)
			}
			m.Exponent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exponent |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableAutoRetire", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableAutoRetire = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreditTypeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreditTypeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedClasses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedClasses = append(m.AllowedClasses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinStartDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MinStartDate == nil {
				m.MinStartDate = &types.Timestamp{}
			}
			if err := m.MinStartDate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Multiplier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Multiplier = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateBasketResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateBasketResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateBasketResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasketDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BasketDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAddToBasket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAddToBasket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAddToBasket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasketDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BasketDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Credits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Credits = append(m.Credits, &BasketCredit{})
			if err := m.Credits[len(m.Credits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAddToBasketResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAddToBasketResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAddToBasketResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountReceived", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AmountReceived = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgTakeFromBasket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgTakeFromBasket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgTakeFromBasket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasketDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BasketDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetirementLocation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetirementLocation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgTakeFromBasketResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgTakeFromBasketResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgTakeFromBasketResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Credits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Credits = append(m.Credits, &BasketCredit{})
			if err := m.Credits[len(m.Credits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
