// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: regen/ecocredit/basket/v1beta1/types.proto

package v1beta1

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// BasketCredit represents the information for a credit batch inside a basket.
type BasketCredit struct {
	// batch_denom is the unique ID of the credit batch.
	BatchDenom string `protobuf:"bytes,1,opt,name=batch_denom,json=batchDenom,proto3" json:"batch_denom,omitempty"`
	// tradable_amount is the number of credits in this transfer that can be
	// traded by the recipient. Decimal values are acceptable within the
	// precision returned by Query/Precision.
	TradableAmount string `protobuf:"bytes,2,opt,name=tradable_amount,json=tradableAmount,proto3" json:"tradable_amount,omitempty"`
}

func (m *BasketCredit) Reset()         { *m = BasketCredit{} }
func (m *BasketCredit) String() string { return proto.CompactTextString(m) }
func (*BasketCredit) ProtoMessage()    {}
func (*BasketCredit) Descriptor() ([]byte, []int) {
	return fileDescriptor_685ac2fc3638ac99, []int{0}
}
func (m *BasketCredit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BasketCredit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BasketCredit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BasketCredit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BasketCredit.Merge(m, src)
}
func (m *BasketCredit) XXX_Size() int {
	return m.Size()
}
func (m *BasketCredit) XXX_DiscardUnknown() {
	xxx_messageInfo_BasketCredit.DiscardUnknown(m)
}

var xxx_messageInfo_BasketCredit proto.InternalMessageInfo

func (m *BasketCredit) GetBatchDenom() string {
	if m != nil {
		return m.BatchDenom
	}
	return ""
}

func (m *BasketCredit) GetTradableAmount() string {
	if m != nil {
		return m.TradableAmount
	}
	return ""
}

// BasketCriteria defines a criteria by which credits can be added to a basket.
type BasketCriteria struct {
	// filter defines condition(s) that credits should satisfy in order to be
	// added to the basket.
	Filter *Filter `protobuf:"bytes,1,opt,name=filter,proto3" json:"filter,omitempty"`
	// multiplier is an integer number which is applied to credit units when
	// converting to basket units. For example if the multiplier is 2000, then
	// 1.1 credits will result in 2200 basket tokens. If there are any fractional
	// amounts left over in this calculation when adding credits to a basket,
	// those fractional amounts will not get added to the basket.
	Multiplier string `protobuf:"bytes,2,opt,name=multiplier,proto3" json:"multiplier,omitempty"`
}

func (m *BasketCriteria) Reset()         { *m = BasketCriteria{} }
func (m *BasketCriteria) String() string { return proto.CompactTextString(m) }
func (*BasketCriteria) ProtoMessage()    {}
func (*BasketCriteria) Descriptor() ([]byte, []int) {
	return fileDescriptor_685ac2fc3638ac99, []int{1}
}
func (m *BasketCriteria) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BasketCriteria) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BasketCriteria.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BasketCriteria) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BasketCriteria.Merge(m, src)
}
func (m *BasketCriteria) XXX_Size() int {
	return m.Size()
}
func (m *BasketCriteria) XXX_DiscardUnknown() {
	xxx_messageInfo_BasketCriteria.DiscardUnknown(m)
}

var xxx_messageInfo_BasketCriteria proto.InternalMessageInfo

func (m *BasketCriteria) GetFilter() *Filter {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *BasketCriteria) GetMultiplier() string {
	if m != nil {
		return m.Multiplier
	}
	return ""
}

// Filter defines condition(s) that credits should satisfy in order to be added
// to the basket. It can handled nested conditions linked with and/or operators.
type Filter struct {
	// sum is the oneof that specifies the type of filter.
	//
	// Types that are valid to be assigned to Sum:
	//	*Filter_And_
	//	*Filter_Or_
	//	*Filter_CreditTypeName
	//	*Filter_ClassId
	//	*Filter_ProjectId
	//	*Filter_BatchDenom
	//	*Filter_ClassAdmin
	//	*Filter_Issuer
	//	*Filter_Owner
	//	*Filter_ProjectLocation
	//	*Filter_DateRange_
	//	*Filter_Tag
	Sum isFilter_Sum `protobuf_oneof:"sum"`
}

func (m *Filter) Reset()         { *m = Filter{} }
func (m *Filter) String() string { return proto.CompactTextString(m) }
func (*Filter) ProtoMessage()    {}
func (*Filter) Descriptor() ([]byte, []int) {
	return fileDescriptor_685ac2fc3638ac99, []int{2}
}
func (m *Filter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Filter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Filter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Filter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Filter.Merge(m, src)
}
func (m *Filter) XXX_Size() int {
	return m.Size()
}
func (m *Filter) XXX_DiscardUnknown() {
	xxx_messageInfo_Filter.DiscardUnknown(m)
}

var xxx_messageInfo_Filter proto.InternalMessageInfo

type isFilter_Sum interface {
	isFilter_Sum()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Filter_And_ struct {
	And *Filter_And `protobuf:"bytes,1,opt,name=and,proto3,oneof" json:"and,omitempty"`
}
type Filter_Or_ struct {
	Or *Filter_Or `protobuf:"bytes,2,opt,name=or,proto3,oneof" json:"or,omitempty"`
}
type Filter_CreditTypeName struct {
	CreditTypeName string `protobuf:"bytes,3,opt,name=credit_type_name,json=creditTypeName,proto3,oneof" json:"credit_type_name,omitempty"`
}
type Filter_ClassId struct {
	ClassId string `protobuf:"bytes,4,opt,name=class_id,json=classId,proto3,oneof" json:"class_id,omitempty"`
}
type Filter_ProjectId struct {
	ProjectId string `protobuf:"bytes,5,opt,name=project_id,json=projectId,proto3,oneof" json:"project_id,omitempty"`
}
type Filter_BatchDenom struct {
	BatchDenom string `protobuf:"bytes,6,opt,name=batch_denom,json=batchDenom,proto3,oneof" json:"batch_denom,omitempty"`
}
type Filter_ClassAdmin struct {
	ClassAdmin string `protobuf:"bytes,7,opt,name=class_admin,json=classAdmin,proto3,oneof" json:"class_admin,omitempty"`
}
type Filter_Issuer struct {
	Issuer string `protobuf:"bytes,8,opt,name=issuer,proto3,oneof" json:"issuer,omitempty"`
}
type Filter_Owner struct {
	Owner string `protobuf:"bytes,9,opt,name=owner,proto3,oneof" json:"owner,omitempty"`
}
type Filter_ProjectLocation struct {
	ProjectLocation string `protobuf:"bytes,10,opt,name=project_location,json=projectLocation,proto3,oneof" json:"project_location,omitempty"`
}
type Filter_DateRange_ struct {
	DateRange *Filter_DateRange `protobuf:"bytes,11,opt,name=date_range,json=dateRange,proto3,oneof" json:"date_range,omitempty"`
}
type Filter_Tag struct {
	Tag string `protobuf:"bytes,12,opt,name=tag,proto3,oneof" json:"tag,omitempty"`
}

func (*Filter_And_) isFilter_Sum()            {}
func (*Filter_Or_) isFilter_Sum()             {}
func (*Filter_CreditTypeName) isFilter_Sum()  {}
func (*Filter_ClassId) isFilter_Sum()         {}
func (*Filter_ProjectId) isFilter_Sum()       {}
func (*Filter_BatchDenom) isFilter_Sum()      {}
func (*Filter_ClassAdmin) isFilter_Sum()      {}
func (*Filter_Issuer) isFilter_Sum()          {}
func (*Filter_Owner) isFilter_Sum()           {}
func (*Filter_ProjectLocation) isFilter_Sum() {}
func (*Filter_DateRange_) isFilter_Sum()      {}
func (*Filter_Tag) isFilter_Sum()             {}

func (m *Filter) GetSum() isFilter_Sum {
	if m != nil {
		return m.Sum
	}
	return nil
}

func (m *Filter) GetAnd() *Filter_And {
	if x, ok := m.GetSum().(*Filter_And_); ok {
		return x.And
	}
	return nil
}

func (m *Filter) GetOr() *Filter_Or {
	if x, ok := m.GetSum().(*Filter_Or_); ok {
		return x.Or
	}
	return nil
}

func (m *Filter) GetCreditTypeName() string {
	if x, ok := m.GetSum().(*Filter_CreditTypeName); ok {
		return x.CreditTypeName
	}
	return ""
}

func (m *Filter) GetClassId() string {
	if x, ok := m.GetSum().(*Filter_ClassId); ok {
		return x.ClassId
	}
	return ""
}

func (m *Filter) GetProjectId() string {
	if x, ok := m.GetSum().(*Filter_ProjectId); ok {
		return x.ProjectId
	}
	return ""
}

func (m *Filter) GetBatchDenom() string {
	if x, ok := m.GetSum().(*Filter_BatchDenom); ok {
		return x.BatchDenom
	}
	return ""
}

func (m *Filter) GetClassAdmin() string {
	if x, ok := m.GetSum().(*Filter_ClassAdmin); ok {
		return x.ClassAdmin
	}
	return ""
}

func (m *Filter) GetIssuer() string {
	if x, ok := m.GetSum().(*Filter_Issuer); ok {
		return x.Issuer
	}
	return ""
}

func (m *Filter) GetOwner() string {
	if x, ok := m.GetSum().(*Filter_Owner); ok {
		return x.Owner
	}
	return ""
}

func (m *Filter) GetProjectLocation() string {
	if x, ok := m.GetSum().(*Filter_ProjectLocation); ok {
		return x.ProjectLocation
	}
	return ""
}

func (m *Filter) GetDateRange() *Filter_DateRange {
	if x, ok := m.GetSum().(*Filter_DateRange_); ok {
		return x.DateRange
	}
	return nil
}

func (m *Filter) GetTag() string {
	if x, ok := m.GetSum().(*Filter_Tag); ok {
		return x.Tag
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Filter) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Filter_And_)(nil),
		(*Filter_Or_)(nil),
		(*Filter_CreditTypeName)(nil),
		(*Filter_ClassId)(nil),
		(*Filter_ProjectId)(nil),
		(*Filter_BatchDenom)(nil),
		(*Filter_ClassAdmin)(nil),
		(*Filter_Issuer)(nil),
		(*Filter_Owner)(nil),
		(*Filter_ProjectLocation)(nil),
		(*Filter_DateRange_)(nil),
		(*Filter_Tag)(nil),
	}
}

// And specifies an "and" condition between the list of filters.
type Filter_And struct {
	// filters is a list of filters where all conditions should be satisfied.
	Filters []*Filter `protobuf:"bytes,1,rep,name=filters,proto3" json:"filters,omitempty"`
}

func (m *Filter_And) Reset()         { *m = Filter_And{} }
func (m *Filter_And) String() string { return proto.CompactTextString(m) }
func (*Filter_And) ProtoMessage()    {}
func (*Filter_And) Descriptor() ([]byte, []int) {
	return fileDescriptor_685ac2fc3638ac99, []int{2, 0}
}
func (m *Filter_And) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Filter_And) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Filter_And.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Filter_And) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Filter_And.Merge(m, src)
}
func (m *Filter_And) XXX_Size() int {
	return m.Size()
}
func (m *Filter_And) XXX_DiscardUnknown() {
	xxx_messageInfo_Filter_And.DiscardUnknown(m)
}

var xxx_messageInfo_Filter_And proto.InternalMessageInfo

func (m *Filter_And) GetFilters() []*Filter {
	if m != nil {
		return m.Filters
	}
	return nil
}

// And specifies an "or" condition between the list of filters.
type Filter_Or struct {
	// filters is a list of filters where at least one of the conditions should be satisfied.
	Filters []*Filter `protobuf:"bytes,1,rep,name=filters,proto3" json:"filters,omitempty"`
}

func (m *Filter_Or) Reset()         { *m = Filter_Or{} }
func (m *Filter_Or) String() string { return proto.CompactTextString(m) }
func (*Filter_Or) ProtoMessage()    {}
func (*Filter_Or) Descriptor() ([]byte, []int) {
	return fileDescriptor_685ac2fc3638ac99, []int{2, 1}
}
func (m *Filter_Or) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Filter_Or) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Filter_Or.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Filter_Or) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Filter_Or.Merge(m, src)
}
func (m *Filter_Or) XXX_Size() int {
	return m.Size()
}
func (m *Filter_Or) XXX_DiscardUnknown() {
	xxx_messageInfo_Filter_Or.DiscardUnknown(m)
}

var xxx_messageInfo_Filter_Or proto.InternalMessageInfo

func (m *Filter_Or) GetFilters() []*Filter {
	if m != nil {
		return m.Filters
	}
	return nil
}

// DateRange defines a period for credit batches in a basket.
type Filter_DateRange struct {
	// start_date is the beginning of the period during which this credit batch
	// was quantified and verified. If it is empty then there is no start date
	// limit.
	StartDate *time.Time `protobuf:"bytes,7,opt,name=start_date,json=startDate,proto3,stdtime" json:"start_date,omitempty"`
	// end_date is the end of the period during which this credit batch was
	// quantified and verified. If it is empty then there is no end date
	// limit.
	EndDate *time.Time `protobuf:"bytes,8,opt,name=end_date,json=endDate,proto3,stdtime" json:"end_date,omitempty"`
}

func (m *Filter_DateRange) Reset()         { *m = Filter_DateRange{} }
func (m *Filter_DateRange) String() string { return proto.CompactTextString(m) }
func (*Filter_DateRange) ProtoMessage()    {}
func (*Filter_DateRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_685ac2fc3638ac99, []int{2, 2}
}
func (m *Filter_DateRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Filter_DateRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Filter_DateRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Filter_DateRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Filter_DateRange.Merge(m, src)
}
func (m *Filter_DateRange) XXX_Size() int {
	return m.Size()
}
func (m *Filter_DateRange) XXX_DiscardUnknown() {
	xxx_messageInfo_Filter_DateRange.DiscardUnknown(m)
}

var xxx_messageInfo_Filter_DateRange proto.InternalMessageInfo

func (m *Filter_DateRange) GetStartDate() *time.Time {
	if m != nil {
		return m.StartDate
	}
	return nil
}

func (m *Filter_DateRange) GetEndDate() *time.Time {
	if m != nil {
		return m.EndDate
	}
	return nil
}

func init() {
	proto.RegisterType((*BasketCredit)(nil), "regen.ecocredit.basket.v1beta1.BasketCredit")
	proto.RegisterType((*BasketCriteria)(nil), "regen.ecocredit.basket.v1beta1.BasketCriteria")
	proto.RegisterType((*Filter)(nil), "regen.ecocredit.basket.v1beta1.Filter")
	proto.RegisterType((*Filter_And)(nil), "regen.ecocredit.basket.v1beta1.Filter.And")
	proto.RegisterType((*Filter_Or)(nil), "regen.ecocredit.basket.v1beta1.Filter.Or")
	proto.RegisterType((*Filter_DateRange)(nil), "regen.ecocredit.basket.v1beta1.Filter.DateRange")
}

func init() {
	proto.RegisterFile("regen/ecocredit/basket/v1beta1/types.proto", fileDescriptor_685ac2fc3638ac99)
}

var fileDescriptor_685ac2fc3638ac99 = []byte{
	// 607 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x54, 0xcd, 0x4e, 0xdc, 0x3a,
	0x14, 0x9e, 0xcc, 0xc0, 0xfc, 0x9c, 0x41, 0x80, 0xac, 0xab, 0xab, 0x68, 0xae, 0x94, 0x01, 0x16,
	0xf7, 0xde, 0x52, 0x35, 0x29, 0x74, 0x89, 0x44, 0x99, 0x29, 0xa2, 0x20, 0x55, 0x45, 0x8d, 0x58,
	0x54, 0x6c, 0x22, 0x27, 0x3e, 0x84, 0x94, 0xc4, 0x8e, 0x1c, 0x4f, 0x29, 0x8f, 0xd0, 0x1d, 0x6f,
	0xd0, 0xd7, 0xe9, 0x92, 0x65, 0x77, 0xad, 0xe0, 0x45, 0x2a, 0x3b, 0x0e, 0xa2, 0x8b, 0x56, 0x53,
	0xa9, 0xbb, 0x9c, 0xef, 0xe7, 0xfc, 0xf8, 0xd8, 0x81, 0x4d, 0x89, 0x29, 0xf2, 0x00, 0x13, 0x91,
	0x48, 0x64, 0x99, 0x0a, 0x62, 0x5a, 0x5d, 0xa0, 0x0a, 0xde, 0x6f, 0xc5, 0xa8, 0xe8, 0x56, 0xa0,
	0xae, 0x4a, 0xac, 0xfc, 0x52, 0x0a, 0x25, 0x88, 0x67, 0xb4, 0xfe, 0xbd, 0xd6, 0xaf, 0xb5, 0xbe,
	0xd5, 0x8e, 0xfe, 0x4a, 0x45, 0x2a, 0x8c, 0x34, 0xd0, 0x5f, 0xb5, 0x6b, 0x34, 0x4e, 0x85, 0x48,
	0x73, 0x0c, 0x4c, 0x14, 0xcf, 0xce, 0x02, 0x95, 0x15, 0x58, 0x29, 0x5a, 0x94, 0xb5, 0x60, 0xe3,
	0x2d, 0x2c, 0x4d, 0x4d, 0xa2, 0x17, 0x26, 0x2b, 0x19, 0xc3, 0x30, 0xa6, 0x2a, 0x39, 0x8f, 0x18,
	0x72, 0x51, 0xb8, 0xce, 0x9a, 0xf3, 0xff, 0x20, 0x04, 0x03, 0xed, 0x6b, 0x84, 0xfc, 0x07, 0x2b,
	0x4a, 0x52, 0x46, 0xe3, 0x1c, 0x23, 0x5a, 0x88, 0x19, 0x57, 0x6e, 0xdb, 0x88, 0x96, 0x1b, 0x78,
	0x62, 0xd0, 0x8d, 0x12, 0x96, 0x9b, 0xcc, 0x99, 0x42, 0x99, 0x51, 0xb2, 0x0b, 0xdd, 0xb3, 0x2c,
	0x57, 0x28, 0x4d, 0xda, 0xe1, 0xf6, 0xbf, 0xfe, 0xaf, 0x67, 0xf2, 0x0f, 0x8c, 0x3a, 0xb4, 0x2e,
	0xe2, 0x01, 0x14, 0xb3, 0x5c, 0x65, 0x65, 0x9e, 0xa1, 0xb4, 0x55, 0x1f, 0x20, 0x1b, 0x9f, 0xba,
	0xd0, 0xad, 0x2d, 0x64, 0x17, 0x3a, 0x94, 0x33, 0x5b, 0x67, 0x73, 0xbe, 0x3a, 0xfe, 0x84, 0xb3,
	0xc3, 0x56, 0xa8, 0x8d, 0x64, 0x07, 0xda, 0xa2, 0x2e, 0x31, 0xdc, 0x7e, 0x34, 0xa7, 0xfd, 0x58,
	0x1e, 0xb6, 0xc2, 0xb6, 0x90, 0x64, 0x13, 0x56, 0x6b, 0x61, 0xa4, 0x17, 0x18, 0x71, 0x5a, 0xa0,
	0xdb, 0xd1, 0xdd, 0x1e, 0xb6, 0xc2, 0xe5, 0x9a, 0x39, 0xb9, 0x2a, 0xf1, 0x35, 0x2d, 0x90, 0xfc,
	0x03, 0xfd, 0x24, 0xa7, 0x55, 0x15, 0x65, 0xcc, 0x5d, 0xb0, 0x9a, 0x9e, 0x41, 0x8e, 0x18, 0x19,
	0x03, 0x94, 0x52, 0xbc, 0xc3, 0x44, 0x69, 0x7a, 0xd1, 0xd2, 0x03, 0x8b, 0x1d, 0x31, 0xb2, 0xfe,
	0xe3, 0xb6, 0xba, 0x56, 0xf1, 0x70, 0x5f, 0xeb, 0x30, 0xac, 0x0b, 0x50, 0x56, 0x64, 0xdc, 0xed,
	0x35, 0x12, 0x03, 0x4e, 0x34, 0x46, 0x5c, 0xe8, 0x66, 0x55, 0x35, 0x43, 0xe9, 0xf6, 0x2d, 0x6b,
	0x63, 0xf2, 0x37, 0x2c, 0x8a, 0x4b, 0x8e, 0xd2, 0x1d, 0x58, 0xa2, 0x0e, 0xc9, 0x63, 0x58, 0x6d,
	0x1a, 0xcb, 0x45, 0x42, 0x55, 0x26, 0xb8, 0x0b, 0x56, 0xb2, 0x62, 0x99, 0x57, 0x96, 0x20, 0x6f,
	0x00, 0x18, 0x55, 0x18, 0x49, 0xca, 0x53, 0x74, 0x87, 0xe6, 0x4c, 0x9f, 0xce, 0x79, 0xa6, 0xfb,
	0x54, 0x61, 0xa8, 0x7d, 0x7a, 0x6e, 0xd6, 0x04, 0x84, 0x40, 0x47, 0xd1, 0xd4, 0x5d, 0xb2, 0x25,
	0x75, 0x30, 0x7a, 0x09, 0x9d, 0x09, 0x67, 0x64, 0x0f, 0x7a, 0xf5, 0x75, 0xa9, 0x5c, 0x67, 0xad,
	0xf3, 0x1b, 0xb7, 0xac, 0xb1, 0x8d, 0x0e, 0xa0, 0x7d, 0x2c, 0xff, 0x40, 0x9e, 0x8f, 0x0e, 0x0c,
	0xee, 0xfb, 0x27, 0xcf, 0x01, 0x2a, 0x45, 0xa5, 0x8a, 0xf4, 0x14, 0x66, 0x0d, 0xc3, 0xed, 0x91,
	0x5f, 0x3f, 0x4f, 0xbf, 0x79, 0x9e, 0xfe, 0x49, 0xf3, 0x3c, 0xa7, 0x0b, 0xd7, 0x5f, 0xc7, 0x4e,
	0x38, 0x30, 0x1e, 0x9d, 0x85, 0xec, 0x40, 0x1f, 0x39, 0xab, 0xed, 0xfd, 0x39, 0xed, 0x3d, 0xe4,
	0x4c, 0x9b, 0xa7, 0x8b, 0xd0, 0xa9, 0x66, 0xc5, 0xf4, 0xf4, 0xf3, 0xad, 0xe7, 0xdc, 0xdc, 0x7a,
	0xce, 0xb7, 0x5b, 0xcf, 0xb9, 0xbe, 0xf3, 0x5a, 0x37, 0x77, 0x5e, 0xeb, 0xcb, 0x9d, 0xd7, 0x3a,
	0xdd, 0x4b, 0x33, 0x75, 0x3e, 0x8b, 0xfd, 0x44, 0x14, 0x81, 0x99, 0xf3, 0x09, 0x47, 0x75, 0x29,
	0xe4, 0x85, 0x8d, 0x72, 0x64, 0x29, 0xca, 0xe0, 0xc3, 0x4f, 0x7f, 0x56, 0x71, 0xd7, 0x74, 0xf1,
	0xec, 0x7b, 0x00, 0x00, 0x00, 0xff, 0xff, 0xba, 0x40, 0x92, 0x11, 0xd5, 0x04, 0x00, 0x00,
}

func (m *BasketCredit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BasketCredit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BasketCredit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TradableAmount) > 0 {
		i -= len(m.TradableAmount)
		copy(dAtA[i:], m.TradableAmount)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TradableAmount)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.BatchDenom) > 0 {
		i -= len(m.BatchDenom)
		copy(dAtA[i:], m.BatchDenom)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BatchDenom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BasketCriteria) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BasketCriteria) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BasketCriteria) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Multiplier) > 0 {
		i -= len(m.Multiplier)
		copy(dAtA[i:], m.Multiplier)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Multiplier)))
		i--
		dAtA[i] = 0x12
	}
	if m.Filter != nil {
		{
			size, err := m.Filter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Filter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Filter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Filter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Sum != nil {
		{
			size := m.Sum.Size()
			i -= size
			if _, err := m.Sum.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Filter_And_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Filter_And_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.And != nil {
		{
			size, err := m.And.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Filter_Or_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Filter_Or_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Or != nil {
		{
			size, err := m.Or.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Filter_CreditTypeName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Filter_CreditTypeName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.CreditTypeName)
	copy(dAtA[i:], m.CreditTypeName)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.CreditTypeName)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *Filter_ClassId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Filter_ClassId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ClassId)
	copy(dAtA[i:], m.ClassId)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ClassId)))
	i--
	dAtA[i] = 0x22
	return len(dAtA) - i, nil
}
func (m *Filter_ProjectId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Filter_ProjectId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ProjectId)
	copy(dAtA[i:], m.ProjectId)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ProjectId)))
	i--
	dAtA[i] = 0x2a
	return len(dAtA) - i, nil
}
func (m *Filter_BatchDenom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Filter_BatchDenom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.BatchDenom)
	copy(dAtA[i:], m.BatchDenom)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.BatchDenom)))
	i--
	dAtA[i] = 0x32
	return len(dAtA) - i, nil
}
func (m *Filter_ClassAdmin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Filter_ClassAdmin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ClassAdmin)
	copy(dAtA[i:], m.ClassAdmin)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ClassAdmin)))
	i--
	dAtA[i] = 0x3a
	return len(dAtA) - i, nil
}
func (m *Filter_Issuer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Filter_Issuer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Issuer)
	copy(dAtA[i:], m.Issuer)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Issuer)))
	i--
	dAtA[i] = 0x42
	return len(dAtA) - i, nil
}
func (m *Filter_Owner) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Filter_Owner) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Owner)
	copy(dAtA[i:], m.Owner)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Owner)))
	i--
	dAtA[i] = 0x4a
	return len(dAtA) - i, nil
}
func (m *Filter_ProjectLocation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Filter_ProjectLocation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ProjectLocation)
	copy(dAtA[i:], m.ProjectLocation)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ProjectLocation)))
	i--
	dAtA[i] = 0x52
	return len(dAtA) - i, nil
}
func (m *Filter_DateRange_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Filter_DateRange_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DateRange != nil {
		{
			size, err := m.DateRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *Filter_Tag) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Filter_Tag) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Tag)
	copy(dAtA[i:], m.Tag)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Tag)))
	i--
	dAtA[i] = 0x62
	return len(dAtA) - i, nil
}
func (m *Filter_And) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Filter_And) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Filter_And) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Filters) > 0 {
		for iNdEx := len(m.Filters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Filters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Filter_Or) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Filter_Or) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Filter_Or) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Filters) > 0 {
		for iNdEx := len(m.Filters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Filters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Filter_DateRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Filter_DateRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Filter_DateRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EndDate != nil {
		n5, err5 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.EndDate, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.EndDate):])
		if err5 != nil {
			return 0, err5
		}
		i -= n5
		i = encodeVarintTypes(dAtA, i, uint64(n5))
		i--
		dAtA[i] = 0x42
	}
	if m.StartDate != nil {
		n6, err6 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.StartDate, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.StartDate):])
		if err6 != nil {
			return 0, err6
		}
		i -= n6
		i = encodeVarintTypes(dAtA, i, uint64(n6))
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *BasketCredit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BatchDenom)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.TradableAmount)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *BasketCriteria) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Filter != nil {
		l = m.Filter.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Multiplier)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Filter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sum != nil {
		n += m.Sum.Size()
	}
	return n
}

func (m *Filter_And_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.And != nil {
		l = m.And.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Filter_Or_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Or != nil {
		l = m.Or.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Filter_CreditTypeName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CreditTypeName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *Filter_ClassId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClassId)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *Filter_ProjectId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProjectId)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *Filter_BatchDenom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BatchDenom)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *Filter_ClassAdmin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClassAdmin)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *Filter_Issuer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Issuer)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *Filter_Owner) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *Filter_ProjectLocation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProjectLocation)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *Filter_DateRange_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DateRange != nil {
		l = m.DateRange.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Filter_Tag) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Tag)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *Filter_And) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Filters) > 0 {
		for _, e := range m.Filters {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *Filter_Or) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Filters) > 0 {
		for _, e := range m.Filters {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *Filter_DateRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartDate != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.StartDate)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.EndDate != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.EndDate)
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BasketCredit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BasketCredit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BasketCredit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradableAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TradableAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BasketCriteria) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BasketCriteria: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BasketCriteria: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filter == nil {
				m.Filter = &Filter{}
			}
			if err := m.Filter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Multiplier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Multiplier = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Filter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Filter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Filter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field And", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Filter_And{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Sum = &Filter_And_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Or", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Filter_Or{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Sum = &Filter_Or_{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreditTypeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sum = &Filter_CreditTypeName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sum = &Filter_ClassId{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sum = &Filter_ProjectId{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sum = &Filter_BatchDenom{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassAdmin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sum = &Filter_ClassAdmin{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issuer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sum = &Filter_Issuer{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sum = &Filter_Owner{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectLocation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sum = &Filter_ProjectLocation{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Filter_DateRange{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Sum = &Filter_DateRange_{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sum = &Filter_Tag{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Filter_And) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: And: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: And: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filters = append(m.Filters, &Filter{})
			if err := m.Filters[len(m.Filters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Filter_Or) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Or: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Or: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filters = append(m.Filters, &Filter{})
			if err := m.Filters[len(m.Filters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Filter_DateRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DateRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DateRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartDate == nil {
				m.StartDate = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.StartDate, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndDate == nil {
				m.EndDate = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.EndDate, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
