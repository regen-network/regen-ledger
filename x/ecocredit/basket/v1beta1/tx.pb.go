// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: regen/ecocredit/basket/v1beta1/tx.proto

package v1beta1

import (
	context "context"
	fmt "fmt"
	grpc1 "github.com/gogo/protobuf/grpc"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MsgCreateBasket is the Msg/CreateBasket request type.
type MsgCreateBasket struct {
	// curator is the address of the basket curator who is able to change certain
	// basket settings.
	Curator string `protobuf:"bytes,1,opt,name=curator,proto3" json:"curator,omitempty"`
	// name will be used to create a bank denom for this basket token of the form
	// ecocredit:{curator}:{name}.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// display_name will be used to create a bank Metadata display name for this
	// basket token of the form ecocredit:{curator}:{display_name}.
	DisplayName string `protobuf:"bytes,3,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	// exponent is the exponent that will be used for denom metadata. An exponent
	// of 6 will mean that 10^6 units of a basket token should be displayed
	// as one unit in user interfaces.
	Exponent uint32 `protobuf:"varint,4,opt,name=exponent,proto3" json:"exponent,omitempty"`
	// basket_criteria is the criteria by which credits can be added to the
	// basket. Basket criteria will be applied in order and the first criteria
	// which applies to a credit will determine its multiplier in the basket.
	BasketCriteria []*BasketCriteria `protobuf:"bytes,5,rep,name=basket_criteria,json=basketCriteria,proto3" json:"basket_criteria,omitempty"`
	// disable_auto_retire allows auto-retirement to be disabled.
	// The credits will be auto-retired if disable_auto_retire is
	// false unless the credits were previously put into the basket by the
	// address picking them from the basket, in which case they will remain
	// tradable.
	DisableAutoRetire bool `protobuf:"varint,6,opt,name=disable_auto_retire,json=disableAutoRetire,proto3" json:"disable_auto_retire,omitempty"`
	// allow_picking specifies whether an address which didn't deposit the credits
	// in the basket can pick those credits or not.
	AllowPicking bool `protobuf:"varint,7,opt,name=allow_picking,json=allowPicking,proto3" json:"allow_picking,omitempty"`
}

func (m *MsgCreateBasket) Reset()         { *m = MsgCreateBasket{} }
func (m *MsgCreateBasket) String() string { return proto.CompactTextString(m) }
func (*MsgCreateBasket) ProtoMessage()    {}
func (*MsgCreateBasket) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e55200bd8b36dca, []int{0}
}
func (m *MsgCreateBasket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateBasket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateBasket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateBasket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateBasket.Merge(m, src)
}
func (m *MsgCreateBasket) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateBasket) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateBasket.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateBasket proto.InternalMessageInfo

func (m *MsgCreateBasket) GetCurator() string {
	if m != nil {
		return m.Curator
	}
	return ""
}

func (m *MsgCreateBasket) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MsgCreateBasket) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *MsgCreateBasket) GetExponent() uint32 {
	if m != nil {
		return m.Exponent
	}
	return 0
}

func (m *MsgCreateBasket) GetBasketCriteria() []*BasketCriteria {
	if m != nil {
		return m.BasketCriteria
	}
	return nil
}

func (m *MsgCreateBasket) GetDisableAutoRetire() bool {
	if m != nil {
		return m.DisableAutoRetire
	}
	return false
}

func (m *MsgCreateBasket) GetAllowPicking() bool {
	if m != nil {
		return m.AllowPicking
	}
	return false
}

// MsgCreateBasketResponse is the Msg/CreateBasket response type.
type MsgCreateBasketResponse struct {
	// basket_denom is the unique denomination ID of the newly created basket.
	BasketDenom string `protobuf:"bytes,1,opt,name=basket_denom,json=basketDenom,proto3" json:"basket_denom,omitempty"`
}

func (m *MsgCreateBasketResponse) Reset()         { *m = MsgCreateBasketResponse{} }
func (m *MsgCreateBasketResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateBasketResponse) ProtoMessage()    {}
func (*MsgCreateBasketResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e55200bd8b36dca, []int{1}
}
func (m *MsgCreateBasketResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateBasketResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateBasketResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateBasketResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateBasketResponse.Merge(m, src)
}
func (m *MsgCreateBasketResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateBasketResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateBasketResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateBasketResponse proto.InternalMessageInfo

func (m *MsgCreateBasketResponse) GetBasketDenom() string {
	if m != nil {
		return m.BasketDenom
	}
	return ""
}

// MsgAddToBasket is the Msg/AddToBasket request type.
type MsgAddToBasket struct {
	// owner is the owner of credits being added to the basket.
	Owner string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	// basket_denom is the basket denom to add credits to.
	BasketDenom string `protobuf:"bytes,2,opt,name=basket_denom,json=basketDenom,proto3" json:"basket_denom,omitempty"`
	// credits are credits to add to the basket. If they do not match the basket's
	// admission criteria the operation will fail.
	Credits []*BasketCredit `protobuf:"bytes,3,rep,name=credits,proto3" json:"credits,omitempty"`
}

func (m *MsgAddToBasket) Reset()         { *m = MsgAddToBasket{} }
func (m *MsgAddToBasket) String() string { return proto.CompactTextString(m) }
func (*MsgAddToBasket) ProtoMessage()    {}
func (*MsgAddToBasket) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e55200bd8b36dca, []int{2}
}
func (m *MsgAddToBasket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAddToBasket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAddToBasket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAddToBasket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAddToBasket.Merge(m, src)
}
func (m *MsgAddToBasket) XXX_Size() int {
	return m.Size()
}
func (m *MsgAddToBasket) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAddToBasket.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAddToBasket proto.InternalMessageInfo

func (m *MsgAddToBasket) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *MsgAddToBasket) GetBasketDenom() string {
	if m != nil {
		return m.BasketDenom
	}
	return ""
}

func (m *MsgAddToBasket) GetCredits() []*BasketCredit {
	if m != nil {
		return m.Credits
	}
	return nil
}

// MsgAddToBasketResponse is the Msg/AddToBasket response type.
type MsgAddToBasketResponse struct {
	// amount_received is the amount of basket tokens received.
	AmountReceived string `protobuf:"bytes,1,opt,name=amount_received,json=amountReceived,proto3" json:"amount_received,omitempty"`
}

func (m *MsgAddToBasketResponse) Reset()         { *m = MsgAddToBasketResponse{} }
func (m *MsgAddToBasketResponse) String() string { return proto.CompactTextString(m) }
func (*MsgAddToBasketResponse) ProtoMessage()    {}
func (*MsgAddToBasketResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e55200bd8b36dca, []int{3}
}
func (m *MsgAddToBasketResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAddToBasketResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAddToBasketResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAddToBasketResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAddToBasketResponse.Merge(m, src)
}
func (m *MsgAddToBasketResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgAddToBasketResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAddToBasketResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAddToBasketResponse proto.InternalMessageInfo

func (m *MsgAddToBasketResponse) GetAmountReceived() string {
	if m != nil {
		return m.AmountReceived
	}
	return ""
}

// MsgTakeFromBasket is the Msg/TakeFromBasket request type.
type MsgTakeFromBasket struct {
	// owner is the owner of the basket tokens.
	Owner string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	// basket_denom is the basket denom to take credits from.
	BasketDenom string `protobuf:"bytes,2,opt,name=basket_denom,json=basketDenom,proto3" json:"basket_denom,omitempty"`
	// amount is the number of credits to take from the basket.
	Amount string `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount,omitempty"`
	// retirement_location is the optional retirement location for the credits
	// which will be used only if retire_on_take is true for this basket.
	RetirementLocation string `protobuf:"bytes,4,opt,name=retirement_location,json=retirementLocation,proto3" json:"retirement_location,omitempty"`
}

func (m *MsgTakeFromBasket) Reset()         { *m = MsgTakeFromBasket{} }
func (m *MsgTakeFromBasket) String() string { return proto.CompactTextString(m) }
func (*MsgTakeFromBasket) ProtoMessage()    {}
func (*MsgTakeFromBasket) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e55200bd8b36dca, []int{4}
}
func (m *MsgTakeFromBasket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgTakeFromBasket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgTakeFromBasket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgTakeFromBasket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgTakeFromBasket.Merge(m, src)
}
func (m *MsgTakeFromBasket) XXX_Size() int {
	return m.Size()
}
func (m *MsgTakeFromBasket) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgTakeFromBasket.DiscardUnknown(m)
}

var xxx_messageInfo_MsgTakeFromBasket proto.InternalMessageInfo

func (m *MsgTakeFromBasket) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *MsgTakeFromBasket) GetBasketDenom() string {
	if m != nil {
		return m.BasketDenom
	}
	return ""
}

func (m *MsgTakeFromBasket) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *MsgTakeFromBasket) GetRetirementLocation() string {
	if m != nil {
		return m.RetirementLocation
	}
	return ""
}

// MsgTakeFromBasketResponse is the Msg/TakeFromBasket response type.
type MsgTakeFromBasketResponse struct {
	// credits are the credits taken out of the basket.
	Credits []*BasketCredit `protobuf:"bytes,1,rep,name=credits,proto3" json:"credits,omitempty"`
}

func (m *MsgTakeFromBasketResponse) Reset()         { *m = MsgTakeFromBasketResponse{} }
func (m *MsgTakeFromBasketResponse) String() string { return proto.CompactTextString(m) }
func (*MsgTakeFromBasketResponse) ProtoMessage()    {}
func (*MsgTakeFromBasketResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e55200bd8b36dca, []int{5}
}
func (m *MsgTakeFromBasketResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgTakeFromBasketResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgTakeFromBasketResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgTakeFromBasketResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgTakeFromBasketResponse.Merge(m, src)
}
func (m *MsgTakeFromBasketResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgTakeFromBasketResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgTakeFromBasketResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgTakeFromBasketResponse proto.InternalMessageInfo

func (m *MsgTakeFromBasketResponse) GetCredits() []*BasketCredit {
	if m != nil {
		return m.Credits
	}
	return nil
}

// MsgPickFromBasket is the Msg/PickFromBasket request type.
type MsgPickFromBasket struct {
	// owner is the owner of the basket tokens.
	Owner string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	// basket_denom is the basket denom to pick credits from.
	BasketDenom string `protobuf:"bytes,2,opt,name=basket_denom,json=basketDenom,proto3" json:"basket_denom,omitempty"`
	// credits are the units of credits being picked from the basket
	Credits []*BasketCredit `protobuf:"bytes,3,rep,name=credits,proto3" json:"credits,omitempty"`
	// retirement_location is the optional retirement location for the credits
	// which will be used only if retire_on_take is true for this basket.
	RetirementLocation string `protobuf:"bytes,4,opt,name=retirement_location,json=retirementLocation,proto3" json:"retirement_location,omitempty"`
}

func (m *MsgPickFromBasket) Reset()         { *m = MsgPickFromBasket{} }
func (m *MsgPickFromBasket) String() string { return proto.CompactTextString(m) }
func (*MsgPickFromBasket) ProtoMessage()    {}
func (*MsgPickFromBasket) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e55200bd8b36dca, []int{6}
}
func (m *MsgPickFromBasket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPickFromBasket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPickFromBasket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPickFromBasket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPickFromBasket.Merge(m, src)
}
func (m *MsgPickFromBasket) XXX_Size() int {
	return m.Size()
}
func (m *MsgPickFromBasket) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPickFromBasket.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPickFromBasket proto.InternalMessageInfo

func (m *MsgPickFromBasket) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *MsgPickFromBasket) GetBasketDenom() string {
	if m != nil {
		return m.BasketDenom
	}
	return ""
}

func (m *MsgPickFromBasket) GetCredits() []*BasketCredit {
	if m != nil {
		return m.Credits
	}
	return nil
}

func (m *MsgPickFromBasket) GetRetirementLocation() string {
	if m != nil {
		return m.RetirementLocation
	}
	return ""
}

// MsgPickFromBasketResponse is the Msg/PickFromBasket response type.
type MsgPickFromBasketResponse struct {
}

func (m *MsgPickFromBasketResponse) Reset()         { *m = MsgPickFromBasketResponse{} }
func (m *MsgPickFromBasketResponse) String() string { return proto.CompactTextString(m) }
func (*MsgPickFromBasketResponse) ProtoMessage()    {}
func (*MsgPickFromBasketResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e55200bd8b36dca, []int{7}
}
func (m *MsgPickFromBasketResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPickFromBasketResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPickFromBasketResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPickFromBasketResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPickFromBasketResponse.Merge(m, src)
}
func (m *MsgPickFromBasketResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgPickFromBasketResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPickFromBasketResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPickFromBasketResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*MsgCreateBasket)(nil), "regen.ecocredit.basket.v1beta1.MsgCreateBasket")
	proto.RegisterType((*MsgCreateBasketResponse)(nil), "regen.ecocredit.basket.v1beta1.MsgCreateBasketResponse")
	proto.RegisterType((*MsgAddToBasket)(nil), "regen.ecocredit.basket.v1beta1.MsgAddToBasket")
	proto.RegisterType((*MsgAddToBasketResponse)(nil), "regen.ecocredit.basket.v1beta1.MsgAddToBasketResponse")
	proto.RegisterType((*MsgTakeFromBasket)(nil), "regen.ecocredit.basket.v1beta1.MsgTakeFromBasket")
	proto.RegisterType((*MsgTakeFromBasketResponse)(nil), "regen.ecocredit.basket.v1beta1.MsgTakeFromBasketResponse")
	proto.RegisterType((*MsgPickFromBasket)(nil), "regen.ecocredit.basket.v1beta1.MsgPickFromBasket")
	proto.RegisterType((*MsgPickFromBasketResponse)(nil), "regen.ecocredit.basket.v1beta1.MsgPickFromBasketResponse")
}

func init() {
	proto.RegisterFile("regen/ecocredit/basket/v1beta1/tx.proto", fileDescriptor_9e55200bd8b36dca)
}

var fileDescriptor_9e55200bd8b36dca = []byte{
	// 610 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x55, 0xcd, 0x6e, 0xd3, 0x40,
	0x10, 0xae, 0x9b, 0xfe, 0x6e, 0xda, 0x54, 0xdd, 0xa2, 0x62, 0x82, 0x64, 0x85, 0x70, 0x68, 0x84,
	0xc0, 0x56, 0x8b, 0x04, 0x42, 0xe2, 0x40, 0x5b, 0xd4, 0x13, 0x41, 0xc8, 0xaa, 0x84, 0xd4, 0x8b,
	0xb5, 0xb6, 0x47, 0xc6, 0x8a, 0xbd, 0x6b, 0xad, 0xd7, 0x6d, 0x7a, 0xe1, 0x19, 0xe0, 0xc0, 0x5b,
	0xf0, 0x1a, 0x48, 0x1c, 0x7b, 0xe4, 0x88, 0xda, 0x77, 0xe0, 0x8c, 0xb2, 0xbb, 0x31, 0x71, 0x02,
	0x34, 0x51, 0x7b, 0xcb, 0xcc, 0x7c, 0xf3, 0xf3, 0x7d, 0x33, 0xce, 0xa2, 0x1d, 0x0e, 0x11, 0x50,
	0x07, 0x02, 0x16, 0x70, 0x08, 0x63, 0xe1, 0xf8, 0x24, 0xef, 0x81, 0x70, 0x4e, 0x77, 0x7d, 0x10,
	0x64, 0xd7, 0x11, 0x7d, 0x3b, 0xe3, 0x4c, 0x30, 0x6c, 0x49, 0xa0, 0x5d, 0x02, 0x6d, 0x05, 0xb4,
	0x35, 0xb0, 0xf9, 0xe8, 0xba, 0x42, 0xe7, 0x19, 0xe4, 0xaa, 0x56, 0xfb, 0xeb, 0x3c, 0xda, 0xe8,
	0xe6, 0xd1, 0x21, 0x07, 0x22, 0xe0, 0x40, 0xe2, 0xb0, 0x89, 0x96, 0x83, 0x82, 0x13, 0xc1, 0xb8,
	0x69, 0xb4, 0x8c, 0xce, 0xaa, 0x3b, 0x34, 0x31, 0x46, 0x0b, 0x94, 0xa4, 0x60, 0xce, 0x4b, 0xb7,
	0xfc, 0x8d, 0x1f, 0xa0, 0xb5, 0x30, 0xce, 0xb3, 0x84, 0x9c, 0x7b, 0x32, 0x56, 0x93, 0xb1, 0xba,
	0xf6, 0xbd, 0x1d, 0x40, 0x9a, 0x68, 0x05, 0xfa, 0x19, 0xa3, 0x40, 0x85, 0xb9, 0xd0, 0x32, 0x3a,
	0xeb, 0x6e, 0x69, 0xe3, 0xf7, 0x68, 0x43, 0x8d, 0xe7, 0x05, 0x3c, 0x16, 0xc0, 0x63, 0x62, 0x2e,
	0xb6, 0x6a, 0x9d, 0xfa, 0x9e, 0x6d, 0xff, 0x9f, 0xa6, 0xad, 0xa6, 0x3d, 0xd4, 0x59, 0x6e, 0xc3,
	0xaf, 0xd8, 0xd8, 0x46, 0x5b, 0x61, 0x9c, 0x13, 0x3f, 0x01, 0x8f, 0x14, 0x82, 0x79, 0x1c, 0x44,
	0xcc, 0xc1, 0x5c, 0x6a, 0x19, 0x9d, 0x15, 0x77, 0x53, 0x87, 0xf6, 0x0b, 0xc1, 0x5c, 0x19, 0xc0,
	0x0f, 0xd1, 0x3a, 0x49, 0x12, 0x76, 0xe6, 0x65, 0x71, 0xd0, 0x8b, 0x69, 0x64, 0x2e, 0x4b, 0xe4,
	0x9a, 0x74, 0xbe, 0x53, 0xbe, 0xf6, 0x4b, 0x74, 0x77, 0x4c, 0x2d, 0x17, 0xf2, 0x8c, 0xd1, 0x5c,
	0xea, 0xa0, 0x89, 0x84, 0x40, 0x59, 0xaa, 0xa5, 0xab, 0x2b, 0xdf, 0xeb, 0x81, 0xab, 0xfd, 0xd9,
	0x40, 0x8d, 0x6e, 0x1e, 0xed, 0x87, 0xe1, 0x31, 0xd3, 0x5a, 0xdf, 0x41, 0x8b, 0xec, 0x8c, 0xc2,
	0x50, 0x69, 0x65, 0x4c, 0xd4, 0x9a, 0x9f, 0xa8, 0x85, 0x8f, 0xd0, 0xb2, 0x92, 0x25, 0x37, 0x6b,
	0x52, 0xaf, 0xc7, 0xd3, 0xea, 0x35, 0x88, 0xb9, 0xc3, 0xe4, 0xf6, 0x3e, 0xda, 0xae, 0x8e, 0x54,
	0x12, 0xda, 0x41, 0x1b, 0x24, 0x65, 0x05, 0x15, 0x1e, 0x87, 0x00, 0xe2, 0x53, 0x08, 0xf5, 0x90,
	0x0d, 0xe5, 0x76, 0xb5, 0xb7, 0xfd, 0xc5, 0x40, 0x9b, 0xdd, 0x3c, 0x3a, 0x26, 0x3d, 0x38, 0xe2,
	0x2c, 0xbd, 0x29, 0xb3, 0x6d, 0xb4, 0xa4, 0x1a, 0xe8, 0x53, 0xd2, 0x16, 0x76, 0xd0, 0x96, 0xda,
	0x61, 0x0a, 0x54, 0x78, 0x09, 0x0b, 0x88, 0x88, 0x19, 0x95, 0x07, 0xb5, 0xea, 0xe2, 0x3f, 0xa1,
	0x37, 0x3a, 0xd2, 0x0e, 0xd0, 0xbd, 0x89, 0xb1, 0x4a, 0x76, 0x23, 0xfa, 0x19, 0x37, 0xd1, 0xef,
	0x9b, 0x22, 0x3f, 0x38, 0x90, 0xdb, 0x20, 0x7f, 0x4b, 0x6b, 0x9d, 0x5d, 0xac, 0xfb, 0x52, 0xac,
	0x2a, 0x8d, 0xa1, 0x58, 0x7b, 0xbf, 0x6a, 0xa8, 0xd6, 0xcd, 0x23, 0xdc, 0x47, 0x6b, 0x95, 0x7f,
	0x0a, 0xe7, 0xba, 0xe1, 0xc6, 0x3e, 0x96, 0xe6, 0xf3, 0x19, 0x13, 0xca, 0x75, 0x15, 0xa8, 0x3e,
	0xfa, 0xd9, 0xd8, 0x53, 0xd4, 0x19, 0xc1, 0x37, 0x9f, 0xcd, 0x86, 0x2f, 0xdb, 0x7e, 0x44, 0x8d,
	0xb1, 0xb3, 0xde, 0x9d, 0xa2, 0x52, 0x35, 0xa5, 0xf9, 0x62, 0xe6, 0x94, 0xd1, 0xfe, 0x63, 0x97,
	0x35, 0x4d, 0xff, 0x6a, 0xca, 0x54, 0xfd, 0xff, 0xbe, 0xf8, 0x83, 0x93, 0xef, 0x97, 0x96, 0x71,
	0x71, 0x69, 0x19, 0x3f, 0x2f, 0x2d, 0xe3, 0xd3, 0x95, 0x35, 0x77, 0x71, 0x65, 0xcd, 0xfd, 0xb8,
	0xb2, 0xe6, 0x4e, 0x5e, 0x45, 0xb1, 0xf8, 0x50, 0xf8, 0x76, 0xc0, 0x52, 0x47, 0x96, 0x7f, 0x42,
	0x41, 0x9c, 0x31, 0xde, 0xd3, 0x56, 0x02, 0x61, 0x04, 0xdc, 0xe9, 0xff, 0xf3, 0x19, 0xf2, 0x97,
	0xe4, 0x0b, 0xf4, 0xf4, 0x77, 0x00, 0x00, 0x00, 0xff, 0xff, 0x8b, 0xb5, 0x84, 0x37, 0xf8, 0x06,
	0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	// CreateBasket creates a bank denom which wraps credits.
	CreateBasket(ctx context.Context, in *MsgCreateBasket, opts ...grpc.CallOption) (*MsgCreateBasketResponse, error)
	// AddToBasket adds credits to a basket in return for basket tokens.
	AddToBasket(ctx context.Context, in *MsgAddToBasket, opts ...grpc.CallOption) (*MsgAddToBasketResponse, error)
	// TakeFromBasket takes credits from a basket without regard for which
	// credits they are. The credits will be auto-retired if disable_auto_retire
	// is false. Credits will be chosen randomly using the previous block hash
	// as a consensus source of randomness.
	// More concretely, the implementation is as follows:
	// - take the previous block hash and convert it into an uint64,
	// - given the total number of different credits within the basket `n`, the
	//   first credits that will get picked correspond to: hash modulo n (in
	//   terms of order),
	// - then if we need to take more credits, we get some from the next one and
	//   so on.
	TakeFromBasket(ctx context.Context, in *MsgTakeFromBasket, opts ...grpc.CallOption) (*MsgTakeFromBasketResponse, error)
	// PickFromBasket picks specific credits from a basket. If allow_picking is
	// set to false, then only an address which deposited credits in the basket
	// can pick those credits. All other addresses will be blocked from picking
	// those credits. The credits will be auto-retired if disable_auto_retire is
	// false unless the credits were previously put into the basket by the
	// address picking them from the basket, in which case they will remain
	// tradable. This functionality allows the owner of a credit to have more
	// control over the credits they are putting in baskets then ordinary users
	// to deal with the scenario where basket tokens end up being worth
	// significantly less than the credits on their own.
	PickFromBasket(ctx context.Context, in *MsgPickFromBasket, opts ...grpc.CallOption) (*MsgPickFromBasketResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) CreateBasket(ctx context.Context, in *MsgCreateBasket, opts ...grpc.CallOption) (*MsgCreateBasketResponse, error) {
	out := new(MsgCreateBasketResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.basket.v1beta1.Msg/CreateBasket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) AddToBasket(ctx context.Context, in *MsgAddToBasket, opts ...grpc.CallOption) (*MsgAddToBasketResponse, error) {
	out := new(MsgAddToBasketResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.basket.v1beta1.Msg/AddToBasket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) TakeFromBasket(ctx context.Context, in *MsgTakeFromBasket, opts ...grpc.CallOption) (*MsgTakeFromBasketResponse, error) {
	out := new(MsgTakeFromBasketResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.basket.v1beta1.Msg/TakeFromBasket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) PickFromBasket(ctx context.Context, in *MsgPickFromBasket, opts ...grpc.CallOption) (*MsgPickFromBasketResponse, error) {
	out := new(MsgPickFromBasketResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.basket.v1beta1.Msg/PickFromBasket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	// CreateBasket creates a bank denom which wraps credits.
	CreateBasket(context.Context, *MsgCreateBasket) (*MsgCreateBasketResponse, error)
	// AddToBasket adds credits to a basket in return for basket tokens.
	AddToBasket(context.Context, *MsgAddToBasket) (*MsgAddToBasketResponse, error)
	// TakeFromBasket takes credits from a basket without regard for which
	// credits they are. The credits will be auto-retired if disable_auto_retire
	// is false. Credits will be chosen randomly using the previous block hash
	// as a consensus source of randomness.
	// More concretely, the implementation is as follows:
	// - take the previous block hash and convert it into an uint64,
	// - given the total number of different credits within the basket `n`, the
	//   first credits that will get picked correspond to: hash modulo n (in
	//   terms of order),
	// - then if we need to take more credits, we get some from the next one and
	//   so on.
	TakeFromBasket(context.Context, *MsgTakeFromBasket) (*MsgTakeFromBasketResponse, error)
	// PickFromBasket picks specific credits from a basket. If allow_picking is
	// set to false, then only an address which deposited credits in the basket
	// can pick those credits. All other addresses will be blocked from picking
	// those credits. The credits will be auto-retired if disable_auto_retire is
	// false unless the credits were previously put into the basket by the
	// address picking them from the basket, in which case they will remain
	// tradable. This functionality allows the owner of a credit to have more
	// control over the credits they are putting in baskets then ordinary users
	// to deal with the scenario where basket tokens end up being worth
	// significantly less than the credits on their own.
	PickFromBasket(context.Context, *MsgPickFromBasket) (*MsgPickFromBasketResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) CreateBasket(ctx context.Context, req *MsgCreateBasket) (*MsgCreateBasketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBasket not implemented")
}
func (*UnimplementedMsgServer) AddToBasket(ctx context.Context, req *MsgAddToBasket) (*MsgAddToBasketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddToBasket not implemented")
}
func (*UnimplementedMsgServer) TakeFromBasket(ctx context.Context, req *MsgTakeFromBasket) (*MsgTakeFromBasketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TakeFromBasket not implemented")
}
func (*UnimplementedMsgServer) PickFromBasket(ctx context.Context, req *MsgPickFromBasket) (*MsgPickFromBasketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PickFromBasket not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_CreateBasket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateBasket)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateBasket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.basket.v1beta1.Msg/CreateBasket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateBasket(ctx, req.(*MsgCreateBasket))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_AddToBasket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgAddToBasket)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).AddToBasket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.basket.v1beta1.Msg/AddToBasket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).AddToBasket(ctx, req.(*MsgAddToBasket))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_TakeFromBasket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgTakeFromBasket)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).TakeFromBasket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.basket.v1beta1.Msg/TakeFromBasket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).TakeFromBasket(ctx, req.(*MsgTakeFromBasket))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_PickFromBasket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgPickFromBasket)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).PickFromBasket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.basket.v1beta1.Msg/PickFromBasket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).PickFromBasket(ctx, req.(*MsgPickFromBasket))
	}
	return interceptor(ctx, in, info, handler)
}

var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "regen.ecocredit.basket.v1beta1.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateBasket",
			Handler:    _Msg_CreateBasket_Handler,
		},
		{
			MethodName: "AddToBasket",
			Handler:    _Msg_AddToBasket_Handler,
		},
		{
			MethodName: "TakeFromBasket",
			Handler:    _Msg_TakeFromBasket_Handler,
		},
		{
			MethodName: "PickFromBasket",
			Handler:    _Msg_PickFromBasket_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "regen/ecocredit/basket/v1beta1/tx.proto",
}

func (m *MsgCreateBasket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateBasket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateBasket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AllowPicking {
		i--
		if m.AllowPicking {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.DisableAutoRetire {
		i--
		if m.DisableAutoRetire {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.BasketCriteria) > 0 {
		for iNdEx := len(m.BasketCriteria) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BasketCriteria[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Exponent != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Exponent))
		i--
		dAtA[i] = 0x20
	}
	if len(m.DisplayName) > 0 {
		i -= len(m.DisplayName)
		copy(dAtA[i:], m.DisplayName)
		i = encodeVarintTx(dAtA, i, uint64(len(m.DisplayName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Curator) > 0 {
		i -= len(m.Curator)
		copy(dAtA[i:], m.Curator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Curator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateBasketResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateBasketResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateBasketResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BasketDenom) > 0 {
		i -= len(m.BasketDenom)
		copy(dAtA[i:], m.BasketDenom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.BasketDenom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgAddToBasket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAddToBasket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAddToBasket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Credits) > 0 {
		for iNdEx := len(m.Credits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Credits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.BasketDenom) > 0 {
		i -= len(m.BasketDenom)
		copy(dAtA[i:], m.BasketDenom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.BasketDenom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgAddToBasketResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAddToBasketResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAddToBasketResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AmountReceived) > 0 {
		i -= len(m.AmountReceived)
		copy(dAtA[i:], m.AmountReceived)
		i = encodeVarintTx(dAtA, i, uint64(len(m.AmountReceived)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgTakeFromBasket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgTakeFromBasket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgTakeFromBasket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RetirementLocation) > 0 {
		i -= len(m.RetirementLocation)
		copy(dAtA[i:], m.RetirementLocation)
		i = encodeVarintTx(dAtA, i, uint64(len(m.RetirementLocation)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.BasketDenom) > 0 {
		i -= len(m.BasketDenom)
		copy(dAtA[i:], m.BasketDenom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.BasketDenom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgTakeFromBasketResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgTakeFromBasketResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgTakeFromBasketResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Credits) > 0 {
		for iNdEx := len(m.Credits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Credits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MsgPickFromBasket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPickFromBasket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPickFromBasket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RetirementLocation) > 0 {
		i -= len(m.RetirementLocation)
		copy(dAtA[i:], m.RetirementLocation)
		i = encodeVarintTx(dAtA, i, uint64(len(m.RetirementLocation)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Credits) > 0 {
		for iNdEx := len(m.Credits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Credits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.BasketDenom) > 0 {
		i -= len(m.BasketDenom)
		copy(dAtA[i:], m.BasketDenom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.BasketDenom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgPickFromBasketResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPickFromBasketResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPickFromBasketResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgCreateBasket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Curator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Exponent != 0 {
		n += 1 + sovTx(uint64(m.Exponent))
	}
	if len(m.BasketCriteria) > 0 {
		for _, e := range m.BasketCriteria {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.DisableAutoRetire {
		n += 2
	}
	if m.AllowPicking {
		n += 2
	}
	return n
}

func (m *MsgCreateBasketResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BasketDenom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgAddToBasket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.BasketDenom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Credits) > 0 {
		for _, e := range m.Credits {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgAddToBasketResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AmountReceived)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgTakeFromBasket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.BasketDenom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.RetirementLocation)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgTakeFromBasketResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Credits) > 0 {
		for _, e := range m.Credits {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgPickFromBasket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.BasketDenom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Credits) > 0 {
		for _, e := range m.Credits {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	l = len(m.RetirementLocation)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgPickFromBasketResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgCreateBasket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateBasket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateBasket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Curator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Curator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exponent", wireType)
			}
			m.Exponent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exponent |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasketCriteria", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BasketCriteria = append(m.BasketCriteria, &BasketCriteria{})
			if err := m.BasketCriteria[len(m.BasketCriteria)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableAutoRetire", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableAutoRetire = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowPicking", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowPicking = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateBasketResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateBasketResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateBasketResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasketDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BasketDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAddToBasket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAddToBasket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAddToBasket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasketDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BasketDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Credits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Credits = append(m.Credits, &BasketCredit{})
			if err := m.Credits[len(m.Credits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAddToBasketResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAddToBasketResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAddToBasketResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountReceived", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AmountReceived = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgTakeFromBasket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgTakeFromBasket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgTakeFromBasket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasketDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BasketDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetirementLocation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetirementLocation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgTakeFromBasketResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgTakeFromBasketResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgTakeFromBasketResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Credits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Credits = append(m.Credits, &BasketCredit{})
			if err := m.Credits[len(m.Credits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPickFromBasket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPickFromBasket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPickFromBasket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasketDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BasketDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Credits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Credits = append(m.Credits, &BasketCredit{})
			if err := m.Credits[len(m.Credits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetirementLocation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetirementLocation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPickFromBasketResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPickFromBasketResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPickFromBasketResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
