// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: regen/ecocredit/basket/v1/tx.proto

package basket

import (
	context "context"
	fmt "fmt"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/cosmos-sdk/types/msgservice"
	_ "github.com/gogo/protobuf/gogoproto"
	grpc1 "github.com/gogo/protobuf/grpc"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MsgCreateBasket is the Msg/CreateBasket request type.
type MsgCreate struct {
	// curator is the address of the basket curator who is able to change certain
	// basket settings.
	Curator string `protobuf:"bytes,1,opt,name=curator,proto3" json:"curator,omitempty"`
	// name will be used to together with prefix to create a bank denom for this
	// basket token. It can be between 3-8 alphanumeric characters, with the
	// first character being alphabetic.
	//
	// The bank denom will be formed from name and credit type with the format
	// `eco.<prefix><credit_type_abbrev>.<name>` where prefix is the prefix of
	// a standard SI unit derived from credit type precision.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// description is a human-readable description of the basket denom that should
	// be at most 256 characters.
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// Deprecated (Since Revision 1): This field is no longer used and will be
	// removed in the next version. The value of credit type precision is always
	// used as the exponent when determining the prefix for basket denom, defining
	// bank denom metadata, and converting credits to/from basket tokens.
	Exponent uint32 `protobuf:"varint,4,opt,name=exponent,proto3" json:"exponent,omitempty"` // Deprecated: Do not use.
	// disable_auto_retire allows auto-retirement to be disabled.
	// The credits will be auto-retired if disable_auto_retire is
	// false unless the credits were previously put into the basket by the
	// address picking them from the basket, in which case they will remain
	// tradable.
	DisableAutoRetire bool `protobuf:"varint,5,opt,name=disable_auto_retire,json=disableAutoRetire,proto3" json:"disable_auto_retire,omitempty"`
	// credit_type_abbrev is the abbreviation of the credit type this basket is
	// able to hold.
	CreditTypeAbbrev string `protobuf:"bytes,6,opt,name=credit_type_abbrev,json=creditTypeAbbrev,proto3" json:"credit_type_abbrev,omitempty"`
	// allowed_classes are the credit classes allowed to be put in the basket
	AllowedClasses []string `protobuf:"bytes,7,rep,name=allowed_classes,json=allowedClasses,proto3" json:"allowed_classes,omitempty"`
	// date_criteria is the date criteria for batches admitted to the basket.
	// At most, only one of the fields in the date_criteria should be set.
	DateCriteria *DateCriteria `protobuf:"bytes,8,opt,name=date_criteria,json=dateCriteria,proto3" json:"date_criteria,omitempty"`
	// fee is the basket creation fee. A fee is not required if the list of fees
	// in Params.basket_fee is empty. The provided fee must be one of the fees
	// listed in Params.basket_fee. The provided amount can be greater than
	// or equal to the listed amount but the basket creator will only be charged
	// the listed amount (i.e. the minimum amount).
	//
	// Note (Since Revision 1): Although this field supports a list of fees, the
	// basket creator must provide no more than one fee (i.e. one Coin in a list
	// of Coins). Providing more than one fee will fail basic message validation.
	// This field will be updated to a single fee rather than a list of fees in
	// the next version to reflect these requirements.
	Fee github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,9,rep,name=fee,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"fee"`
}

func (m *MsgCreate) Reset()         { *m = MsgCreate{} }
func (m *MsgCreate) String() string { return proto.CompactTextString(m) }
func (*MsgCreate) ProtoMessage()    {}
func (*MsgCreate) Descriptor() ([]byte, []int) {
	return fileDescriptor_a60f962a3c61f018, []int{0}
}
func (m *MsgCreate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreate.Merge(m, src)
}
func (m *MsgCreate) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreate) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreate.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreate proto.InternalMessageInfo

func (m *MsgCreate) GetCurator() string {
	if m != nil {
		return m.Curator
	}
	return ""
}

func (m *MsgCreate) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MsgCreate) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

// Deprecated: Do not use.
func (m *MsgCreate) GetExponent() uint32 {
	if m != nil {
		return m.Exponent
	}
	return 0
}

func (m *MsgCreate) GetDisableAutoRetire() bool {
	if m != nil {
		return m.DisableAutoRetire
	}
	return false
}

func (m *MsgCreate) GetCreditTypeAbbrev() string {
	if m != nil {
		return m.CreditTypeAbbrev
	}
	return ""
}

func (m *MsgCreate) GetAllowedClasses() []string {
	if m != nil {
		return m.AllowedClasses
	}
	return nil
}

func (m *MsgCreate) GetDateCriteria() *DateCriteria {
	if m != nil {
		return m.DateCriteria
	}
	return nil
}

func (m *MsgCreate) GetFee() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.Fee
	}
	return nil
}

// MsgCreateBasketResponse is the Msg/CreateBasket response type.
type MsgCreateResponse struct {
	// basket_denom is the unique denomination ID of the newly created basket.
	BasketDenom string `protobuf:"bytes,1,opt,name=basket_denom,json=basketDenom,proto3" json:"basket_denom,omitempty"`
}

func (m *MsgCreateResponse) Reset()         { *m = MsgCreateResponse{} }
func (m *MsgCreateResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateResponse) ProtoMessage()    {}
func (*MsgCreateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a60f962a3c61f018, []int{1}
}
func (m *MsgCreateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateResponse.Merge(m, src)
}
func (m *MsgCreateResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateResponse proto.InternalMessageInfo

func (m *MsgCreateResponse) GetBasketDenom() string {
	if m != nil {
		return m.BasketDenom
	}
	return ""
}

// MsgAddToBasket is the Msg/AddToBasket request type.
type MsgPut struct {
	// owner is the owner of credits being put into the basket.
	Owner string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	// basket_denom is the basket denom to add credits to.
	BasketDenom string `protobuf:"bytes,2,opt,name=basket_denom,json=basketDenom,proto3" json:"basket_denom,omitempty"`
	// credits are credits to add to the basket. If they do not match the basket's
	// admission criteria the operation will fail. If there are any "dust" credits
	// left over when converting credits to basket tokens, these credits will
	// not be converted to basket tokens and instead remain with the owner.
	Credits []*BasketCredit `protobuf:"bytes,3,rep,name=credits,proto3" json:"credits,omitempty"`
}

func (m *MsgPut) Reset()         { *m = MsgPut{} }
func (m *MsgPut) String() string { return proto.CompactTextString(m) }
func (*MsgPut) ProtoMessage()    {}
func (*MsgPut) Descriptor() ([]byte, []int) {
	return fileDescriptor_a60f962a3c61f018, []int{2}
}
func (m *MsgPut) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPut) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPut.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPut) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPut.Merge(m, src)
}
func (m *MsgPut) XXX_Size() int {
	return m.Size()
}
func (m *MsgPut) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPut.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPut proto.InternalMessageInfo

func (m *MsgPut) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *MsgPut) GetBasketDenom() string {
	if m != nil {
		return m.BasketDenom
	}
	return ""
}

func (m *MsgPut) GetCredits() []*BasketCredit {
	if m != nil {
		return m.Credits
	}
	return nil
}

// MsgAddToBasketResponse is the Msg/AddToBasket response type.
type MsgPutResponse struct {
	// amount_received is the integer amount of basket tokens received.
	AmountReceived string `protobuf:"bytes,1,opt,name=amount_received,json=amountReceived,proto3" json:"amount_received,omitempty"`
}

func (m *MsgPutResponse) Reset()         { *m = MsgPutResponse{} }
func (m *MsgPutResponse) String() string { return proto.CompactTextString(m) }
func (*MsgPutResponse) ProtoMessage()    {}
func (*MsgPutResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a60f962a3c61f018, []int{3}
}
func (m *MsgPutResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPutResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPutResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPutResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPutResponse.Merge(m, src)
}
func (m *MsgPutResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgPutResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPutResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPutResponse proto.InternalMessageInfo

func (m *MsgPutResponse) GetAmountReceived() string {
	if m != nil {
		return m.AmountReceived
	}
	return ""
}

// MsgTakeFromBasket is the Msg/TakeFromBasket request type.
type MsgTake struct {
	// owner is the owner of the basket tokens.
	Owner string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	// basket_denom is the basket bank denom to take credits from.
	BasketDenom string `protobuf:"bytes,2,opt,name=basket_denom,json=basketDenom,proto3" json:"basket_denom,omitempty"`
	// amount is the integer number of basket tokens to convert into credits.
	Amount string `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount,omitempty"`
	// retirement_location is the optional retirement jurisdiction for the
	// credits which will be used only if retire_on_take is true for this basket.
	//
	// Deprecated (Since Revision 1): This field will be removed in the next
	// version in favor of retirement_jurisdiction. Only one of these need to be
	// set and retirement_jurisdiction will be used if both are set.
	RetirementLocation string `protobuf:"bytes,4,opt,name=retirement_location,json=retirementLocation,proto3" json:"retirement_location,omitempty"` // Deprecated: Do not use.
	// retire_on_take is a boolean that dictates whether the ecocredits
	// received in exchange for the basket tokens will be received as
	// retired or tradable credits.
	RetireOnTake bool `protobuf:"varint,5,opt,name=retire_on_take,json=retireOnTake,proto3" json:"retire_on_take,omitempty"`
	// retirement_jurisdiction is the optional retirement jurisdiction for the
	// credits which will be used only if retire_on_take is true for this basket.
	//
	// Since Revision 1
	RetirementJurisdiction string `protobuf:"bytes,6,opt,name=retirement_jurisdiction,json=retirementJurisdiction,proto3" json:"retirement_jurisdiction,omitempty"`
}

func (m *MsgTake) Reset()         { *m = MsgTake{} }
func (m *MsgTake) String() string { return proto.CompactTextString(m) }
func (*MsgTake) ProtoMessage()    {}
func (*MsgTake) Descriptor() ([]byte, []int) {
	return fileDescriptor_a60f962a3c61f018, []int{4}
}
func (m *MsgTake) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgTake) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgTake.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgTake) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgTake.Merge(m, src)
}
func (m *MsgTake) XXX_Size() int {
	return m.Size()
}
func (m *MsgTake) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgTake.DiscardUnknown(m)
}

var xxx_messageInfo_MsgTake proto.InternalMessageInfo

func (m *MsgTake) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *MsgTake) GetBasketDenom() string {
	if m != nil {
		return m.BasketDenom
	}
	return ""
}

func (m *MsgTake) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

// Deprecated: Do not use.
func (m *MsgTake) GetRetirementLocation() string {
	if m != nil {
		return m.RetirementLocation
	}
	return ""
}

func (m *MsgTake) GetRetireOnTake() bool {
	if m != nil {
		return m.RetireOnTake
	}
	return false
}

func (m *MsgTake) GetRetirementJurisdiction() string {
	if m != nil {
		return m.RetirementJurisdiction
	}
	return ""
}

// MsgTakeFromBasketResponse is the Msg/TakeFromBasket response type.
type MsgTakeResponse struct {
	// credits are the credits taken out of the basket.
	Credits []*BasketCredit `protobuf:"bytes,1,rep,name=credits,proto3" json:"credits,omitempty"`
}

func (m *MsgTakeResponse) Reset()         { *m = MsgTakeResponse{} }
func (m *MsgTakeResponse) String() string { return proto.CompactTextString(m) }
func (*MsgTakeResponse) ProtoMessage()    {}
func (*MsgTakeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a60f962a3c61f018, []int{5}
}
func (m *MsgTakeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgTakeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgTakeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgTakeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgTakeResponse.Merge(m, src)
}
func (m *MsgTakeResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgTakeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgTakeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgTakeResponse proto.InternalMessageInfo

func (m *MsgTakeResponse) GetCredits() []*BasketCredit {
	if m != nil {
		return m.Credits
	}
	return nil
}

// MsgUpdateBasketFee is the Msg/UpdateBasketFee request type.
// Since Revision 1
type MsgUpdateBasketFee struct {
	// authority is the address of the governance account.
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// basket_fee defines a list of coins fees that can be used in the basket creation fee.
	BasketFee github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,2,rep,name=basket_fee,json=basketFee,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"basket_fee"`
}

func (m *MsgUpdateBasketFee) Reset()         { *m = MsgUpdateBasketFee{} }
func (m *MsgUpdateBasketFee) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateBasketFee) ProtoMessage()    {}
func (*MsgUpdateBasketFee) Descriptor() ([]byte, []int) {
	return fileDescriptor_a60f962a3c61f018, []int{6}
}
func (m *MsgUpdateBasketFee) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateBasketFee) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateBasketFee.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateBasketFee) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateBasketFee.Merge(m, src)
}
func (m *MsgUpdateBasketFee) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateBasketFee) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateBasketFee.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateBasketFee proto.InternalMessageInfo

func (m *MsgUpdateBasketFee) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgUpdateBasketFee) GetBasketFee() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.BasketFee
	}
	return nil
}

// MsgUpdateBasketFeeResponse is the Msg/UpdateBasketFee response type.
// Since Revision 1
type MsgUpdateBasketFeeResponse struct {
}

func (m *MsgUpdateBasketFeeResponse) Reset()         { *m = MsgUpdateBasketFeeResponse{} }
func (m *MsgUpdateBasketFeeResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateBasketFeeResponse) ProtoMessage()    {}
func (*MsgUpdateBasketFeeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a60f962a3c61f018, []int{7}
}
func (m *MsgUpdateBasketFeeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateBasketFeeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateBasketFeeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateBasketFeeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateBasketFeeResponse.Merge(m, src)
}
func (m *MsgUpdateBasketFeeResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateBasketFeeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateBasketFeeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateBasketFeeResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*MsgCreate)(nil), "regen.ecocredit.basket.v1.MsgCreate")
	proto.RegisterType((*MsgCreateResponse)(nil), "regen.ecocredit.basket.v1.MsgCreateResponse")
	proto.RegisterType((*MsgPut)(nil), "regen.ecocredit.basket.v1.MsgPut")
	proto.RegisterType((*MsgPutResponse)(nil), "regen.ecocredit.basket.v1.MsgPutResponse")
	proto.RegisterType((*MsgTake)(nil), "regen.ecocredit.basket.v1.MsgTake")
	proto.RegisterType((*MsgTakeResponse)(nil), "regen.ecocredit.basket.v1.MsgTakeResponse")
	proto.RegisterType((*MsgUpdateBasketFee)(nil), "regen.ecocredit.basket.v1.MsgUpdateBasketFee")
	proto.RegisterType((*MsgUpdateBasketFeeResponse)(nil), "regen.ecocredit.basket.v1.MsgUpdateBasketFeeResponse")
}

func init() {
	proto.RegisterFile("regen/ecocredit/basket/v1/tx.proto", fileDescriptor_a60f962a3c61f018)
}

var fileDescriptor_a60f962a3c61f018 = []byte{
	// 822 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x55, 0xcd, 0x6e, 0xdb, 0x46,
	0x10, 0x36, 0x4d, 0x47, 0xb6, 0xc6, 0x8e, 0xdd, 0x6c, 0x82, 0x84, 0x11, 0x02, 0x46, 0x21, 0x52,
	0x44, 0x0d, 0x62, 0xb2, 0x76, 0xd0, 0xbf, 0xdc, 0x6c, 0x05, 0x3d, 0x14, 0x11, 0x1a, 0xb0, 0x6e,
	0x0f, 0x45, 0x0b, 0x62, 0x49, 0x4e, 0x19, 0x46, 0x22, 0x57, 0xd8, 0x5d, 0xca, 0xf6, 0xb5, 0xb7,
	0xde, 0xf2, 0x04, 0x7d, 0x80, 0x9e, 0xfa, 0x02, 0xbd, 0xe7, 0x98, 0x63, 0x4f, 0x6d, 0x61, 0x1f,
	0xfa, 0x0e, 0x3d, 0x15, 0xdc, 0x5d, 0xd2, 0x6a, 0x8c, 0x2a, 0xad, 0x91, 0x93, 0x76, 0xbe, 0xf9,
	0x66, 0x76, 0x66, 0xbe, 0x59, 0x11, 0x3c, 0x8e, 0x19, 0x96, 0x01, 0x26, 0x2c, 0xe1, 0x98, 0xe6,
	0x32, 0x88, 0xa9, 0x18, 0xa3, 0x0c, 0x66, 0x3b, 0x81, 0x3c, 0xf2, 0xa7, 0x9c, 0x49, 0x46, 0x6e,
	0x2a, 0x8e, 0xdf, 0x72, 0x7c, 0xcd, 0xf1, 0x67, 0x3b, 0x3d, 0x37, 0x61, 0xa2, 0x60, 0xa2, 0x8e,
	0xc2, 0x60, 0xb6, 0x13, 0xa3, 0xa4, 0x3b, 0x41, 0xc2, 0xf2, 0x52, 0x87, 0xf6, 0x6e, 0x18, 0x7f,
	0x21, 0xb2, 0x3a, 0x65, 0x21, 0x32, 0xe3, 0xb8, 0x96, 0xb1, 0x8c, 0xa9, 0x63, 0x50, 0x9f, 0x0c,
	0xfa, 0xee, 0x82, 0x6a, 0x8e, 0xa7, 0x28, 0x34, 0xcd, 0xfb, 0xc5, 0x86, 0xee, 0x48, 0x64, 0x43,
	0x8e, 0x54, 0x22, 0x71, 0x60, 0x35, 0xa9, 0x38, 0x95, 0x8c, 0x3b, 0x56, 0xdf, 0x1a, 0x74, 0xc3,
	0xc6, 0x24, 0x04, 0x56, 0x4a, 0x5a, 0xa0, 0xb3, 0xac, 0x60, 0x75, 0x26, 0x7d, 0x58, 0x4f, 0x51,
	0x24, 0x3c, 0x9f, 0xca, 0x9c, 0x95, 0x8e, 0xad, 0x5c, 0xf3, 0x10, 0x71, 0x61, 0x0d, 0x8f, 0xa6,
	0xac, 0xc4, 0x52, 0x3a, 0x2b, 0x7d, 0x6b, 0x70, 0x79, 0x7f, 0xd9, 0xb1, 0xc2, 0x16, 0x23, 0x3e,
	0x5c, 0x4d, 0x73, 0x41, 0xe3, 0x09, 0x46, 0xb4, 0x92, 0x2c, 0xe2, 0x28, 0x73, 0x8e, 0xce, 0xa5,
	0xbe, 0x35, 0x58, 0x0b, 0xaf, 0x18, 0xd7, 0x5e, 0x25, 0x59, 0xa8, 0x1c, 0xe4, 0x01, 0x10, 0xdd,
	0x4d, 0x54, 0xf7, 0x10, 0xd1, 0x38, 0xe6, 0x38, 0x73, 0x3a, 0xea, 0xe2, 0x77, 0xb4, 0xe7, 0xe0,
	0x78, 0x8a, 0x7b, 0x0a, 0x27, 0xf7, 0x60, 0x8b, 0x4e, 0x26, 0xec, 0x10, 0xd3, 0x28, 0x99, 0x50,
	0x21, 0x50, 0x38, 0xab, 0x7d, 0x7b, 0xd0, 0x0d, 0x37, 0x0d, 0x3c, 0xd4, 0x28, 0x79, 0x02, 0x97,
	0x53, 0x2a, 0x31, 0x4a, 0x78, 0x2e, 0x91, 0xe7, 0xd4, 0x59, 0xeb, 0x5b, 0x83, 0xf5, 0xdd, 0x7b,
	0xfe, 0xbf, 0xaa, 0xe5, 0x3f, 0xa6, 0x12, 0x87, 0x86, 0x1e, 0x6e, 0xa4, 0x73, 0x16, 0xf9, 0x16,
	0xec, 0xef, 0x10, 0x9d, 0x6e, 0xdf, 0x1e, 0xac, 0xef, 0xde, 0xf4, 0xb5, 0x6c, 0x75, 0x28, 0xfa,
	0x46, 0x56, 0x7f, 0xc8, 0xf2, 0x72, 0xff, 0xfd, 0x97, 0xbf, 0xdd, 0x5e, 0xfa, 0xe9, 0xf7, 0xdb,
	0x83, 0x2c, 0x97, 0xcf, 0xaa, 0xd8, 0x4f, 0x58, 0x11, 0x18, 0x8d, 0xf5, 0xcf, 0xb6, 0x48, 0xc7,
	0x46, 0xac, 0x3a, 0x40, 0x84, 0x75, 0xde, 0x47, 0x1b, 0xdf, 0xff, 0xf9, 0xf3, 0xfd, 0x46, 0x17,
	0xef, 0x43, 0xb8, 0xd2, 0xca, 0x17, 0xa2, 0x98, 0xb2, 0x52, 0x20, 0xb9, 0x03, 0x1b, 0xba, 0xd2,
	0x28, 0xc5, 0x92, 0x15, 0x46, 0xcb, 0x75, 0x8d, 0x3d, 0xae, 0x21, 0xef, 0x85, 0x05, 0x9d, 0x91,
	0xc8, 0x9e, 0x56, 0x92, 0x5c, 0x83, 0x4b, 0xec, 0xb0, 0xc4, 0x46, 0x72, 0x6d, 0x9c, 0xcb, 0xb1,
	0x7c, 0x2e, 0x07, 0xd9, 0x83, 0x55, 0x3d, 0x17, 0xe1, 0xd8, 0xaa, 0xd9, 0x45, 0x03, 0xdb, 0x57,
	0xa7, 0xa1, 0x82, 0xc3, 0x26, 0xee, 0x11, 0xd4, 0xcd, 0xe8, 0x1b, 0xbd, 0x4f, 0x60, 0x53, 0x57,
	0xd4, 0xf6, 0x51, 0x0b, 0x58, 0xb0, 0xaa, 0x94, 0x11, 0xc7, 0x04, 0xf3, 0x19, 0xa6, 0xa6, 0xc6,
	0x4d, 0x0d, 0x87, 0x06, 0xf5, 0xfe, 0xb2, 0x60, 0x75, 0x24, 0xb2, 0x03, 0x3a, 0xc6, 0x8b, 0xb7,
	0x73, 0x1d, 0x3a, 0x3a, 0xad, 0xd9, 0x64, 0x63, 0x91, 0x87, 0x70, 0x55, 0xef, 0x65, 0x81, 0xa5,
	0x8c, 0x26, 0x2c, 0xa1, 0x6a, 0xdd, 0xeb, 0x7d, 0xee, 0xaa, 0x7d, 0x26, 0x67, 0xee, 0x27, 0xc6,
	0x4b, 0xee, 0xc2, 0xa6, 0x46, 0x23, 0x56, 0x46, 0x92, 0x8e, 0x9b, 0xa5, 0xde, 0xd0, 0xe8, 0xe7,
	0xa5, 0xaa, 0xf5, 0x23, 0xb8, 0x31, 0x97, 0xfa, 0x79, 0xc5, 0x73, 0x91, 0xe6, 0x89, 0x4a, 0xaf,
	0x97, 0xfa, 0xfa, 0x99, 0xfb, 0xb3, 0x39, 0xef, 0x3f, 0xe6, 0x76, 0x00, 0x5b, 0xa6, 0xf7, 0x76,
	0x70, 0x73, 0xca, 0x58, 0x17, 0x53, 0xc6, 0xfb, 0xd1, 0x02, 0x32, 0x12, 0xd9, 0x97, 0xd3, 0x7a,
	0xb7, 0x35, 0xe5, 0x53, 0x44, 0x72, 0x0b, 0xba, 0xb4, 0x92, 0xcf, 0x18, 0xcf, 0xe5, 0xb1, 0x99,
	0xf0, 0x19, 0x40, 0x9e, 0x03, 0x98, 0x29, 0xd7, 0x2f, 0x60, 0xf9, 0xed, 0xbf, 0x80, 0x6e, 0xdc,
	0x54, 0xe2, 0xdd, 0x82, 0xde, 0xf9, 0xfa, 0x9a, 0x09, 0xec, 0xfe, 0x60, 0x83, 0x3d, 0x12, 0x19,
	0xf9, 0x06, 0x3a, 0xe6, 0xbf, 0xed, 0xee, 0x82, 0x11, 0xb4, 0x4f, 0xa8, 0xf7, 0xe0, 0xbf, 0xb0,
	0xda, 0x39, 0x7f, 0x01, 0x76, 0xfd, 0x82, 0xee, 0x2c, 0x0e, 0x7a, 0x5a, 0xc9, 0xde, 0x7b, 0x6f,
	0xa4, 0xb4, 0x49, 0xbf, 0x82, 0x15, 0xb5, 0x1c, 0xde, 0xe2, 0x90, 0x9a, 0xd3, 0xbb, 0xff, 0x66,
	0x4e, 0x9b, 0xf7, 0x10, 0xb6, 0x5e, 0x57, 0x73, 0x7b, 0x71, 0xf8, 0x6b, 0xf4, 0xde, 0x07, 0xff,
	0x8b, 0xde, 0x5c, 0xbc, 0x1f, 0xbe, 0x3c, 0x71, 0xad, 0x57, 0x27, 0xae, 0xf5, 0xc7, 0x89, 0x6b,
	0xbd, 0x38, 0x75, 0x97, 0x5e, 0x9d, 0xba, 0x4b, 0xbf, 0x9e, 0xba, 0x4b, 0x5f, 0x7f, 0x3c, 0x27,
	0xbc, 0x4a, 0xbd, 0x5d, 0xa2, 0x3c, 0x64, 0x7c, 0x6c, 0xac, 0x09, 0xa6, 0x19, 0xf2, 0xe0, 0xe8,
	0xdc, 0x67, 0x2c, 0xee, 0xa8, 0xcf, 0xd7, 0xc3, 0xbf, 0x03, 0x00, 0x00, 0xff, 0xff, 0xd4, 0x20,
	0xb6, 0x27, 0x75, 0x07, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	// Create creates a bank denom which wraps credits.
	Create(ctx context.Context, in *MsgCreate, opts ...grpc.CallOption) (*MsgCreateResponse, error)
	// Put puts credits into a basket in return for basket tokens.
	Put(ctx context.Context, in *MsgPut, opts ...grpc.CallOption) (*MsgPutResponse, error)
	// Take takes credits from a basket starting from the oldest
	// credits first.
	Take(ctx context.Context, in *MsgTake, opts ...grpc.CallOption) (*MsgTakeResponse, error)
	// UpdateClassFee is a governance method that allows for updation of fees to be
	// used for the basket creation fee.
	// Since Revision 1
	UpdateBasketFee(ctx context.Context, in *MsgUpdateBasketFee, opts ...grpc.CallOption) (*MsgUpdateBasketFeeResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) Create(ctx context.Context, in *MsgCreate, opts ...grpc.CallOption) (*MsgCreateResponse, error) {
	out := new(MsgCreateResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.basket.v1.Msg/Create", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Put(ctx context.Context, in *MsgPut, opts ...grpc.CallOption) (*MsgPutResponse, error) {
	out := new(MsgPutResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.basket.v1.Msg/Put", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Take(ctx context.Context, in *MsgTake, opts ...grpc.CallOption) (*MsgTakeResponse, error) {
	out := new(MsgTakeResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.basket.v1.Msg/Take", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateBasketFee(ctx context.Context, in *MsgUpdateBasketFee, opts ...grpc.CallOption) (*MsgUpdateBasketFeeResponse, error) {
	out := new(MsgUpdateBasketFeeResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.basket.v1.Msg/UpdateBasketFee", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	// Create creates a bank denom which wraps credits.
	Create(context.Context, *MsgCreate) (*MsgCreateResponse, error)
	// Put puts credits into a basket in return for basket tokens.
	Put(context.Context, *MsgPut) (*MsgPutResponse, error)
	// Take takes credits from a basket starting from the oldest
	// credits first.
	Take(context.Context, *MsgTake) (*MsgTakeResponse, error)
	// UpdateClassFee is a governance method that allows for updation of fees to be
	// used for the basket creation fee.
	// Since Revision 1
	UpdateBasketFee(context.Context, *MsgUpdateBasketFee) (*MsgUpdateBasketFeeResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) Create(ctx context.Context, req *MsgCreate) (*MsgCreateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (*UnimplementedMsgServer) Put(ctx context.Context, req *MsgPut) (*MsgPutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Put not implemented")
}
func (*UnimplementedMsgServer) Take(ctx context.Context, req *MsgTake) (*MsgTakeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Take not implemented")
}
func (*UnimplementedMsgServer) UpdateBasketFee(ctx context.Context, req *MsgUpdateBasketFee) (*MsgUpdateBasketFeeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateBasketFee not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.basket.v1.Msg/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Create(ctx, req.(*MsgCreate))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Put_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgPut)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Put(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.basket.v1.Msg/Put",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Put(ctx, req.(*MsgPut))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Take_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgTake)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Take(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.basket.v1.Msg/Take",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Take(ctx, req.(*MsgTake))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateBasketFee_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateBasketFee)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateBasketFee(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.basket.v1.Msg/UpdateBasketFee",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateBasketFee(ctx, req.(*MsgUpdateBasketFee))
	}
	return interceptor(ctx, in, info, handler)
}

var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "regen.ecocredit.basket.v1.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _Msg_Create_Handler,
		},
		{
			MethodName: "Put",
			Handler:    _Msg_Put_Handler,
		},
		{
			MethodName: "Take",
			Handler:    _Msg_Take_Handler,
		},
		{
			MethodName: "UpdateBasketFee",
			Handler:    _Msg_UpdateBasketFee_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "regen/ecocredit/basket/v1/tx.proto",
}

func (m *MsgCreate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Fee) > 0 {
		for iNdEx := len(m.Fee) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Fee[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.DateCriteria != nil {
		{
			size, err := m.DateCriteria.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.AllowedClasses) > 0 {
		for iNdEx := len(m.AllowedClasses) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AllowedClasses[iNdEx])
			copy(dAtA[i:], m.AllowedClasses[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.AllowedClasses[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.CreditTypeAbbrev) > 0 {
		i -= len(m.CreditTypeAbbrev)
		copy(dAtA[i:], m.CreditTypeAbbrev)
		i = encodeVarintTx(dAtA, i, uint64(len(m.CreditTypeAbbrev)))
		i--
		dAtA[i] = 0x32
	}
	if m.DisableAutoRetire {
		i--
		if m.DisableAutoRetire {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Exponent != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Exponent))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Curator) > 0 {
		i -= len(m.Curator)
		copy(dAtA[i:], m.Curator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Curator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BasketDenom) > 0 {
		i -= len(m.BasketDenom)
		copy(dAtA[i:], m.BasketDenom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.BasketDenom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgPut) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPut) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPut) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Credits) > 0 {
		for iNdEx := len(m.Credits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Credits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.BasketDenom) > 0 {
		i -= len(m.BasketDenom)
		copy(dAtA[i:], m.BasketDenom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.BasketDenom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgPutResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPutResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPutResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AmountReceived) > 0 {
		i -= len(m.AmountReceived)
		copy(dAtA[i:], m.AmountReceived)
		i = encodeVarintTx(dAtA, i, uint64(len(m.AmountReceived)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgTake) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgTake) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgTake) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RetirementJurisdiction) > 0 {
		i -= len(m.RetirementJurisdiction)
		copy(dAtA[i:], m.RetirementJurisdiction)
		i = encodeVarintTx(dAtA, i, uint64(len(m.RetirementJurisdiction)))
		i--
		dAtA[i] = 0x32
	}
	if m.RetireOnTake {
		i--
		if m.RetireOnTake {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.RetirementLocation) > 0 {
		i -= len(m.RetirementLocation)
		copy(dAtA[i:], m.RetirementLocation)
		i = encodeVarintTx(dAtA, i, uint64(len(m.RetirementLocation)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.BasketDenom) > 0 {
		i -= len(m.BasketDenom)
		copy(dAtA[i:], m.BasketDenom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.BasketDenom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgTakeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgTakeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgTakeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Credits) > 0 {
		for iNdEx := len(m.Credits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Credits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateBasketFee) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateBasketFee) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateBasketFee) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BasketFee) > 0 {
		for iNdEx := len(m.BasketFee) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BasketFee[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateBasketFeeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateBasketFeeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateBasketFeeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgCreate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Curator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Exponent != 0 {
		n += 1 + sovTx(uint64(m.Exponent))
	}
	if m.DisableAutoRetire {
		n += 2
	}
	l = len(m.CreditTypeAbbrev)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.AllowedClasses) > 0 {
		for _, s := range m.AllowedClasses {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.DateCriteria != nil {
		l = m.DateCriteria.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Fee) > 0 {
		for _, e := range m.Fee {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgCreateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BasketDenom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgPut) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.BasketDenom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Credits) > 0 {
		for _, e := range m.Credits {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgPutResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AmountReceived)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgTake) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.BasketDenom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.RetirementLocation)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.RetireOnTake {
		n += 2
	}
	l = len(m.RetirementJurisdiction)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgTakeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Credits) > 0 {
		for _, e := range m.Credits {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgUpdateBasketFee) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.BasketFee) > 0 {
		for _, e := range m.BasketFee {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgUpdateBasketFeeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgCreate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Curator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Curator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exponent", wireType)
			}
			m.Exponent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exponent |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableAutoRetire", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableAutoRetire = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreditTypeAbbrev", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreditTypeAbbrev = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedClasses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedClasses = append(m.AllowedClasses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateCriteria", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DateCriteria == nil {
				m.DateCriteria = &DateCriteria{}
			}
			if err := m.DateCriteria.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fee = append(m.Fee, types.Coin{})
			if err := m.Fee[len(m.Fee)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasketDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BasketDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPut) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPut: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPut: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasketDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BasketDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Credits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Credits = append(m.Credits, &BasketCredit{})
			if err := m.Credits[len(m.Credits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPutResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPutResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPutResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountReceived", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AmountReceived = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgTake) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgTake: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgTake: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasketDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BasketDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetirementLocation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetirementLocation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetireOnTake", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RetireOnTake = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetirementJurisdiction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetirementJurisdiction = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgTakeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgTakeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgTakeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Credits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Credits = append(m.Credits, &BasketCredit{})
			if err := m.Credits[len(m.Credits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateBasketFee) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateBasketFee: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateBasketFee: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasketFee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BasketFee = append(m.BasketFee, types.Coin{})
			if err := m.BasketFee[len(m.BasketFee)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateBasketFeeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateBasketFeeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateBasketFeeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
