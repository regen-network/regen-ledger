// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: regen/ecocredit/curation/v1beta1/state.proto

package curationv1beta1

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-sdk/api/cosmos/orm/v1"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// TagDefinition defines a tag.
type TagDefinition struct {
	// id is the unique internal identifier of the tag.
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// curator_address is the address of the curator that can set this tag.
	CuratorAddress []byte `protobuf:"bytes,2,opt,name=curator_address,json=curatorAddress,proto3" json:"curator_address,omitempty"`
	// metadata is the metadata of the tag.
	Metadata *TagMeta `protobuf:"bytes,3,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// type is the type of the tag.
	Type *TagType `protobuf:"bytes,4,opt,name=type,proto3" json:"type,omitempty"`
}

func (m *TagDefinition) Reset()         { *m = TagDefinition{} }
func (m *TagDefinition) String() string { return proto.CompactTextString(m) }
func (*TagDefinition) ProtoMessage()    {}
func (*TagDefinition) Descriptor() ([]byte, []int) {
	return fileDescriptor_2baa3213cfc65fb2, []int{0}
}
func (m *TagDefinition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TagDefinition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TagDefinition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TagDefinition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TagDefinition.Merge(m, src)
}
func (m *TagDefinition) XXX_Size() int {
	return m.Size()
}
func (m *TagDefinition) XXX_DiscardUnknown() {
	xxx_messageInfo_TagDefinition.DiscardUnknown(m)
}

var xxx_messageInfo_TagDefinition proto.InternalMessageInfo

func (m *TagDefinition) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TagDefinition) GetCuratorAddress() []byte {
	if m != nil {
		return m.CuratorAddress
	}
	return nil
}

func (m *TagDefinition) GetMetadata() *TagMeta {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *TagDefinition) GetType() *TagType {
	if m != nil {
		return m.Type
	}
	return nil
}

// AddressTagEntry defines a boolean tag for an address.
type AddressTagEntry struct {
	// address is the address of the account that has the tag.
	Address []byte `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// tag_id is the id of the tag.
	TagId uint64 `protobuf:"varint,2,opt,name=tag_id,json=tagId,proto3" json:"tag_id,omitempty"`
}

func (m *AddressTagEntry) Reset()         { *m = AddressTagEntry{} }
func (m *AddressTagEntry) String() string { return proto.CompactTextString(m) }
func (*AddressTagEntry) ProtoMessage()    {}
func (*AddressTagEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_2baa3213cfc65fb2, []int{1}
}
func (m *AddressTagEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddressTagEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddressTagEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddressTagEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddressTagEntry.Merge(m, src)
}
func (m *AddressTagEntry) XXX_Size() int {
	return m.Size()
}
func (m *AddressTagEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_AddressTagEntry.DiscardUnknown(m)
}

var xxx_messageInfo_AddressTagEntry proto.InternalMessageInfo

func (m *AddressTagEntry) GetAddress() []byte {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *AddressTagEntry) GetTagId() uint64 {
	if m != nil {
		return m.TagId
	}
	return 0
}

// AddressNumericTagEntry defines a numeric tag for an address.
type AddressNumericTagEntry struct {
	// address is the address of the account that has the tag.
	Address []byte `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// tag_id is the id of the tag.
	TagId uint64 `protobuf:"varint,2,opt,name=tag_id,json=tagId,proto3" json:"tag_id,omitempty"`
	// value is the value of the numeric tag.
	Value uint64 `protobuf:"varint,3,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *AddressNumericTagEntry) Reset()         { *m = AddressNumericTagEntry{} }
func (m *AddressNumericTagEntry) String() string { return proto.CompactTextString(m) }
func (*AddressNumericTagEntry) ProtoMessage()    {}
func (*AddressNumericTagEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_2baa3213cfc65fb2, []int{2}
}
func (m *AddressNumericTagEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddressNumericTagEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddressNumericTagEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddressNumericTagEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddressNumericTagEntry.Merge(m, src)
}
func (m *AddressNumericTagEntry) XXX_Size() int {
	return m.Size()
}
func (m *AddressNumericTagEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_AddressNumericTagEntry.DiscardUnknown(m)
}

var xxx_messageInfo_AddressNumericTagEntry proto.InternalMessageInfo

func (m *AddressNumericTagEntry) GetAddress() []byte {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *AddressNumericTagEntry) GetTagId() uint64 {
	if m != nil {
		return m.TagId
	}
	return 0
}

func (m *AddressNumericTagEntry) GetValue() uint64 {
	if m != nil {
		return m.Value
	}
	return 0
}

// ClassTagEntry defines a boolean tag for a class.
type ClassTagEntry struct {
	// class_id is the id of the class that has the tag.
	ClassId uint64 `protobuf:"varint,1,opt,name=class_id,json=classId,proto3" json:"class_id,omitempty"`
	// tag_id is the id of the tag.
	TagId uint64 `protobuf:"varint,2,opt,name=tag_id,json=tagId,proto3" json:"tag_id,omitempty"`
}

func (m *ClassTagEntry) Reset()         { *m = ClassTagEntry{} }
func (m *ClassTagEntry) String() string { return proto.CompactTextString(m) }
func (*ClassTagEntry) ProtoMessage()    {}
func (*ClassTagEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_2baa3213cfc65fb2, []int{3}
}
func (m *ClassTagEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClassTagEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClassTagEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClassTagEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClassTagEntry.Merge(m, src)
}
func (m *ClassTagEntry) XXX_Size() int {
	return m.Size()
}
func (m *ClassTagEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_ClassTagEntry.DiscardUnknown(m)
}

var xxx_messageInfo_ClassTagEntry proto.InternalMessageInfo

func (m *ClassTagEntry) GetClassId() uint64 {
	if m != nil {
		return m.ClassId
	}
	return 0
}

func (m *ClassTagEntry) GetTagId() uint64 {
	if m != nil {
		return m.TagId
	}
	return 0
}

// ClassNumericTagEntry defines a numeric tag for a class.
type ClassNumericTagEntry struct {
	// class_id is the id of the class that has the tag.
	ClassId uint64 `protobuf:"varint,1,opt,name=class_id,json=classId,proto3" json:"class_id,omitempty"`
	// tag_id is the id of the tag.
	TagId uint64 `protobuf:"varint,2,opt,name=tag_id,json=tagId,proto3" json:"tag_id,omitempty"`
	// value is the value of the numeric tag.
	Value uint64 `protobuf:"varint,3,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *ClassNumericTagEntry) Reset()         { *m = ClassNumericTagEntry{} }
func (m *ClassNumericTagEntry) String() string { return proto.CompactTextString(m) }
func (*ClassNumericTagEntry) ProtoMessage()    {}
func (*ClassNumericTagEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_2baa3213cfc65fb2, []int{4}
}
func (m *ClassNumericTagEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClassNumericTagEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClassNumericTagEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClassNumericTagEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClassNumericTagEntry.Merge(m, src)
}
func (m *ClassNumericTagEntry) XXX_Size() int {
	return m.Size()
}
func (m *ClassNumericTagEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_ClassNumericTagEntry.DiscardUnknown(m)
}

var xxx_messageInfo_ClassNumericTagEntry proto.InternalMessageInfo

func (m *ClassNumericTagEntry) GetClassId() uint64 {
	if m != nil {
		return m.ClassId
	}
	return 0
}

func (m *ClassNumericTagEntry) GetTagId() uint64 {
	if m != nil {
		return m.TagId
	}
	return 0
}

func (m *ClassNumericTagEntry) GetValue() uint64 {
	if m != nil {
		return m.Value
	}
	return 0
}

// ProjectTagEntry defines a boolean tag for a project.
type ProjectTagEntry struct {
	// project_id is the id of the project that has the tag.
	ProjectId uint64 `protobuf:"varint,1,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	// tag_id is the id of the tag.
	TagId uint64 `protobuf:"varint,2,opt,name=tag_id,json=tagId,proto3" json:"tag_id,omitempty"`
}

func (m *ProjectTagEntry) Reset()         { *m = ProjectTagEntry{} }
func (m *ProjectTagEntry) String() string { return proto.CompactTextString(m) }
func (*ProjectTagEntry) ProtoMessage()    {}
func (*ProjectTagEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_2baa3213cfc65fb2, []int{5}
}
func (m *ProjectTagEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProjectTagEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProjectTagEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProjectTagEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProjectTagEntry.Merge(m, src)
}
func (m *ProjectTagEntry) XXX_Size() int {
	return m.Size()
}
func (m *ProjectTagEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_ProjectTagEntry.DiscardUnknown(m)
}

var xxx_messageInfo_ProjectTagEntry proto.InternalMessageInfo

func (m *ProjectTagEntry) GetProjectId() uint64 {
	if m != nil {
		return m.ProjectId
	}
	return 0
}

func (m *ProjectTagEntry) GetTagId() uint64 {
	if m != nil {
		return m.TagId
	}
	return 0
}

// ProjectNumericTagEntry defines a numeric tag for a project.
type ProjectNumericTagEntry struct {
	// project_id is the id of the project that has the tag.
	ProjectId uint64 `protobuf:"varint,1,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	// tag_id is the id of the tag.
	TagId uint64 `protobuf:"varint,2,opt,name=tag_id,json=tagId,proto3" json:"tag_id,omitempty"`
	// value is the value of the numeric tag.
	Value uint64 `protobuf:"varint,3,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *ProjectNumericTagEntry) Reset()         { *m = ProjectNumericTagEntry{} }
func (m *ProjectNumericTagEntry) String() string { return proto.CompactTextString(m) }
func (*ProjectNumericTagEntry) ProtoMessage()    {}
func (*ProjectNumericTagEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_2baa3213cfc65fb2, []int{6}
}
func (m *ProjectNumericTagEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProjectNumericTagEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProjectNumericTagEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProjectNumericTagEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProjectNumericTagEntry.Merge(m, src)
}
func (m *ProjectNumericTagEntry) XXX_Size() int {
	return m.Size()
}
func (m *ProjectNumericTagEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_ProjectNumericTagEntry.DiscardUnknown(m)
}

var xxx_messageInfo_ProjectNumericTagEntry proto.InternalMessageInfo

func (m *ProjectNumericTagEntry) GetProjectId() uint64 {
	if m != nil {
		return m.ProjectId
	}
	return 0
}

func (m *ProjectNumericTagEntry) GetTagId() uint64 {
	if m != nil {
		return m.TagId
	}
	return 0
}

func (m *ProjectNumericTagEntry) GetValue() uint64 {
	if m != nil {
		return m.Value
	}
	return 0
}

// BatchTagEntry defines a boolean tag for a batch.
type BatchTagEntry struct {
	// batch_id is the id of the batch that has the tag.
	BatchId uint64 `protobuf:"varint,1,opt,name=batch_id,json=batchId,proto3" json:"batch_id,omitempty"`
	// tag_id is the id of the tag.
	TagId uint64 `protobuf:"varint,2,opt,name=tag_id,json=tagId,proto3" json:"tag_id,omitempty"`
}

func (m *BatchTagEntry) Reset()         { *m = BatchTagEntry{} }
func (m *BatchTagEntry) String() string { return proto.CompactTextString(m) }
func (*BatchTagEntry) ProtoMessage()    {}
func (*BatchTagEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_2baa3213cfc65fb2, []int{7}
}
func (m *BatchTagEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchTagEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchTagEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchTagEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchTagEntry.Merge(m, src)
}
func (m *BatchTagEntry) XXX_Size() int {
	return m.Size()
}
func (m *BatchTagEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchTagEntry.DiscardUnknown(m)
}

var xxx_messageInfo_BatchTagEntry proto.InternalMessageInfo

func (m *BatchTagEntry) GetBatchId() uint64 {
	if m != nil {
		return m.BatchId
	}
	return 0
}

func (m *BatchTagEntry) GetTagId() uint64 {
	if m != nil {
		return m.TagId
	}
	return 0
}

// BatchNumericTagEntry defines a numeric tag for a batch.
type BatchNumericTagEntry struct {
	// batch_id is the id of the batch that has the tag.
	BatchId uint64 `protobuf:"varint,1,opt,name=batch_id,json=batchId,proto3" json:"batch_id,omitempty"`
	// tag_id is the id of the tag.
	TagId uint64 `protobuf:"varint,2,opt,name=tag_id,json=tagId,proto3" json:"tag_id,omitempty"`
	// value is the value of the numeric tag.
	Value uint64 `protobuf:"varint,3,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *BatchNumericTagEntry) Reset()         { *m = BatchNumericTagEntry{} }
func (m *BatchNumericTagEntry) String() string { return proto.CompactTextString(m) }
func (*BatchNumericTagEntry) ProtoMessage()    {}
func (*BatchNumericTagEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_2baa3213cfc65fb2, []int{8}
}
func (m *BatchNumericTagEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchNumericTagEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchNumericTagEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchNumericTagEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchNumericTagEntry.Merge(m, src)
}
func (m *BatchNumericTagEntry) XXX_Size() int {
	return m.Size()
}
func (m *BatchNumericTagEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchNumericTagEntry.DiscardUnknown(m)
}

var xxx_messageInfo_BatchNumericTagEntry proto.InternalMessageInfo

func (m *BatchNumericTagEntry) GetBatchId() uint64 {
	if m != nil {
		return m.BatchId
	}
	return 0
}

func (m *BatchNumericTagEntry) GetTagId() uint64 {
	if m != nil {
		return m.TagId
	}
	return 0
}

func (m *BatchNumericTagEntry) GetValue() uint64 {
	if m != nil {
		return m.Value
	}
	return 0
}

func init() {
	proto.RegisterType((*TagDefinition)(nil), "regen.ecocredit.curation.v1beta1.TagDefinition")
	proto.RegisterType((*AddressTagEntry)(nil), "regen.ecocredit.curation.v1beta1.AddressTagEntry")
	proto.RegisterType((*AddressNumericTagEntry)(nil), "regen.ecocredit.curation.v1beta1.AddressNumericTagEntry")
	proto.RegisterType((*ClassTagEntry)(nil), "regen.ecocredit.curation.v1beta1.ClassTagEntry")
	proto.RegisterType((*ClassNumericTagEntry)(nil), "regen.ecocredit.curation.v1beta1.ClassNumericTagEntry")
	proto.RegisterType((*ProjectTagEntry)(nil), "regen.ecocredit.curation.v1beta1.ProjectTagEntry")
	proto.RegisterType((*ProjectNumericTagEntry)(nil), "regen.ecocredit.curation.v1beta1.ProjectNumericTagEntry")
	proto.RegisterType((*BatchTagEntry)(nil), "regen.ecocredit.curation.v1beta1.BatchTagEntry")
	proto.RegisterType((*BatchNumericTagEntry)(nil), "regen.ecocredit.curation.v1beta1.BatchNumericTagEntry")
}

func init() {
	proto.RegisterFile("regen/ecocredit/curation/v1beta1/state.proto", fileDescriptor_2baa3213cfc65fb2)
}

var fileDescriptor_2baa3213cfc65fb2 = []byte{
	// 614 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x54, 0xcf, 0x6e, 0xd3, 0x4e,
	0x10, 0xee, 0x26, 0x4e, 0xda, 0xdf, 0xfc, 0xda, 0xc4, 0x75, 0xff, 0x60, 0x2a, 0x61, 0x45, 0xbe,
	0x10, 0x50, 0xb0, 0x09, 0x70, 0x0a, 0x20, 0x95, 0x40, 0x91, 0x7a, 0x00, 0x21, 0x2b, 0x07, 0xc4,
	0x25, 0xda, 0xd8, 0x8b, 0x6b, 0x48, 0xb2, 0xd1, 0x7a, 0x13, 0xc8, 0x81, 0x57, 0x40, 0x3c, 0x01,
	0x12, 0x9c, 0x79, 0x10, 0x8e, 0x95, 0xb8, 0x70, 0xac, 0x92, 0x37, 0xe0, 0x09, 0x90, 0xd7, 0xbb,
	0x49, 0x54, 0x12, 0x25, 0xe9, 0xc9, 0x9e, 0xd9, 0x6f, 0xf6, 0xfb, 0xe6, 0xdb, 0xd1, 0x40, 0x85,
	0x91, 0x90, 0x74, 0x5d, 0xe2, 0x53, 0x9f, 0x91, 0x20, 0xe2, 0xae, 0xdf, 0x67, 0x98, 0x47, 0xb4,
	0xeb, 0x0e, 0xaa, 0x2d, 0xc2, 0x71, 0xd5, 0x8d, 0x39, 0xe6, 0xc4, 0xe9, 0x31, 0xca, 0xa9, 0x51,
	0x12, 0x68, 0x67, 0x82, 0x76, 0x14, 0xda, 0x91, 0xe8, 0xa3, 0x6b, 0x3e, 0x8d, 0x3b, 0x34, 0x76,
	0x29, 0xeb, 0xb8, 0x83, 0x6a, 0xf2, 0x49, 0x4b, 0x8f, 0x96, 0x13, 0xf1, 0x61, 0x8f, 0xc4, 0x29,
	0xda, 0xbe, 0x40, 0xb0, 0xd3, 0xc0, 0xe1, 0x33, 0xf2, 0x36, 0xea, 0x46, 0x09, 0xca, 0x28, 0x40,
	0x26, 0x0a, 0x4c, 0x54, 0x42, 0x65, 0xcd, 0xcb, 0x44, 0x81, 0x71, 0x13, 0x8a, 0xe2, 0x06, 0xca,
	0x9a, 0x38, 0x08, 0x18, 0x89, 0x63, 0x33, 0x53, 0x42, 0xe5, 0x6d, 0xaf, 0x20, 0xd3, 0x4f, 0xd2,
	0xac, 0x71, 0x02, 0x5b, 0x1d, 0xc2, 0x71, 0x80, 0x39, 0x36, 0xb3, 0x25, 0x54, 0xfe, 0xff, 0xde,
	0x2d, 0x67, 0x59, 0x1b, 0x4e, 0x03, 0x87, 0x2f, 0x08, 0xc7, 0xde, 0xa4, 0xd4, 0x78, 0x0c, 0x5a,
	0x22, 0xd0, 0xd4, 0xd6, 0xb8, 0xa2, 0x31, 0xec, 0x11, 0x4f, 0x94, 0xd5, 0xf4, 0x3f, 0x5f, 0x7f,
	0x7d, 0xce, 0x02, 0xe4, 0x93, 0x36, 0x74, 0x64, 0x22, 0x9b, 0x41, 0x51, 0x4a, 0x6c, 0xe0, 0xf0,
	0xa4, 0xcb, 0xd9, 0xd0, 0x30, 0x61, 0x53, 0xf5, 0x82, 0x44, 0x2f, 0x2a, 0x34, 0x0e, 0x20, 0xcf,
	0x71, 0xd8, 0x8c, 0x02, 0xd1, 0xa4, 0xe6, 0xe5, 0x38, 0x0e, 0x4f, 0x83, 0x9a, 0x23, 0x6e, 0x2d,
	0x83, 0x0e, 0x05, 0x89, 0xac, 0xa4, 0x30, 0xc3, 0x80, 0x42, 0xfa, 0x57, 0x91, 0x07, 0x3a, 0x32,
	0x33, 0xf6, 0x37, 0x04, 0x87, 0x92, 0xf4, 0x65, 0xbf, 0x43, 0x58, 0xe4, 0x5f, 0x99, 0xdb, 0xd8,
	0x87, 0xdc, 0x00, 0xb7, 0xfb, 0x44, 0x98, 0xaa, 0x79, 0x69, 0x50, 0x3b, 0x16, 0x8a, 0x6a, 0xab,
	0x29, 0x32, 0x74, 0xd8, 0x96, 0x39, 0x51, 0xad, 0x67, 0xcc, 0xac, 0x1d, 0xc3, 0xce, 0xd3, 0x36,
	0x9e, 0x71, 0xe5, 0x3a, 0x6c, 0xf9, 0x49, 0xa2, 0x39, 0x79, 0xff, 0x4d, 0x11, 0x9f, 0x06, 0x8b,
	0x6c, 0xb9, 0x2b, 0x44, 0xdc, 0x86, 0x5d, 0x28, 0xaa, 0x4a, 0xa5, 0x62, 0x0f, 0x8a, 0x92, 0x51,
	0x9d, 0xe8, 0xc8, 0xcc, 0xda, 0xdf, 0x11, 0xec, 0x0b, 0xd6, 0xcb, 0xb6, 0xac, 0x4d, 0xbe, 0xc0,
	0x97, 0xba, 0x90, 0xf4, 0x68, 0x55, 0x49, 0x73, 0x9c, 0xd1, 0xec, 0x4f, 0x50, 0x7c, 0xc5, 0xe8,
	0x3b, 0xe2, 0xf3, 0x89, 0xbc, 0x1b, 0x00, 0xbd, 0x34, 0x35, 0x15, 0xf8, 0x9f, 0xcc, 0x2c, 0xf6,
	0xe7, 0x81, 0x10, 0xe3, 0xc0, 0x1e, 0xec, 0x4e, 0xab, 0x95, 0x9c, 0x03, 0xd8, 0x95, 0xcc, 0xd3,
	0x33, 0x1d, 0x99, 0x9a, 0xfd, 0x03, 0xc1, 0xa1, 0xe4, 0xbf, 0xec, 0xd2, 0x95, 0x64, 0x2c, 0x70,
	0xea, 0xb9, 0x10, 0x77, 0xbc, 0x8e, 0xb8, 0x39, 0x6e, 0xe5, 0x92, 0x39, 0xaa, 0x63, 0xee, 0x9f,
	0xcd, 0x3e, 0x65, 0x2b, 0x49, 0xcc, 0x3c, 0xa5, 0x88, 0x57, 0x9a, 0x23, 0x55, 0xf9, 0xef, 0xa3,
	0xa9, 0x13, 0x1d, 0x99, 0x39, 0x31, 0x47, 0x82, 0x75, 0xce, 0x1c, 0xad, 0x47, 0xbe, 0x7c, 0x8e,
	0x56, 0x91, 0x34, 0xc7, 0x99, 0x7c, 0x9d, 0xfd, 0x1c, 0x59, 0xe8, 0x7c, 0x64, 0xa1, 0x8b, 0x91,
	0x85, 0xbe, 0x8c, 0xad, 0x8d, 0xf3, 0xb1, 0xb5, 0xf1, 0x7b, 0x6c, 0x6d, 0xbc, 0x79, 0x1d, 0x46,
	0xfc, 0xac, 0xdf, 0x72, 0x7c, 0xda, 0x71, 0xc5, 0x82, 0xbb, 0xd3, 0x25, 0xfc, 0x03, 0x65, 0xef,
	0x65, 0xd4, 0x26, 0x41, 0x48, 0x98, 0xfb, 0x71, 0xde, 0x1a, 0x17, 0xeb, 0x5b, 0x2d, 0xf3, 0x87,
	0x2a, 0x2d, 0xe3, 0x56, 0x5e, 0xec, 0xf5, 0xfb, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0x2a, 0xd7,
	0x53, 0x47, 0x70, 0x06, 0x00, 0x00,
}

func (m *TagDefinition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TagDefinition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TagDefinition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		{
			size, err := m.Type.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintState(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintState(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CuratorAddress) > 0 {
		i -= len(m.CuratorAddress)
		copy(dAtA[i:], m.CuratorAddress)
		i = encodeVarintState(dAtA, i, uint64(len(m.CuratorAddress)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AddressTagEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddressTagEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddressTagEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TagId != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.TagId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintState(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AddressNumericTagEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddressNumericTagEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddressNumericTagEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x18
	}
	if m.TagId != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.TagId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintState(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClassTagEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClassTagEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClassTagEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TagId != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.TagId))
		i--
		dAtA[i] = 0x10
	}
	if m.ClassId != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.ClassId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ClassNumericTagEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClassNumericTagEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClassNumericTagEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x18
	}
	if m.TagId != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.TagId))
		i--
		dAtA[i] = 0x10
	}
	if m.ClassId != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.ClassId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ProjectTagEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProjectTagEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProjectTagEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TagId != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.TagId))
		i--
		dAtA[i] = 0x10
	}
	if m.ProjectId != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.ProjectId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ProjectNumericTagEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProjectNumericTagEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProjectNumericTagEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x18
	}
	if m.TagId != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.TagId))
		i--
		dAtA[i] = 0x10
	}
	if m.ProjectId != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.ProjectId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BatchTagEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchTagEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchTagEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TagId != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.TagId))
		i--
		dAtA[i] = 0x10
	}
	if m.BatchId != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.BatchId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BatchNumericTagEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchNumericTagEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchNumericTagEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x18
	}
	if m.TagId != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.TagId))
		i--
		dAtA[i] = 0x10
	}
	if m.BatchId != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.BatchId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintState(dAtA []byte, offset int, v uint64) int {
	offset -= sovState(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TagDefinition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovState(uint64(m.Id))
	}
	l = len(m.CuratorAddress)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovState(uint64(l))
	}
	if m.Type != nil {
		l = m.Type.Size()
		n += 1 + l + sovState(uint64(l))
	}
	return n
}

func (m *AddressTagEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if m.TagId != 0 {
		n += 1 + sovState(uint64(m.TagId))
	}
	return n
}

func (m *AddressNumericTagEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if m.TagId != 0 {
		n += 1 + sovState(uint64(m.TagId))
	}
	if m.Value != 0 {
		n += 1 + sovState(uint64(m.Value))
	}
	return n
}

func (m *ClassTagEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClassId != 0 {
		n += 1 + sovState(uint64(m.ClassId))
	}
	if m.TagId != 0 {
		n += 1 + sovState(uint64(m.TagId))
	}
	return n
}

func (m *ClassNumericTagEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClassId != 0 {
		n += 1 + sovState(uint64(m.ClassId))
	}
	if m.TagId != 0 {
		n += 1 + sovState(uint64(m.TagId))
	}
	if m.Value != 0 {
		n += 1 + sovState(uint64(m.Value))
	}
	return n
}

func (m *ProjectTagEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProjectId != 0 {
		n += 1 + sovState(uint64(m.ProjectId))
	}
	if m.TagId != 0 {
		n += 1 + sovState(uint64(m.TagId))
	}
	return n
}

func (m *ProjectNumericTagEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProjectId != 0 {
		n += 1 + sovState(uint64(m.ProjectId))
	}
	if m.TagId != 0 {
		n += 1 + sovState(uint64(m.TagId))
	}
	if m.Value != 0 {
		n += 1 + sovState(uint64(m.Value))
	}
	return n
}

func (m *BatchTagEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchId != 0 {
		n += 1 + sovState(uint64(m.BatchId))
	}
	if m.TagId != 0 {
		n += 1 + sovState(uint64(m.TagId))
	}
	return n
}

func (m *BatchNumericTagEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchId != 0 {
		n += 1 + sovState(uint64(m.BatchId))
	}
	if m.TagId != 0 {
		n += 1 + sovState(uint64(m.TagId))
	}
	if m.Value != 0 {
		n += 1 + sovState(uint64(m.Value))
	}
	return n
}

func sovState(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozState(x uint64) (n int) {
	return sovState(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TagDefinition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TagDefinition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TagDefinition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CuratorAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CuratorAddress = append(m.CuratorAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.CuratorAddress == nil {
				m.CuratorAddress = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &TagMeta{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Type == nil {
				m.Type = &TagType{}
			}
			if err := m.Type.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddressTagEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddressTagEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddressTagEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = append(m.Address[:0], dAtA[iNdEx:postIndex]...)
			if m.Address == nil {
				m.Address = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagId", wireType)
			}
			m.TagId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TagId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddressNumericTagEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddressNumericTagEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddressNumericTagEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = append(m.Address[:0], dAtA[iNdEx:postIndex]...)
			if m.Address == nil {
				m.Address = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagId", wireType)
			}
			m.TagId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TagId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClassTagEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClassTagEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClassTagEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassId", wireType)
			}
			m.ClassId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClassId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagId", wireType)
			}
			m.TagId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TagId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClassNumericTagEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClassNumericTagEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClassNumericTagEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassId", wireType)
			}
			m.ClassId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClassId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagId", wireType)
			}
			m.TagId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TagId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProjectTagEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProjectTagEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProjectTagEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectId", wireType)
			}
			m.ProjectId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProjectId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagId", wireType)
			}
			m.TagId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TagId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProjectNumericTagEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProjectNumericTagEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProjectNumericTagEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectId", wireType)
			}
			m.ProjectId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProjectId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagId", wireType)
			}
			m.TagId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TagId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchTagEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchTagEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchTagEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchId", wireType)
			}
			m.BatchId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagId", wireType)
			}
			m.TagId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TagId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchNumericTagEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchNumericTagEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchNumericTagEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchId", wireType)
			}
			m.BatchId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagId", wireType)
			}
			m.TagId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TagId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipState(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowState
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowState
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowState
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthState
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupState
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthState
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthState        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowState          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupState = fmt.Errorf("proto: unexpected end of group")
)
