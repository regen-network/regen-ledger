// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: regen/ecocredit/curation/v1beta1/types.proto

package curationv1beta1

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// TagTarget represents the target of a tag.
type TagTarget struct {
	// sum is the target of the tag.
	//
	// Types that are valid to be assigned to Sum:
	//	*TagTarget_Address
	//	*TagTarget_ClassId
	//	*TagTarget_ProjectId
	//	*TagTarget_BatchId
	Sum isTagTarget_Sum `protobuf_oneof:"sum"`
}

func (m *TagTarget) Reset()         { *m = TagTarget{} }
func (m *TagTarget) String() string { return proto.CompactTextString(m) }
func (*TagTarget) ProtoMessage()    {}
func (*TagTarget) Descriptor() ([]byte, []int) {
	return fileDescriptor_950121d976ee240f, []int{0}
}
func (m *TagTarget) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TagTarget) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TagTarget.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TagTarget) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TagTarget.Merge(m, src)
}
func (m *TagTarget) XXX_Size() int {
	return m.Size()
}
func (m *TagTarget) XXX_DiscardUnknown() {
	xxx_messageInfo_TagTarget.DiscardUnknown(m)
}

var xxx_messageInfo_TagTarget proto.InternalMessageInfo

type isTagTarget_Sum interface {
	isTagTarget_Sum()
	MarshalTo([]byte) (int, error)
	Size() int
}

type TagTarget_Address struct {
	Address string `protobuf:"bytes,1,opt,name=address,proto3,oneof" json:"address,omitempty"`
}
type TagTarget_ClassId struct {
	ClassId string `protobuf:"bytes,2,opt,name=class_id,json=classId,proto3,oneof" json:"class_id,omitempty"`
}
type TagTarget_ProjectId struct {
	ProjectId string `protobuf:"bytes,3,opt,name=project_id,json=projectId,proto3,oneof" json:"project_id,omitempty"`
}
type TagTarget_BatchId struct {
	BatchId string `protobuf:"bytes,4,opt,name=batch_id,json=batchId,proto3,oneof" json:"batch_id,omitempty"`
}

func (*TagTarget_Address) isTagTarget_Sum()   {}
func (*TagTarget_ClassId) isTagTarget_Sum()   {}
func (*TagTarget_ProjectId) isTagTarget_Sum() {}
func (*TagTarget_BatchId) isTagTarget_Sum()   {}

func (m *TagTarget) GetSum() isTagTarget_Sum {
	if m != nil {
		return m.Sum
	}
	return nil
}

func (m *TagTarget) GetAddress() string {
	if x, ok := m.GetSum().(*TagTarget_Address); ok {
		return x.Address
	}
	return ""
}

func (m *TagTarget) GetClassId() string {
	if x, ok := m.GetSum().(*TagTarget_ClassId); ok {
		return x.ClassId
	}
	return ""
}

func (m *TagTarget) GetProjectId() string {
	if x, ok := m.GetSum().(*TagTarget_ProjectId); ok {
		return x.ProjectId
	}
	return ""
}

func (m *TagTarget) GetBatchId() string {
	if x, ok := m.GetSum().(*TagTarget_BatchId); ok {
		return x.BatchId
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*TagTarget) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*TagTarget_Address)(nil),
		(*TagTarget_ClassId)(nil),
		(*TagTarget_ProjectId)(nil),
		(*TagTarget_BatchId)(nil),
	}
}

// AllowedTagTargets represents the targets that a tag can be applied to.
type AllowedTagTargets struct {
	// address indicates that this tag can be applied to the address of an account such as a credit class admin.
	Address bool `protobuf:"varint,1,opt,name=address,proto3" json:"address,omitempty"`
	// class indicates that this tag can be applied to all the credits within a given class.
	Class bool `protobuf:"varint,2,opt,name=class,proto3" json:"class,omitempty"`
	// project indicates that this tag can be applied to all the credits within a given project.
	Project bool `protobuf:"varint,3,opt,name=project,proto3" json:"project,omitempty"`
	// batch indicates that this tag can be applied to the credits within a batch.
	Batch bool `protobuf:"varint,4,opt,name=batch,proto3" json:"batch,omitempty"`
}

func (m *AllowedTagTargets) Reset()         { *m = AllowedTagTargets{} }
func (m *AllowedTagTargets) String() string { return proto.CompactTextString(m) }
func (*AllowedTagTargets) ProtoMessage()    {}
func (*AllowedTagTargets) Descriptor() ([]byte, []int) {
	return fileDescriptor_950121d976ee240f, []int{1}
}
func (m *AllowedTagTargets) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllowedTagTargets) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AllowedTagTargets.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AllowedTagTargets) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllowedTagTargets.Merge(m, src)
}
func (m *AllowedTagTargets) XXX_Size() int {
	return m.Size()
}
func (m *AllowedTagTargets) XXX_DiscardUnknown() {
	xxx_messageInfo_AllowedTagTargets.DiscardUnknown(m)
}

var xxx_messageInfo_AllowedTagTargets proto.InternalMessageInfo

func (m *AllowedTagTargets) GetAddress() bool {
	if m != nil {
		return m.Address
	}
	return false
}

func (m *AllowedTagTargets) GetClass() bool {
	if m != nil {
		return m.Class
	}
	return false
}

func (m *AllowedTagTargets) GetProject() bool {
	if m != nil {
		return m.Project
	}
	return false
}

func (m *AllowedTagTargets) GetBatch() bool {
	if m != nil {
		return m.Batch
	}
	return false
}

// TagMeta represents the metadata of a tag.
type TagMeta struct {
	// name is the name of the tag. It is not considered unique among tags and is informational only.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// description is a description of the tag. It is informational only.
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// allowed_targets is the targets that this tag can be applied to.
	AllowedTargets *AllowedTagTargets `protobuf:"bytes,3,opt,name=allowed_targets,json=allowedTargets,proto3" json:"allowed_targets,omitempty"`
}

func (m *TagMeta) Reset()         { *m = TagMeta{} }
func (m *TagMeta) String() string { return proto.CompactTextString(m) }
func (*TagMeta) ProtoMessage()    {}
func (*TagMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_950121d976ee240f, []int{2}
}
func (m *TagMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TagMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TagMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TagMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TagMeta.Merge(m, src)
}
func (m *TagMeta) XXX_Size() int {
	return m.Size()
}
func (m *TagMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_TagMeta.DiscardUnknown(m)
}

var xxx_messageInfo_TagMeta proto.InternalMessageInfo

func (m *TagMeta) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TagMeta) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *TagMeta) GetAllowedTargets() *AllowedTagTargets {
	if m != nil {
		return m.AllowedTargets
	}
	return nil
}

// TagType represents the type of a tag.
type TagType struct {
	// sum is the type of the tag.
	//
	// Types that are valid to be assigned to Sum:
	//	*TagType_Tag
	//	*TagType_Numeric
	Sum isTagType_Sum `protobuf_oneof:"sum"`
}

func (m *TagType) Reset()         { *m = TagType{} }
func (m *TagType) String() string { return proto.CompactTextString(m) }
func (*TagType) ProtoMessage()    {}
func (*TagType) Descriptor() ([]byte, []int) {
	return fileDescriptor_950121d976ee240f, []int{3}
}
func (m *TagType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TagType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TagType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TagType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TagType.Merge(m, src)
}
func (m *TagType) XXX_Size() int {
	return m.Size()
}
func (m *TagType) XXX_DiscardUnknown() {
	xxx_messageInfo_TagType.DiscardUnknown(m)
}

var xxx_messageInfo_TagType proto.InternalMessageInfo

type isTagType_Sum interface {
	isTagType_Sum()
	MarshalTo([]byte) (int, error)
	Size() int
}

type TagType_Tag struct {
	Tag *TagTagType `protobuf:"bytes,1,opt,name=tag,proto3,oneof" json:"tag,omitempty"`
}
type TagType_Numeric struct {
	Numeric *NumericTagType `protobuf:"bytes,2,opt,name=numeric,proto3,oneof" json:"numeric,omitempty"`
}

func (*TagType_Tag) isTagType_Sum()     {}
func (*TagType_Numeric) isTagType_Sum() {}

func (m *TagType) GetSum() isTagType_Sum {
	if m != nil {
		return m.Sum
	}
	return nil
}

func (m *TagType) GetTag() *TagTagType {
	if x, ok := m.GetSum().(*TagType_Tag); ok {
		return x.Tag
	}
	return nil
}

func (m *TagType) GetNumeric() *NumericTagType {
	if x, ok := m.GetSum().(*TagType_Numeric); ok {
		return x.Numeric
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*TagType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*TagType_Tag)(nil),
		(*TagType_Numeric)(nil),
	}
}

// TagTagType represents a tag that can either be present or not present.
type TagTagType struct {
}

func (m *TagTagType) Reset()         { *m = TagTagType{} }
func (m *TagTagType) String() string { return proto.CompactTextString(m) }
func (*TagTagType) ProtoMessage()    {}
func (*TagTagType) Descriptor() ([]byte, []int) {
	return fileDescriptor_950121d976ee240f, []int{4}
}
func (m *TagTagType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TagTagType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TagTagType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TagTagType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TagTagType.Merge(m, src)
}
func (m *TagTagType) XXX_Size() int {
	return m.Size()
}
func (m *TagTagType) XXX_DiscardUnknown() {
	xxx_messageInfo_TagTagType.DiscardUnknown(m)
}

var xxx_messageInfo_TagTagType proto.InternalMessageInfo

// NumericTagType represents a tag that can have a numeric value. Numeric values are represented as
// uint64s in storage and have a fixed precision. They are not considered floating point values.
// The range of numeric values must be representable within the range of a uint64 given the provided
// min, max and precision.
type NumericTagType struct {
	// min is the minimum value of the attribute as a decimal string. It is required.
	Min string `protobuf:"bytes,1,opt,name=min,proto3" json:"min,omitempty"`
	// max is the maximum value of the attribute as a decimal string. It is required.
	Max string `protobuf:"bytes,2,opt,name=max,proto3" json:"max,omitempty"`
	// precision is the number of significant decimal places after the decimal point if it is a positive value.
	// For instance 1 indicates that 3.54 would be an invalid value and that 3.5 is the most precise value
	// that could be submitted.
	// If it is a negative value, it is the number of non-significant digits after the decimal point.
	// For instance -1 indicates that 34 would be an invalid value and that 30 is the most precise value
	// that could be submitted.
	// A value of 0 indicates an integer value.
	Precision int32 `protobuf:"varint,3,opt,name=precision,proto3" json:"precision,omitempty"`
}

func (m *NumericTagType) Reset()         { *m = NumericTagType{} }
func (m *NumericTagType) String() string { return proto.CompactTextString(m) }
func (*NumericTagType) ProtoMessage()    {}
func (*NumericTagType) Descriptor() ([]byte, []int) {
	return fileDescriptor_950121d976ee240f, []int{5}
}
func (m *NumericTagType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NumericTagType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NumericTagType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NumericTagType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NumericTagType.Merge(m, src)
}
func (m *NumericTagType) XXX_Size() int {
	return m.Size()
}
func (m *NumericTagType) XXX_DiscardUnknown() {
	xxx_messageInfo_NumericTagType.DiscardUnknown(m)
}

var xxx_messageInfo_NumericTagType proto.InternalMessageInfo

func (m *NumericTagType) GetMin() string {
	if m != nil {
		return m.Min
	}
	return ""
}

func (m *NumericTagType) GetMax() string {
	if m != nil {
		return m.Max
	}
	return ""
}

func (m *NumericTagType) GetPrecision() int32 {
	if m != nil {
		return m.Precision
	}
	return 0
}

func init() {
	proto.RegisterType((*TagTarget)(nil), "regen.ecocredit.curation.v1beta1.TagTarget")
	proto.RegisterType((*AllowedTagTargets)(nil), "regen.ecocredit.curation.v1beta1.AllowedTagTargets")
	proto.RegisterType((*TagMeta)(nil), "regen.ecocredit.curation.v1beta1.TagMeta")
	proto.RegisterType((*TagType)(nil), "regen.ecocredit.curation.v1beta1.TagType")
	proto.RegisterType((*TagTagType)(nil), "regen.ecocredit.curation.v1beta1.TagTagType")
	proto.RegisterType((*NumericTagType)(nil), "regen.ecocredit.curation.v1beta1.NumericTagType")
}

func init() {
	proto.RegisterFile("regen/ecocredit/curation/v1beta1/types.proto", fileDescriptor_950121d976ee240f)
}

var fileDescriptor_950121d976ee240f = []byte{
	// 466 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x53, 0xbd, 0x6e, 0x13, 0x41,
	0x10, 0xbe, 0xc3, 0x31, 0x3e, 0x8f, 0x51, 0x80, 0x15, 0x85, 0x05, 0xe8, 0xb0, 0xae, 0xa2, 0x08,
	0x77, 0xc4, 0x29, 0x69, 0x20, 0x55, 0x2c, 0x01, 0xc5, 0xca, 0x05, 0x42, 0x48, 0xd1, 0x7a, 0x77,
	0x74, 0x39, 0xf0, 0xfd, 0x68, 0x77, 0x4d, 0x92, 0x47, 0xa0, 0xe3, 0x05, 0x90, 0x78, 0x1c, 0xca,
	0x94, 0x94, 0xc8, 0x7e, 0x11, 0xb4, 0x73, 0xb7, 0x31, 0x11, 0x91, 0xdc, 0xed, 0x7c, 0xf3, 0xf3,
	0x7d, 0xf3, 0xad, 0x06, 0x0e, 0x34, 0xe6, 0x58, 0x65, 0x28, 0x6b, 0xa9, 0x51, 0x15, 0x36, 0x93,
	0x2b, 0x2d, 0x6c, 0x51, 0x57, 0xd9, 0xd7, 0xc3, 0x05, 0x5a, 0x71, 0x98, 0xd9, 0xcb, 0x06, 0x4d,
	0xda, 0xe8, 0xda, 0xd6, 0x6c, 0x42, 0xd5, 0xe9, 0x75, 0x75, 0xea, 0xab, 0xd3, 0xae, 0x3a, 0xf9,
	0x16, 0xc2, 0x70, 0x2e, 0xf2, 0xb9, 0xd0, 0x39, 0x5a, 0xf6, 0x18, 0x06, 0x42, 0x29, 0x8d, 0xc6,
	0x8c, 0xc3, 0x49, 0xf8, 0x7c, 0x78, 0x12, 0x70, 0x0f, 0xb0, 0x27, 0x10, 0xc9, 0xa5, 0x30, 0xe6,
	0xb4, 0x50, 0xe3, 0x3b, 0x3e, 0x49, 0xc8, 0x4c, 0xb1, 0x67, 0x00, 0x8d, 0xae, 0x3f, 0xa3, 0xb4,
	0x2e, 0xdd, 0xeb, 0xd2, 0xc3, 0x0e, 0x9b, 0x29, 0xd7, 0xbd, 0x10, 0x56, 0x9e, 0xb9, 0xf4, 0x9e,
	0xef, 0x26, 0x64, 0xa6, 0x8e, 0xfb, 0xd0, 0x33, 0xab, 0x32, 0x31, 0xf0, 0xf0, 0xcd, 0x72, 0x59,
	0x9f, 0xa3, 0xba, 0x56, 0x64, 0xd8, 0xf8, 0xa6, 0xa4, 0x68, 0x2b, 0xe8, 0x11, 0xf4, 0x89, 0x9e,
	0xd4, 0x44, 0xbc, 0x0d, 0x5c, 0x7d, 0xc7, 0x4a, 0x32, 0x22, 0xee, 0x43, 0x57, 0x4f, 0x84, 0xc4,
	0x1f, 0xf1, 0x36, 0x48, 0x7e, 0x84, 0x30, 0x98, 0x8b, 0xfc, 0x1d, 0x5a, 0xc1, 0x18, 0xec, 0x55,
	0xa2, 0xc4, 0x76, 0x77, 0x4e, 0x6f, 0x36, 0x81, 0x91, 0x42, 0x23, 0x75, 0xd1, 0x38, 0xdf, 0xda,
	0xcd, 0xf9, 0xbf, 0x10, 0xfb, 0x04, 0xf7, 0x45, 0x2b, 0xfb, 0xd4, 0xb6, 0xa2, 0x89, 0x79, 0x34,
	0x3d, 0x4a, 0x77, 0xd9, 0x9f, 0xfe, 0xb7, 0x2f, 0xdf, 0x17, 0x1e, 0xa2, 0x38, 0xf9, 0xd9, 0xea,
	0x9b, 0x5f, 0x36, 0xc8, 0x5e, 0x43, 0xcf, 0x8a, 0x9c, 0xe4, 0x8d, 0xa6, 0x07, 0xbb, 0xa7, 0xd3,
	0x58, 0x6a, 0x3d, 0x09, 0xb8, 0x6b, 0x65, 0x6f, 0x61, 0x50, 0xad, 0x4a, 0xd4, 0x85, 0xa4, 0x4d,
	0x46, 0xd3, 0x97, 0xbb, 0xa7, 0xbc, 0x6f, 0x1b, 0xb6, 0x93, 0xfc, 0x08, 0xff, 0x6f, 0xf7, 0x00,
	0xb6, 0x4c, 0x09, 0x87, 0xfd, 0x9b, 0x1d, 0xec, 0x01, 0xf4, 0xca, 0xa2, 0xea, 0x5c, 0x75, 0x4f,
	0x42, 0xc4, 0x45, 0x67, 0xa6, 0x7b, 0xb2, 0xa7, 0x30, 0x6c, 0x34, 0xca, 0xc2, 0x38, 0x93, 0x9d,
	0x7d, 0x7d, 0xbe, 0x05, 0x8e, 0xf5, 0xaf, 0x75, 0x1c, 0x5e, 0xad, 0xe3, 0xf0, 0xcf, 0x3a, 0x0e,
	0xbf, 0x6f, 0xe2, 0xe0, 0x6a, 0x13, 0x07, 0xbf, 0x37, 0x71, 0xf0, 0xf1, 0x43, 0x5e, 0xd8, 0xb3,
	0xd5, 0x22, 0x95, 0x75, 0x99, 0xd1, 0x26, 0x2f, 0x2a, 0xb4, 0xe7, 0xb5, 0xfe, 0xd2, 0x45, 0x4b,
	0x54, 0x39, 0xea, 0xec, 0xe2, 0xb6, 0x8b, 0xa1, 0x4b, 0xf1, 0x77, 0xf3, 0xca, 0xc3, 0x5d, 0xbc,
	0xb8, 0x4b, 0x27, 0x74, 0xf4, 0x37, 0x00, 0x00, 0xff, 0xff, 0x04, 0xff, 0x69, 0xe7, 0x72, 0x03,
	0x00, 0x00,
}

func (m *TagTarget) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TagTarget) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TagTarget) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Sum != nil {
		{
			size := m.Sum.Size()
			i -= size
			if _, err := m.Sum.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *TagTarget_Address) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TagTarget_Address) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Address)
	copy(dAtA[i:], m.Address)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Address)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}
func (m *TagTarget_ClassId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TagTarget_ClassId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ClassId)
	copy(dAtA[i:], m.ClassId)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ClassId)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *TagTarget_ProjectId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TagTarget_ProjectId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ProjectId)
	copy(dAtA[i:], m.ProjectId)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ProjectId)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *TagTarget_BatchId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TagTarget_BatchId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.BatchId)
	copy(dAtA[i:], m.BatchId)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.BatchId)))
	i--
	dAtA[i] = 0x22
	return len(dAtA) - i, nil
}
func (m *AllowedTagTargets) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllowedTagTargets) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AllowedTagTargets) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Batch {
		i--
		if m.Batch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Project {
		i--
		if m.Project {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Class {
		i--
		if m.Class {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Address {
		i--
		if m.Address {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TagMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TagMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TagMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AllowedTargets != nil {
		{
			size, err := m.AllowedTargets.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TagType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TagType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TagType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Sum != nil {
		{
			size := m.Sum.Size()
			i -= size
			if _, err := m.Sum.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *TagType_Tag) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TagType_Tag) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Tag != nil {
		{
			size, err := m.Tag.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *TagType_Numeric) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TagType_Numeric) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Numeric != nil {
		{
			size, err := m.Numeric.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *TagTagType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TagTagType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TagTagType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *NumericTagType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NumericTagType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NumericTagType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Precision != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Precision))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Max) > 0 {
		i -= len(m.Max)
		copy(dAtA[i:], m.Max)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Max)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Min) > 0 {
		i -= len(m.Min)
		copy(dAtA[i:], m.Min)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Min)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TagTarget) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sum != nil {
		n += m.Sum.Size()
	}
	return n
}

func (m *TagTarget_Address) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *TagTarget_ClassId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClassId)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *TagTarget_ProjectId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProjectId)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *TagTarget_BatchId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BatchId)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *AllowedTagTargets) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Address {
		n += 2
	}
	if m.Class {
		n += 2
	}
	if m.Project {
		n += 2
	}
	if m.Batch {
		n += 2
	}
	return n
}

func (m *TagMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AllowedTargets != nil {
		l = m.AllowedTargets.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *TagType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sum != nil {
		n += m.Sum.Size()
	}
	return n
}

func (m *TagType_Tag) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tag != nil {
		l = m.Tag.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *TagType_Numeric) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Numeric != nil {
		l = m.Numeric.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *TagTagType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *NumericTagType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Min)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Max)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Precision != 0 {
		n += 1 + sovTypes(uint64(m.Precision))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TagTarget) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TagTarget: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TagTarget: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sum = &TagTarget_Address{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sum = &TagTarget_ClassId{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sum = &TagTarget_ProjectId{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sum = &TagTarget_BatchId{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllowedTagTargets) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllowedTagTargets: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllowedTagTargets: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Address = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Class", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Class = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Project", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Project = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Batch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Batch = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TagMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TagMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TagMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedTargets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AllowedTargets == nil {
				m.AllowedTargets = &AllowedTagTargets{}
			}
			if err := m.AllowedTargets.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TagType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TagType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TagType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TagTagType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Sum = &TagType_Tag{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Numeric", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NumericTagType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Sum = &TagType_Numeric{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TagTagType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TagTagType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TagTagType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NumericTagType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NumericTagType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NumericTagType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Min", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Min = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Max", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Max = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Precision", wireType)
			}
			m.Precision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Precision |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
