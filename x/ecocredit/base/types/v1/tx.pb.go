// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: regen/ecocredit/v1/tx.proto

package v1

import (
	context "context"
	fmt "fmt"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/cosmos-sdk/types/msgservice"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	_ "github.com/cosmos/gogoproto/types"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MsgAddCreditType is the Msg/AddCreditType request type.
//
// Since Revision 2
type MsgAddCreditType struct {
	// authority is the address of the governance account.
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// credit_type defines a credit type to add to the credit types parameter.
	CreditType *CreditType `protobuf:"bytes,2,opt,name=credit_type,json=creditType,proto3" json:"credit_type,omitempty"`
}

func (m *MsgAddCreditType) Reset()         { *m = MsgAddCreditType{} }
func (m *MsgAddCreditType) String() string { return proto.CompactTextString(m) }
func (*MsgAddCreditType) ProtoMessage()    {}
func (*MsgAddCreditType) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{0}
}
func (m *MsgAddCreditType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAddCreditType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAddCreditType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAddCreditType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAddCreditType.Merge(m, src)
}
func (m *MsgAddCreditType) XXX_Size() int {
	return m.Size()
}
func (m *MsgAddCreditType) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAddCreditType.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAddCreditType proto.InternalMessageInfo

func (m *MsgAddCreditType) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgAddCreditType) GetCreditType() *CreditType {
	if m != nil {
		return m.CreditType
	}
	return nil
}

// MsgAddCreditTypeResponse is the Msg/AddCreditType response type.
//
// Since Revision 2
type MsgAddCreditTypeResponse struct {
}

func (m *MsgAddCreditTypeResponse) Reset()         { *m = MsgAddCreditTypeResponse{} }
func (m *MsgAddCreditTypeResponse) String() string { return proto.CompactTextString(m) }
func (*MsgAddCreditTypeResponse) ProtoMessage()    {}
func (*MsgAddCreditTypeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{1}
}
func (m *MsgAddCreditTypeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAddCreditTypeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAddCreditTypeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAddCreditTypeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAddCreditTypeResponse.Merge(m, src)
}
func (m *MsgAddCreditTypeResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgAddCreditTypeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAddCreditTypeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAddCreditTypeResponse proto.InternalMessageInfo

// MsgCreateClass is the Msg/CreateClass request type.
type MsgCreateClass struct {
	// admin is the address of the account creating the credit class that will
	// become the admin of the credit class upon creation. The admin will have
	// permissions within the credit class to update the credit class including
	// the list of approved issuers. If Params.allowlist_enabled is set to true,
	// this address must be included in Params.allowed_class_creators.
	Admin string `protobuf:"bytes,1,opt,name=admin,proto3" json:"admin,omitempty"`
	// issuers are the addresses of the accounts that will have permissions within
	// the credit class to create projects and issue credits.
	Issuers []string `protobuf:"bytes,2,rep,name=issuers,proto3" json:"issuers,omitempty"`
	// metadata is any arbitrary string with a maximum length of 256 characters
	// that includes or references metadata to attach to the credit class.
	Metadata string `protobuf:"bytes,3,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// credit_type_abbrev is the abbreviation of the credit type under which the
	// credit class will be created (e.g. "C", "BIO").
	CreditTypeAbbrev string `protobuf:"bytes,4,opt,name=credit_type_abbrev,json=creditTypeAbbrev,proto3" json:"credit_type_abbrev,omitempty"`
	// fee is the credit class creation fee. An equal fee is required if the class
	// creation fee parameter is set. The provided fee can be greater than the
	// parameter, but only the amount in the parameter will be charged.
	Fee *types.Coin `protobuf:"bytes,5,opt,name=fee,proto3" json:"fee,omitempty"`
}

func (m *MsgCreateClass) Reset()         { *m = MsgCreateClass{} }
func (m *MsgCreateClass) String() string { return proto.CompactTextString(m) }
func (*MsgCreateClass) ProtoMessage()    {}
func (*MsgCreateClass) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{2}
}
func (m *MsgCreateClass) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateClass) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateClass.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateClass) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateClass.Merge(m, src)
}
func (m *MsgCreateClass) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateClass) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateClass.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateClass proto.InternalMessageInfo

func (m *MsgCreateClass) GetAdmin() string {
	if m != nil {
		return m.Admin
	}
	return ""
}

func (m *MsgCreateClass) GetIssuers() []string {
	if m != nil {
		return m.Issuers
	}
	return nil
}

func (m *MsgCreateClass) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

func (m *MsgCreateClass) GetCreditTypeAbbrev() string {
	if m != nil {
		return m.CreditTypeAbbrev
	}
	return ""
}

func (m *MsgCreateClass) GetFee() *types.Coin {
	if m != nil {
		return m.Fee
	}
	return nil
}

// MsgCreateClassResponse is the Msg/CreateClass response type.
type MsgCreateClassResponse struct {
	// class_id is the unique identifier of the credit class.
	ClassId string `protobuf:"bytes,1,opt,name=class_id,json=classId,proto3" json:"class_id,omitempty"`
}

func (m *MsgCreateClassResponse) Reset()         { *m = MsgCreateClassResponse{} }
func (m *MsgCreateClassResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateClassResponse) ProtoMessage()    {}
func (*MsgCreateClassResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{3}
}
func (m *MsgCreateClassResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateClassResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateClassResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateClassResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateClassResponse.Merge(m, src)
}
func (m *MsgCreateClassResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateClassResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateClassResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateClassResponse proto.InternalMessageInfo

func (m *MsgCreateClassResponse) GetClassId() string {
	if m != nil {
		return m.ClassId
	}
	return ""
}

// MsgCreateProjectResponse is the Msg/CreateProject request type.
type MsgCreateProject struct {
	// admin is the address of the account creating the project that will become
	// the admin of the project upon creation. The creator of the project must be
	// an approved issuer within the credit class under which the project is being
	// created. The admin will have permissions to update the project including
	// the ability to reassign the admin role to another account.
	Admin string `protobuf:"bytes,1,opt,name=admin,proto3" json:"admin,omitempty"`
	// class_id is the unique identifier of the credit class under which the
	// project will be created.
	ClassId string `protobuf:"bytes,2,opt,name=class_id,json=classId,proto3" json:"class_id,omitempty"`
	// metadata is any arbitrary string with a maximum length of 256 characters
	// that includes or references metadata to attach to the project.
	Metadata string `protobuf:"bytes,3,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// jurisdiction is the jurisdiction of the project. A jurisdiction has with
	// the format: <country-code>[-<sub-national-code>[ <postal-code>]]
	// The country-code must be 2 alphabetic characters, the sub-national-code
	// can be 1-3 alphanumeric characters, and the postal-code can be up to 64
	// alphanumeric characters. Only the country-code is required, while the
	// sub-national-code and postal-code are optional and can be added for
	// increased precision.
	Jurisdiction string `protobuf:"bytes,4,opt,name=jurisdiction,proto3" json:"jurisdiction,omitempty"`
	// reference_id is any arbitrary string used to reference the project with a
	// maximum length of 32 characters.
	ReferenceId string `protobuf:"bytes,5,opt,name=reference_id,json=referenceId,proto3" json:"reference_id,omitempty"`
	// fee is the project creation fee. An equal fee is required if the project
	// creation fee parameter is set. The provided fee can be greater than the
	// parameter, but only the amount in the parameter will be charged.
	//
	// Since Revision 3
	Fee *types.Coin `protobuf:"bytes,6,opt,name=fee,proto3" json:"fee,omitempty"`
}

func (m *MsgCreateProject) Reset()         { *m = MsgCreateProject{} }
func (m *MsgCreateProject) String() string { return proto.CompactTextString(m) }
func (*MsgCreateProject) ProtoMessage()    {}
func (*MsgCreateProject) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{4}
}
func (m *MsgCreateProject) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateProject) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateProject.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateProject) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateProject.Merge(m, src)
}
func (m *MsgCreateProject) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateProject) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateProject.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateProject proto.InternalMessageInfo

func (m *MsgCreateProject) GetAdmin() string {
	if m != nil {
		return m.Admin
	}
	return ""
}

func (m *MsgCreateProject) GetClassId() string {
	if m != nil {
		return m.ClassId
	}
	return ""
}

func (m *MsgCreateProject) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

func (m *MsgCreateProject) GetJurisdiction() string {
	if m != nil {
		return m.Jurisdiction
	}
	return ""
}

func (m *MsgCreateProject) GetReferenceId() string {
	if m != nil {
		return m.ReferenceId
	}
	return ""
}

func (m *MsgCreateProject) GetFee() *types.Coin {
	if m != nil {
		return m.Fee
	}
	return nil
}

// MsgCreateProjectResponse is the Msg/CreateProject response type.
type MsgCreateProjectResponse struct {
	// project_id is the unique identifier of the project.
	ProjectId string `protobuf:"bytes,1,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
}

func (m *MsgCreateProjectResponse) Reset()         { *m = MsgCreateProjectResponse{} }
func (m *MsgCreateProjectResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateProjectResponse) ProtoMessage()    {}
func (*MsgCreateProjectResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{5}
}
func (m *MsgCreateProjectResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateProjectResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateProjectResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateProjectResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateProjectResponse.Merge(m, src)
}
func (m *MsgCreateProjectResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateProjectResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateProjectResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateProjectResponse proto.InternalMessageInfo

func (m *MsgCreateProjectResponse) GetProjectId() string {
	if m != nil {
		return m.ProjectId
	}
	return ""
}

// MsgCreateUnregisteredProject is the Msg/CreateUnregisteredProject request type.
type MsgCreateUnregisteredProject struct {
	// admin is the address of the account creating the project that will become
	// the admin of the project upon creation.
	Admin string `protobuf:"bytes,1,opt,name=admin,proto3" json:"admin,omitempty"`
	// metadata is any arbitrary string with a maximum length of 256 characters
	// that includes or references metadata to attach to the project.
	Metadata string `protobuf:"bytes,2,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// jurisdiction is the jurisdiction of the project. A jurisdiction has with
	// the format: <country-code>[-<sub-national-code>[ <postal-code>]]
	// The country-code must be 2 alphabetic characters, the sub-national-code
	// can be 1-3 alphanumeric characters, and the postal-code can be up to 64
	// alphanumeric characters. Only the country-code is required, while the
	// sub-national-code and postal-code are optional and can be added for
	// increased precision.
	Jurisdiction string `protobuf:"bytes,3,opt,name=jurisdiction,proto3" json:"jurisdiction,omitempty"`
	// reference_id is any arbitrary string used to reference the project with a
	// maximum length of 32 characters.
	ReferenceId string `protobuf:"bytes,4,opt,name=reference_id,json=referenceId,proto3" json:"reference_id,omitempty"`
	// fee is the project creation fee. An equal fee is required if the project
	// creation fee parameter is set. The provided fee can be greater than the
	// parameter, but only the amount in the parameter will be charged.
	//
	// Since Revision 3
	Fee *types.Coin `protobuf:"bytes,5,opt,name=fee,proto3" json:"fee,omitempty"`
}

func (m *MsgCreateUnregisteredProject) Reset()         { *m = MsgCreateUnregisteredProject{} }
func (m *MsgCreateUnregisteredProject) String() string { return proto.CompactTextString(m) }
func (*MsgCreateUnregisteredProject) ProtoMessage()    {}
func (*MsgCreateUnregisteredProject) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{6}
}
func (m *MsgCreateUnregisteredProject) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateUnregisteredProject) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateUnregisteredProject.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateUnregisteredProject) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateUnregisteredProject.Merge(m, src)
}
func (m *MsgCreateUnregisteredProject) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateUnregisteredProject) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateUnregisteredProject.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateUnregisteredProject proto.InternalMessageInfo

func (m *MsgCreateUnregisteredProject) GetAdmin() string {
	if m != nil {
		return m.Admin
	}
	return ""
}

func (m *MsgCreateUnregisteredProject) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

func (m *MsgCreateUnregisteredProject) GetJurisdiction() string {
	if m != nil {
		return m.Jurisdiction
	}
	return ""
}

func (m *MsgCreateUnregisteredProject) GetReferenceId() string {
	if m != nil {
		return m.ReferenceId
	}
	return ""
}

func (m *MsgCreateUnregisteredProject) GetFee() *types.Coin {
	if m != nil {
		return m.Fee
	}
	return nil
}

// MsgCreateUnregisteredProjectResponse is the Msg/CreateUnregisteredProject response type.
type MsgCreateUnregisteredProjectResponse struct {
	// project_id is the unique identifier of the project.
	ProjectId string `protobuf:"bytes,1,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
}

func (m *MsgCreateUnregisteredProjectResponse) Reset()         { *m = MsgCreateUnregisteredProjectResponse{} }
func (m *MsgCreateUnregisteredProjectResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateUnregisteredProjectResponse) ProtoMessage()    {}
func (*MsgCreateUnregisteredProjectResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{7}
}
func (m *MsgCreateUnregisteredProjectResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateUnregisteredProjectResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateUnregisteredProjectResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateUnregisteredProjectResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateUnregisteredProjectResponse.Merge(m, src)
}
func (m *MsgCreateUnregisteredProjectResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateUnregisteredProjectResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateUnregisteredProjectResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateUnregisteredProjectResponse proto.InternalMessageInfo

func (m *MsgCreateUnregisteredProjectResponse) GetProjectId() string {
	if m != nil {
		return m.ProjectId
	}
	return ""
}

// MsgCreateOrUpdateApplication is the Msg/CreateOrUpdateApplication request type.
type MsgCreateOrUpdateApplication struct {
	// project_admin is the address of the account that is the admin of the
	// project which is applying to the credit class.
	ProjectAdmin string `protobuf:"bytes,1,opt,name=project_admin,json=projectAdmin,proto3" json:"project_admin,omitempty"`
	// project_id is the identifier of the project which is applying to
	// the credit class.
	ProjectId string `protobuf:"bytes,2,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	// class_id is the identifier of the credit class which the project is
	// applying to.
	ClassId string `protobuf:"bytes,3,opt,name=class_id,json=classId,proto3" json:"class_id,omitempty"`
	// metadata is any optional arbitrary string with a maximum length of 256 characters
	// that includes or references any metadata relevant to the application.
	// This could be used as a digital reference to the actual contents of the application.
	Metadata string `protobuf:"bytes,4,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// withdraw is a boolean that indicates whether the application is being
	// withdrawn rather than updated.
	Withdraw bool `protobuf:"varint,5,opt,name=withdraw,proto3" json:"withdraw,omitempty"`
}

func (m *MsgCreateOrUpdateApplication) Reset()         { *m = MsgCreateOrUpdateApplication{} }
func (m *MsgCreateOrUpdateApplication) String() string { return proto.CompactTextString(m) }
func (*MsgCreateOrUpdateApplication) ProtoMessage()    {}
func (*MsgCreateOrUpdateApplication) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{8}
}
func (m *MsgCreateOrUpdateApplication) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateOrUpdateApplication) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateOrUpdateApplication.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateOrUpdateApplication) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateOrUpdateApplication.Merge(m, src)
}
func (m *MsgCreateOrUpdateApplication) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateOrUpdateApplication) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateOrUpdateApplication.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateOrUpdateApplication proto.InternalMessageInfo

func (m *MsgCreateOrUpdateApplication) GetProjectAdmin() string {
	if m != nil {
		return m.ProjectAdmin
	}
	return ""
}

func (m *MsgCreateOrUpdateApplication) GetProjectId() string {
	if m != nil {
		return m.ProjectId
	}
	return ""
}

func (m *MsgCreateOrUpdateApplication) GetClassId() string {
	if m != nil {
		return m.ClassId
	}
	return ""
}

func (m *MsgCreateOrUpdateApplication) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

func (m *MsgCreateOrUpdateApplication) GetWithdraw() bool {
	if m != nil {
		return m.Withdraw
	}
	return false
}

// MsgCreateOrUpdateApplicationResponse is the Msg/CreateOrUpdateApplication response type.
type MsgCreateOrUpdateApplicationResponse struct {
}

func (m *MsgCreateOrUpdateApplicationResponse) Reset()         { *m = MsgCreateOrUpdateApplicationResponse{} }
func (m *MsgCreateOrUpdateApplicationResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateOrUpdateApplicationResponse) ProtoMessage()    {}
func (*MsgCreateOrUpdateApplicationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{9}
}
func (m *MsgCreateOrUpdateApplicationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateOrUpdateApplicationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateOrUpdateApplicationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateOrUpdateApplicationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateOrUpdateApplicationResponse.Merge(m, src)
}
func (m *MsgCreateOrUpdateApplicationResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateOrUpdateApplicationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateOrUpdateApplicationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateOrUpdateApplicationResponse proto.InternalMessageInfo

// MsgUpdateProjectEnrollment is the Msg/UpdateProjectEnrollment request type.
type MsgUpdateProjectEnrollment struct {
	// issuer is the address of the account that is the issuer of the credit class
	// which is updating the project enrollment status.
	Issuer string `protobuf:"bytes,1,opt,name=issuer,proto3" json:"issuer,omitempty"`
	// project_id is the identifier of the project.
	ProjectId string `protobuf:"bytes,2,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	// class_id is the identifier of the credit class.
	ClassId string `protobuf:"bytes,3,opt,name=class_id,json=classId,proto3" json:"class_id,omitempty"`
	// new_status is the new status of the project enrollment.
	NewStatus ProjectEnrollmentStatus `protobuf:"varint,4,opt,name=new_status,json=newStatus,proto3,enum=regen.ecocredit.v1.ProjectEnrollmentStatus" json:"new_status,omitempty"`
	// metadata is any optiopnal arbitrary string with a maximum length of 256 characters
	// that includes or references the reason for the approving, requesting changes
	// to, or rejecting the application, or terminating the project.
	Metadata string `protobuf:"bytes,5,opt,name=metadata,proto3" json:"metadata,omitempty"`
}

func (m *MsgUpdateProjectEnrollment) Reset()         { *m = MsgUpdateProjectEnrollment{} }
func (m *MsgUpdateProjectEnrollment) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateProjectEnrollment) ProtoMessage()    {}
func (*MsgUpdateProjectEnrollment) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{10}
}
func (m *MsgUpdateProjectEnrollment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateProjectEnrollment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateProjectEnrollment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateProjectEnrollment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateProjectEnrollment.Merge(m, src)
}
func (m *MsgUpdateProjectEnrollment) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateProjectEnrollment) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateProjectEnrollment.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateProjectEnrollment proto.InternalMessageInfo

func (m *MsgUpdateProjectEnrollment) GetIssuer() string {
	if m != nil {
		return m.Issuer
	}
	return ""
}

func (m *MsgUpdateProjectEnrollment) GetProjectId() string {
	if m != nil {
		return m.ProjectId
	}
	return ""
}

func (m *MsgUpdateProjectEnrollment) GetClassId() string {
	if m != nil {
		return m.ClassId
	}
	return ""
}

func (m *MsgUpdateProjectEnrollment) GetNewStatus() ProjectEnrollmentStatus {
	if m != nil {
		return m.NewStatus
	}
	return ProjectEnrollmentStatus_PROJECT_ENROLLMENT_STATUS_UNSPECIFIED
}

func (m *MsgUpdateProjectEnrollment) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

// MsgEvaluateProjectEnrollmentResponse is the Msg/EvaluateProjectEnrollment response type.
type MsgUpdateProjectEnrollmentResponse struct {
}

func (m *MsgUpdateProjectEnrollmentResponse) Reset()         { *m = MsgUpdateProjectEnrollmentResponse{} }
func (m *MsgUpdateProjectEnrollmentResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateProjectEnrollmentResponse) ProtoMessage()    {}
func (*MsgUpdateProjectEnrollmentResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{11}
}
func (m *MsgUpdateProjectEnrollmentResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateProjectEnrollmentResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateProjectEnrollmentResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateProjectEnrollmentResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateProjectEnrollmentResponse.Merge(m, src)
}
func (m *MsgUpdateProjectEnrollmentResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateProjectEnrollmentResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateProjectEnrollmentResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateProjectEnrollmentResponse proto.InternalMessageInfo

// MsgCreateBatch is the Msg/CreateBatch request type.
type MsgCreateBatch struct {
	// issuer is the address of the account issuing the credits and must be an
	// approved issuer within a credit class of the project.
	Issuer string `protobuf:"bytes,1,opt,name=issuer,proto3" json:"issuer,omitempty"`
	// project_id is the unique identifier of the project under which the credit
	// batch will be created.
	ProjectId string `protobuf:"bytes,2,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	// issuance specifies the amount of tradable and retired credits that will be
	// issued to each recipient and the jurisdiction in which the credits will be
	// retired if credits are to be retired upon receipt.
	Issuance []*BatchIssuance `protobuf:"bytes,3,rep,name=issuance,proto3" json:"issuance,omitempty"`
	// metadata is any arbitrary string with a maximum length of 256 characters
	// that includes or references metadata to attach to the credit batch.
	Metadata string `protobuf:"bytes,4,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// start_date is the beginning of the period during which this credit batch
	// was quantified and verified.
	StartDate *time.Time `protobuf:"bytes,5,opt,name=start_date,json=startDate,proto3,stdtime" json:"start_date,omitempty"`
	// end_date is the end of the period during which this credit batch was
	// quantified and verified.
	EndDate *time.Time `protobuf:"bytes,6,opt,name=end_date,json=endDate,proto3,stdtime" json:"end_date,omitempty"`
	// open determines whether or not the credits can be dynamically minted to the
	// credit batch following the creation of the credit batch. This field should
	// only be set to true when bridging credits from another chain or registry as
	// a result of a bridge operation and is not intended for native issuance.
	Open bool `protobuf:"varint,7,opt,name=open,proto3" json:"open,omitempty"`
	// origin_tx is the transaction from another chain or registry that triggered
	// the creation of the credit batch. This field can be ignored when natively
	// issuing credits and should only be set when bridging assets from another
	// chain or registry as a result of a bridge operation.
	OriginTx *OriginTx `protobuf:"bytes,8,opt,name=origin_tx,json=originTx,proto3" json:"origin_tx,omitempty"`
	// class_id is the unique identifier of the credit class under which the
	// credit batch will be created.
	//
	// Since Revision 3
	ClassId string `protobuf:"bytes,9,opt,name=class_id,json=classId,proto3" json:"class_id,omitempty"`
}

func (m *MsgCreateBatch) Reset()         { *m = MsgCreateBatch{} }
func (m *MsgCreateBatch) String() string { return proto.CompactTextString(m) }
func (*MsgCreateBatch) ProtoMessage()    {}
func (*MsgCreateBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{12}
}
func (m *MsgCreateBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateBatch.Merge(m, src)
}
func (m *MsgCreateBatch) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateBatch.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateBatch proto.InternalMessageInfo

func (m *MsgCreateBatch) GetIssuer() string {
	if m != nil {
		return m.Issuer
	}
	return ""
}

func (m *MsgCreateBatch) GetProjectId() string {
	if m != nil {
		return m.ProjectId
	}
	return ""
}

func (m *MsgCreateBatch) GetIssuance() []*BatchIssuance {
	if m != nil {
		return m.Issuance
	}
	return nil
}

func (m *MsgCreateBatch) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

func (m *MsgCreateBatch) GetStartDate() *time.Time {
	if m != nil {
		return m.StartDate
	}
	return nil
}

func (m *MsgCreateBatch) GetEndDate() *time.Time {
	if m != nil {
		return m.EndDate
	}
	return nil
}

func (m *MsgCreateBatch) GetOpen() bool {
	if m != nil {
		return m.Open
	}
	return false
}

func (m *MsgCreateBatch) GetOriginTx() *OriginTx {
	if m != nil {
		return m.OriginTx
	}
	return nil
}

func (m *MsgCreateBatch) GetClassId() string {
	if m != nil {
		return m.ClassId
	}
	return ""
}

// MsgCreateBatchResponse is the Msg/CreateBatch response type.
type MsgCreateBatchResponse struct {
	// batch_denom is the unique identifier of the credit batch.
	BatchDenom string `protobuf:"bytes,1,opt,name=batch_denom,json=batchDenom,proto3" json:"batch_denom,omitempty"`
}

func (m *MsgCreateBatchResponse) Reset()         { *m = MsgCreateBatchResponse{} }
func (m *MsgCreateBatchResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateBatchResponse) ProtoMessage()    {}
func (*MsgCreateBatchResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{13}
}
func (m *MsgCreateBatchResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateBatchResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateBatchResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateBatchResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateBatchResponse.Merge(m, src)
}
func (m *MsgCreateBatchResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateBatchResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateBatchResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateBatchResponse proto.InternalMessageInfo

func (m *MsgCreateBatchResponse) GetBatchDenom() string {
	if m != nil {
		return m.BatchDenom
	}
	return ""
}

// MsgMintBatchCredits is the Msg/MintBatchCredits request type.
type MsgMintBatchCredits struct {
	// issuer is the address of the account minting the credits and must be the
	// same issuer who created the credit batch.
	Issuer string `protobuf:"bytes,1,opt,name=issuer,proto3" json:"issuer,omitempty"`
	// batch_denom is the unique identifier of the credit batch.
	BatchDenom string `protobuf:"bytes,2,opt,name=batch_denom,json=batchDenom,proto3" json:"batch_denom,omitempty"`
	// issuance specifies the amount of tradable and retired credits that will be
	// issued to each recipient and the jurisdiction in which the credits will be
	// retired if credits are to be retired upon receipt.
	Issuance []*BatchIssuance `protobuf:"bytes,3,rep,name=issuance,proto3" json:"issuance,omitempty"`
	// origin_tx is the transaction from another chain or registry that triggered
	// the minting of credits.
	OriginTx *OriginTx `protobuf:"bytes,4,opt,name=origin_tx,json=originTx,proto3" json:"origin_tx,omitempty"`
}

func (m *MsgMintBatchCredits) Reset()         { *m = MsgMintBatchCredits{} }
func (m *MsgMintBatchCredits) String() string { return proto.CompactTextString(m) }
func (*MsgMintBatchCredits) ProtoMessage()    {}
func (*MsgMintBatchCredits) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{14}
}
func (m *MsgMintBatchCredits) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgMintBatchCredits) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgMintBatchCredits.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgMintBatchCredits) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgMintBatchCredits.Merge(m, src)
}
func (m *MsgMintBatchCredits) XXX_Size() int {
	return m.Size()
}
func (m *MsgMintBatchCredits) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgMintBatchCredits.DiscardUnknown(m)
}

var xxx_messageInfo_MsgMintBatchCredits proto.InternalMessageInfo

func (m *MsgMintBatchCredits) GetIssuer() string {
	if m != nil {
		return m.Issuer
	}
	return ""
}

func (m *MsgMintBatchCredits) GetBatchDenom() string {
	if m != nil {
		return m.BatchDenom
	}
	return ""
}

func (m *MsgMintBatchCredits) GetIssuance() []*BatchIssuance {
	if m != nil {
		return m.Issuance
	}
	return nil
}

func (m *MsgMintBatchCredits) GetOriginTx() *OriginTx {
	if m != nil {
		return m.OriginTx
	}
	return nil
}

// MsgMintBatchCreditsResponse is the Msg/MintBatchCredits response type.
type MsgMintBatchCreditsResponse struct {
}

func (m *MsgMintBatchCreditsResponse) Reset()         { *m = MsgMintBatchCreditsResponse{} }
func (m *MsgMintBatchCreditsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgMintBatchCreditsResponse) ProtoMessage()    {}
func (*MsgMintBatchCreditsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{15}
}
func (m *MsgMintBatchCreditsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgMintBatchCreditsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgMintBatchCreditsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgMintBatchCreditsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgMintBatchCreditsResponse.Merge(m, src)
}
func (m *MsgMintBatchCreditsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgMintBatchCreditsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgMintBatchCreditsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgMintBatchCreditsResponse proto.InternalMessageInfo

// MsgSealBatch is the Msg/MintBatchCredits request type.
type MsgSealBatch struct {
	// issuer is the address of the account that created the credit batch and the
	// only account with permissions to seal the credit batch.
	Issuer string `protobuf:"bytes,1,opt,name=issuer,proto3" json:"issuer,omitempty"`
	// batch_denom is the unique identifier of the credit batch.
	BatchDenom string `protobuf:"bytes,2,opt,name=batch_denom,json=batchDenom,proto3" json:"batch_denom,omitempty"`
}

func (m *MsgSealBatch) Reset()         { *m = MsgSealBatch{} }
func (m *MsgSealBatch) String() string { return proto.CompactTextString(m) }
func (*MsgSealBatch) ProtoMessage()    {}
func (*MsgSealBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{16}
}
func (m *MsgSealBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSealBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSealBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSealBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSealBatch.Merge(m, src)
}
func (m *MsgSealBatch) XXX_Size() int {
	return m.Size()
}
func (m *MsgSealBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSealBatch.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSealBatch proto.InternalMessageInfo

func (m *MsgSealBatch) GetIssuer() string {
	if m != nil {
		return m.Issuer
	}
	return ""
}

func (m *MsgSealBatch) GetBatchDenom() string {
	if m != nil {
		return m.BatchDenom
	}
	return ""
}

// MsgSealBatchResponse is the Msg/SealBatch response type.
type MsgSealBatchResponse struct {
}

func (m *MsgSealBatchResponse) Reset()         { *m = MsgSealBatchResponse{} }
func (m *MsgSealBatchResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSealBatchResponse) ProtoMessage()    {}
func (*MsgSealBatchResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{17}
}
func (m *MsgSealBatchResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSealBatchResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSealBatchResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSealBatchResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSealBatchResponse.Merge(m, src)
}
func (m *MsgSealBatchResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSealBatchResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSealBatchResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSealBatchResponse proto.InternalMessageInfo

// MsgSend is the Msg/Send request type.
type MsgSend struct {
	// sender is the address of the account sending credits.
	Sender string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	// recipient is the address of the account receiving credits.
	Recipient string `protobuf:"bytes,2,opt,name=recipient,proto3" json:"recipient,omitempty"`
	// credits are the credits being sent to the recipient.
	Credits []*MsgSend_SendCredits `protobuf:"bytes,3,rep,name=credits,proto3" json:"credits,omitempty"`
}

func (m *MsgSend) Reset()         { *m = MsgSend{} }
func (m *MsgSend) String() string { return proto.CompactTextString(m) }
func (*MsgSend) ProtoMessage()    {}
func (*MsgSend) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{18}
}
func (m *MsgSend) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSend) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSend.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSend) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSend.Merge(m, src)
}
func (m *MsgSend) XXX_Size() int {
	return m.Size()
}
func (m *MsgSend) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSend.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSend proto.InternalMessageInfo

func (m *MsgSend) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgSend) GetRecipient() string {
	if m != nil {
		return m.Recipient
	}
	return ""
}

func (m *MsgSend) GetCredits() []*MsgSend_SendCredits {
	if m != nil {
		return m.Credits
	}
	return nil
}

// SendCredits specifies the amount of tradable and retired credits of a
// credit batch that will be sent to the recipient and the jurisdiction in
// which the credits will be retired upon receipt.
type MsgSend_SendCredits struct {
	// batch_denom is the unique identifier of the credit batch.
	BatchDenom string `protobuf:"bytes,1,opt,name=batch_denom,json=batchDenom,proto3" json:"batch_denom,omitempty"`
	// tradable_amount is the amount of credits in this transfer that can be
	// traded by the recipient. The number of decimal places must be less than
	// or equal to the credit type precision.
	TradableAmount string `protobuf:"bytes,2,opt,name=tradable_amount,json=tradableAmount,proto3" json:"tradable_amount,omitempty"`
	// retired_amount is the amount of credits in this transfer that are retired
	// upon receipt. The number of decimal places must be less than or equal to
	// the credit type precision.
	RetiredAmount string `protobuf:"bytes,3,opt,name=retired_amount,json=retiredAmount,proto3" json:"retired_amount,omitempty"`
	// retirement_jurisdiction is the jurisdiction of the recipient and is only
	// required if retired_amount is positive. A jurisdiction has the format:
	// <country-code>[-<sub-national-code>[ <postal-code>]]
	// The country-code and sub-national-code must conform to ISO 3166-2 and the
	// postal-code can be up to 64 alphanumeric characters. Only the
	// country-code is required, while the sub-national-code and postal-code are
	// optional and can be added for increased precision.
	RetirementJurisdiction string `protobuf:"bytes,4,opt,name=retirement_jurisdiction,json=retirementJurisdiction,proto3" json:"retirement_jurisdiction,omitempty"`
	// retirement_reason is any arbitrary string that specifies the reason for
	// retiring credits. This field is only required if retired_amount is
	// positive.
	//
	// Since Revision 2
	RetirementReason string `protobuf:"bytes,5,opt,name=retirement_reason,json=retirementReason,proto3" json:"retirement_reason,omitempty"`
}

func (m *MsgSend_SendCredits) Reset()         { *m = MsgSend_SendCredits{} }
func (m *MsgSend_SendCredits) String() string { return proto.CompactTextString(m) }
func (*MsgSend_SendCredits) ProtoMessage()    {}
func (*MsgSend_SendCredits) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{18, 0}
}
func (m *MsgSend_SendCredits) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSend_SendCredits) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSend_SendCredits.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSend_SendCredits) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSend_SendCredits.Merge(m, src)
}
func (m *MsgSend_SendCredits) XXX_Size() int {
	return m.Size()
}
func (m *MsgSend_SendCredits) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSend_SendCredits.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSend_SendCredits proto.InternalMessageInfo

func (m *MsgSend_SendCredits) GetBatchDenom() string {
	if m != nil {
		return m.BatchDenom
	}
	return ""
}

func (m *MsgSend_SendCredits) GetTradableAmount() string {
	if m != nil {
		return m.TradableAmount
	}
	return ""
}

func (m *MsgSend_SendCredits) GetRetiredAmount() string {
	if m != nil {
		return m.RetiredAmount
	}
	return ""
}

func (m *MsgSend_SendCredits) GetRetirementJurisdiction() string {
	if m != nil {
		return m.RetirementJurisdiction
	}
	return ""
}

func (m *MsgSend_SendCredits) GetRetirementReason() string {
	if m != nil {
		return m.RetirementReason
	}
	return ""
}

// MsgSendResponse is the Msg/Send response type.
type MsgSendResponse struct {
}

func (m *MsgSendResponse) Reset()         { *m = MsgSendResponse{} }
func (m *MsgSendResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSendResponse) ProtoMessage()    {}
func (*MsgSendResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{19}
}
func (m *MsgSendResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSendResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSendResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSendResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSendResponse.Merge(m, src)
}
func (m *MsgSendResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSendResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSendResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSendResponse proto.InternalMessageInfo

// MsgRetire is the Msg/Retire request type.
type MsgRetire struct {
	// owner is the address of the account that owns the credits being retired.
	Owner string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	// credits specifies a credit batch and the number of credits being retired.
	Credits []*Credits `protobuf:"bytes,2,rep,name=credits,proto3" json:"credits,omitempty"`
	// jurisdiction is the jurisdiction of the credit owner. A jurisdiction has
	// the format: <country-code>[-<sub-national-code>[ <postal-code>]]
	// The country-code must be 2 alphabetic characters, the sub-national-code
	// can be 1-3 alphanumeric characters, and the postal-code can be up to 64
	// alphanumeric characters. Only the country-code is required, while the
	// sub-national-code and postal-code are optional and can be added for
	// increased precision.
	Jurisdiction string `protobuf:"bytes,3,opt,name=jurisdiction,proto3" json:"jurisdiction,omitempty"`
	// reason is any arbitrary string that specifies the reason for retiring
	// credits.
	//
	// Since Revision 2
	Reason string `protobuf:"bytes,4,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *MsgRetire) Reset()         { *m = MsgRetire{} }
func (m *MsgRetire) String() string { return proto.CompactTextString(m) }
func (*MsgRetire) ProtoMessage()    {}
func (*MsgRetire) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{20}
}
func (m *MsgRetire) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRetire) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRetire.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRetire) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRetire.Merge(m, src)
}
func (m *MsgRetire) XXX_Size() int {
	return m.Size()
}
func (m *MsgRetire) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRetire.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRetire proto.InternalMessageInfo

func (m *MsgRetire) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *MsgRetire) GetCredits() []*Credits {
	if m != nil {
		return m.Credits
	}
	return nil
}

func (m *MsgRetire) GetJurisdiction() string {
	if m != nil {
		return m.Jurisdiction
	}
	return ""
}

func (m *MsgRetire) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

// MsgRetire is the Msg/Retire response type.
type MsgRetireResponse struct {
}

func (m *MsgRetireResponse) Reset()         { *m = MsgRetireResponse{} }
func (m *MsgRetireResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRetireResponse) ProtoMessage()    {}
func (*MsgRetireResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{21}
}
func (m *MsgRetireResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRetireResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRetireResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRetireResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRetireResponse.Merge(m, src)
}
func (m *MsgRetireResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRetireResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRetireResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRetireResponse proto.InternalMessageInfo

// MsgCancel is the Msg/Cancel request type.
type MsgCancel struct {
	// owner is the address of the account that owns the credits being cancelled.
	Owner string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	// credits specifies a credit batch and the number of credits being cancelled.
	Credits []*Credits `protobuf:"bytes,2,rep,name=credits,proto3" json:"credits,omitempty"`
	// reason is any arbitrary string that specifies the reason for cancelling
	// credits.
	Reason string `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *MsgCancel) Reset()         { *m = MsgCancel{} }
func (m *MsgCancel) String() string { return proto.CompactTextString(m) }
func (*MsgCancel) ProtoMessage()    {}
func (*MsgCancel) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{22}
}
func (m *MsgCancel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCancel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCancel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCancel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCancel.Merge(m, src)
}
func (m *MsgCancel) XXX_Size() int {
	return m.Size()
}
func (m *MsgCancel) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCancel.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCancel proto.InternalMessageInfo

func (m *MsgCancel) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *MsgCancel) GetCredits() []*Credits {
	if m != nil {
		return m.Credits
	}
	return nil
}

func (m *MsgCancel) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

// MsgCancelResponse is the Msg/Cancel response type.
type MsgCancelResponse struct {
}

func (m *MsgCancelResponse) Reset()         { *m = MsgCancelResponse{} }
func (m *MsgCancelResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCancelResponse) ProtoMessage()    {}
func (*MsgCancelResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{23}
}
func (m *MsgCancelResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCancelResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCancelResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCancelResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCancelResponse.Merge(m, src)
}
func (m *MsgCancelResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCancelResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCancelResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCancelResponse proto.InternalMessageInfo

// MsgUpdateClassAdmin is the Msg/UpdateClassAdmin request type.
type MsgUpdateClassAdmin struct {
	// admin is the address of the account that is currently the admin of the
	// credit class.
	Admin string `protobuf:"bytes,1,opt,name=admin,proto3" json:"admin,omitempty"`
	// class_id is the unique identifier of the credit class.
	ClassId string `protobuf:"bytes,2,opt,name=class_id,json=classId,proto3" json:"class_id,omitempty"`
	// new_admin is the address of the account that will become the new admin of
	// the credit class.
	NewAdmin string `protobuf:"bytes,3,opt,name=new_admin,json=newAdmin,proto3" json:"new_admin,omitempty"`
}

func (m *MsgUpdateClassAdmin) Reset()         { *m = MsgUpdateClassAdmin{} }
func (m *MsgUpdateClassAdmin) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateClassAdmin) ProtoMessage()    {}
func (*MsgUpdateClassAdmin) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{24}
}
func (m *MsgUpdateClassAdmin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateClassAdmin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateClassAdmin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateClassAdmin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateClassAdmin.Merge(m, src)
}
func (m *MsgUpdateClassAdmin) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateClassAdmin) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateClassAdmin.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateClassAdmin proto.InternalMessageInfo

func (m *MsgUpdateClassAdmin) GetAdmin() string {
	if m != nil {
		return m.Admin
	}
	return ""
}

func (m *MsgUpdateClassAdmin) GetClassId() string {
	if m != nil {
		return m.ClassId
	}
	return ""
}

func (m *MsgUpdateClassAdmin) GetNewAdmin() string {
	if m != nil {
		return m.NewAdmin
	}
	return ""
}

// MsgUpdateClassAdminResponse is the MsgUpdateClassAdmin response type.
type MsgUpdateClassAdminResponse struct {
}

func (m *MsgUpdateClassAdminResponse) Reset()         { *m = MsgUpdateClassAdminResponse{} }
func (m *MsgUpdateClassAdminResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateClassAdminResponse) ProtoMessage()    {}
func (*MsgUpdateClassAdminResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{25}
}
func (m *MsgUpdateClassAdminResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateClassAdminResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateClassAdminResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateClassAdminResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateClassAdminResponse.Merge(m, src)
}
func (m *MsgUpdateClassAdminResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateClassAdminResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateClassAdminResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateClassAdminResponse proto.InternalMessageInfo

// MsgUpdateClassIssuers is the Msg/UpdateClassIssuers request type.
type MsgUpdateClassIssuers struct {
	// admin is the address of the account that is the admin of the credit class.
	Admin string `protobuf:"bytes,1,opt,name=admin,proto3" json:"admin,omitempty"`
	// class_id is the unique identifier of the credit class.
	ClassId string `protobuf:"bytes,2,opt,name=class_id,json=classId,proto3" json:"class_id,omitempty"`
	// add_issuers are the addresses of the accounts that will be added to the
	// list of approved credit class issuers.
	AddIssuers []string `protobuf:"bytes,3,rep,name=add_issuers,json=addIssuers,proto3" json:"add_issuers,omitempty"`
	// remove_issuers are the addresses of the accounts that will be removed from
	// the list of approved credit class issuers.
	RemoveIssuers []string `protobuf:"bytes,4,rep,name=remove_issuers,json=removeIssuers,proto3" json:"remove_issuers,omitempty"`
}

func (m *MsgUpdateClassIssuers) Reset()         { *m = MsgUpdateClassIssuers{} }
func (m *MsgUpdateClassIssuers) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateClassIssuers) ProtoMessage()    {}
func (*MsgUpdateClassIssuers) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{26}
}
func (m *MsgUpdateClassIssuers) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateClassIssuers) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateClassIssuers.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateClassIssuers) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateClassIssuers.Merge(m, src)
}
func (m *MsgUpdateClassIssuers) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateClassIssuers) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateClassIssuers.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateClassIssuers proto.InternalMessageInfo

func (m *MsgUpdateClassIssuers) GetAdmin() string {
	if m != nil {
		return m.Admin
	}
	return ""
}

func (m *MsgUpdateClassIssuers) GetClassId() string {
	if m != nil {
		return m.ClassId
	}
	return ""
}

func (m *MsgUpdateClassIssuers) GetAddIssuers() []string {
	if m != nil {
		return m.AddIssuers
	}
	return nil
}

func (m *MsgUpdateClassIssuers) GetRemoveIssuers() []string {
	if m != nil {
		return m.RemoveIssuers
	}
	return nil
}

// MsgUpdateClassIssuersResponse is the MsgUpdateClassIssuers response type.
type MsgUpdateClassIssuersResponse struct {
}

func (m *MsgUpdateClassIssuersResponse) Reset()         { *m = MsgUpdateClassIssuersResponse{} }
func (m *MsgUpdateClassIssuersResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateClassIssuersResponse) ProtoMessage()    {}
func (*MsgUpdateClassIssuersResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{27}
}
func (m *MsgUpdateClassIssuersResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateClassIssuersResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateClassIssuersResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateClassIssuersResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateClassIssuersResponse.Merge(m, src)
}
func (m *MsgUpdateClassIssuersResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateClassIssuersResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateClassIssuersResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateClassIssuersResponse proto.InternalMessageInfo

// MsgUpdateClassMetadata is the Msg/UpdateClassMetadata request type.
type MsgUpdateClassMetadata struct {
	// admin is the address of the account that is the admin of the credit class.
	Admin string `protobuf:"bytes,1,opt,name=admin,proto3" json:"admin,omitempty"`
	// class_id is the unique identifier of the credit class.
	ClassId string `protobuf:"bytes,2,opt,name=class_id,json=classId,proto3" json:"class_id,omitempty"`
	// new_metadata is new metadata that will replace the existing metadata. It
	// can be any arbitrary string with a maximum length of 256 characters that
	// includes or references the metadata to attach to the credit class.
	NewMetadata string `protobuf:"bytes,3,opt,name=new_metadata,json=newMetadata,proto3" json:"new_metadata,omitempty"`
}

func (m *MsgUpdateClassMetadata) Reset()         { *m = MsgUpdateClassMetadata{} }
func (m *MsgUpdateClassMetadata) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateClassMetadata) ProtoMessage()    {}
func (*MsgUpdateClassMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{28}
}
func (m *MsgUpdateClassMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateClassMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateClassMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateClassMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateClassMetadata.Merge(m, src)
}
func (m *MsgUpdateClassMetadata) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateClassMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateClassMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateClassMetadata proto.InternalMessageInfo

func (m *MsgUpdateClassMetadata) GetAdmin() string {
	if m != nil {
		return m.Admin
	}
	return ""
}

func (m *MsgUpdateClassMetadata) GetClassId() string {
	if m != nil {
		return m.ClassId
	}
	return ""
}

func (m *MsgUpdateClassMetadata) GetNewMetadata() string {
	if m != nil {
		return m.NewMetadata
	}
	return ""
}

// MsgUpdateClassMetadataResponse is the Msg/UpdateClassMetadata response type.
type MsgUpdateClassMetadataResponse struct {
}

func (m *MsgUpdateClassMetadataResponse) Reset()         { *m = MsgUpdateClassMetadataResponse{} }
func (m *MsgUpdateClassMetadataResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateClassMetadataResponse) ProtoMessage()    {}
func (*MsgUpdateClassMetadataResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{29}
}
func (m *MsgUpdateClassMetadataResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateClassMetadataResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateClassMetadataResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateClassMetadataResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateClassMetadataResponse.Merge(m, src)
}
func (m *MsgUpdateClassMetadataResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateClassMetadataResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateClassMetadataResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateClassMetadataResponse proto.InternalMessageInfo

// MsgUpdateProjectAdmin is the Msg/UpdateProjectAdmin request type.
type MsgUpdateProjectAdmin struct {
	// admin is the address of the account that is the currently the admin of the
	// project.
	Admin string `protobuf:"bytes,1,opt,name=admin,proto3" json:"admin,omitempty"`
	// project_id is the unique identifier of the project.
	ProjectId string `protobuf:"bytes,2,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	// new_admin is the address of the account that will become the new admin of
	// the project.
	NewAdmin string `protobuf:"bytes,3,opt,name=new_admin,json=newAdmin,proto3" json:"new_admin,omitempty"`
}

func (m *MsgUpdateProjectAdmin) Reset()         { *m = MsgUpdateProjectAdmin{} }
func (m *MsgUpdateProjectAdmin) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateProjectAdmin) ProtoMessage()    {}
func (*MsgUpdateProjectAdmin) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{30}
}
func (m *MsgUpdateProjectAdmin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateProjectAdmin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateProjectAdmin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateProjectAdmin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateProjectAdmin.Merge(m, src)
}
func (m *MsgUpdateProjectAdmin) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateProjectAdmin) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateProjectAdmin.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateProjectAdmin proto.InternalMessageInfo

func (m *MsgUpdateProjectAdmin) GetAdmin() string {
	if m != nil {
		return m.Admin
	}
	return ""
}

func (m *MsgUpdateProjectAdmin) GetProjectId() string {
	if m != nil {
		return m.ProjectId
	}
	return ""
}

func (m *MsgUpdateProjectAdmin) GetNewAdmin() string {
	if m != nil {
		return m.NewAdmin
	}
	return ""
}

// MsgUpdateProjectAdmin is the Msg/UpdateProjectAdmin response type.
type MsgUpdateProjectAdminResponse struct {
}

func (m *MsgUpdateProjectAdminResponse) Reset()         { *m = MsgUpdateProjectAdminResponse{} }
func (m *MsgUpdateProjectAdminResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateProjectAdminResponse) ProtoMessage()    {}
func (*MsgUpdateProjectAdminResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{31}
}
func (m *MsgUpdateProjectAdminResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateProjectAdminResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateProjectAdminResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateProjectAdminResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateProjectAdminResponse.Merge(m, src)
}
func (m *MsgUpdateProjectAdminResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateProjectAdminResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateProjectAdminResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateProjectAdminResponse proto.InternalMessageInfo

// MsgUpdateProjectMetadata is the Msg/UpdateProjectMetadata request type.
type MsgUpdateProjectMetadata struct {
	// admin is the address of the account that is the admin of the project.
	Admin string `protobuf:"bytes,1,opt,name=admin,proto3" json:"admin,omitempty"`
	// project_id is the unique identifier of the project.
	ProjectId string `protobuf:"bytes,2,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	// new_metadata is new metadata that will replace the existing metadata. It
	// can be any arbitrary string with a maximum length of 256 characters that
	// includes or references the metadata to attach to the project.
	NewMetadata string `protobuf:"bytes,3,opt,name=new_metadata,json=newMetadata,proto3" json:"new_metadata,omitempty"`
}

func (m *MsgUpdateProjectMetadata) Reset()         { *m = MsgUpdateProjectMetadata{} }
func (m *MsgUpdateProjectMetadata) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateProjectMetadata) ProtoMessage()    {}
func (*MsgUpdateProjectMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{32}
}
func (m *MsgUpdateProjectMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateProjectMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateProjectMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateProjectMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateProjectMetadata.Merge(m, src)
}
func (m *MsgUpdateProjectMetadata) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateProjectMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateProjectMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateProjectMetadata proto.InternalMessageInfo

func (m *MsgUpdateProjectMetadata) GetAdmin() string {
	if m != nil {
		return m.Admin
	}
	return ""
}

func (m *MsgUpdateProjectMetadata) GetProjectId() string {
	if m != nil {
		return m.ProjectId
	}
	return ""
}

func (m *MsgUpdateProjectMetadata) GetNewMetadata() string {
	if m != nil {
		return m.NewMetadata
	}
	return ""
}

// MsgUpdateProjectMetadataResponse is the Msg/UpdateProjectMetadataResponse
// response type.
type MsgUpdateProjectMetadataResponse struct {
}

func (m *MsgUpdateProjectMetadataResponse) Reset()         { *m = MsgUpdateProjectMetadataResponse{} }
func (m *MsgUpdateProjectMetadataResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateProjectMetadataResponse) ProtoMessage()    {}
func (*MsgUpdateProjectMetadataResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{33}
}
func (m *MsgUpdateProjectMetadataResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateProjectMetadataResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateProjectMetadataResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateProjectMetadataResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateProjectMetadataResponse.Merge(m, src)
}
func (m *MsgUpdateProjectMetadataResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateProjectMetadataResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateProjectMetadataResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateProjectMetadataResponse proto.InternalMessageInfo

// MsgBridge is the Msg/Bridge request type.
type MsgBridge struct {
	// owner is the address of the account that owns the credits being bridged.
	Owner string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	// target is the name of the target chain or registry.
	Target string `protobuf:"bytes,2,opt,name=target,proto3" json:"target,omitempty"`
	// recipient is the address of the account receiving the bridged credits.
	Recipient string `protobuf:"bytes,3,opt,name=recipient,proto3" json:"recipient,omitempty"`
	// credits specifies a credit batch and the number of credits being bridged.
	Credits []*Credits `protobuf:"bytes,4,rep,name=credits,proto3" json:"credits,omitempty"`
}

func (m *MsgBridge) Reset()         { *m = MsgBridge{} }
func (m *MsgBridge) String() string { return proto.CompactTextString(m) }
func (*MsgBridge) ProtoMessage()    {}
func (*MsgBridge) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{34}
}
func (m *MsgBridge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBridge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBridge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBridge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBridge.Merge(m, src)
}
func (m *MsgBridge) XXX_Size() int {
	return m.Size()
}
func (m *MsgBridge) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBridge.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBridge proto.InternalMessageInfo

func (m *MsgBridge) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *MsgBridge) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

func (m *MsgBridge) GetRecipient() string {
	if m != nil {
		return m.Recipient
	}
	return ""
}

func (m *MsgBridge) GetCredits() []*Credits {
	if m != nil {
		return m.Credits
	}
	return nil
}

// MsgUpdateBatchMetadata is the Msg/UpdateBatchMetadata request type.
//
// Since Revision 2
type MsgUpdateBatchMetadata struct {
	// issuer is the address of the account that is the issuer of the batch.
	Issuer string `protobuf:"bytes,1,opt,name=issuer,proto3" json:"issuer,omitempty"`
	// batch_denom is the unique identifier of the batch.
	BatchDenom string `protobuf:"bytes,2,opt,name=batch_denom,json=batchDenom,proto3" json:"batch_denom,omitempty"`
	// new_metadata is new metadata that will replace the existing metadata. It
	// can be any arbitrary string with a maximum length of 256 characters that
	// includes or references the metadata to attach to the batch.
	NewMetadata string `protobuf:"bytes,3,opt,name=new_metadata,json=newMetadata,proto3" json:"new_metadata,omitempty"`
}

func (m *MsgUpdateBatchMetadata) Reset()         { *m = MsgUpdateBatchMetadata{} }
func (m *MsgUpdateBatchMetadata) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateBatchMetadata) ProtoMessage()    {}
func (*MsgUpdateBatchMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{35}
}
func (m *MsgUpdateBatchMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateBatchMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateBatchMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateBatchMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateBatchMetadata.Merge(m, src)
}
func (m *MsgUpdateBatchMetadata) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateBatchMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateBatchMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateBatchMetadata proto.InternalMessageInfo

func (m *MsgUpdateBatchMetadata) GetIssuer() string {
	if m != nil {
		return m.Issuer
	}
	return ""
}

func (m *MsgUpdateBatchMetadata) GetBatchDenom() string {
	if m != nil {
		return m.BatchDenom
	}
	return ""
}

func (m *MsgUpdateBatchMetadata) GetNewMetadata() string {
	if m != nil {
		return m.NewMetadata
	}
	return ""
}

// MsgUpdateBatchMetadataResponse is the Msg/UpdateBatchMetadataResponse
// response type.
//
// Since Revision 2
type MsgUpdateBatchMetadataResponse struct {
}

func (m *MsgUpdateBatchMetadataResponse) Reset()         { *m = MsgUpdateBatchMetadataResponse{} }
func (m *MsgUpdateBatchMetadataResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateBatchMetadataResponse) ProtoMessage()    {}
func (*MsgUpdateBatchMetadataResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{36}
}
func (m *MsgUpdateBatchMetadataResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateBatchMetadataResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateBatchMetadataResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateBatchMetadataResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateBatchMetadataResponse.Merge(m, src)
}
func (m *MsgUpdateBatchMetadataResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateBatchMetadataResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateBatchMetadataResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateBatchMetadataResponse proto.InternalMessageInfo

// MsgBridgeResponse is the Msg/Bridge response type.
type MsgBridgeResponse struct {
}

func (m *MsgBridgeResponse) Reset()         { *m = MsgBridgeResponse{} }
func (m *MsgBridgeResponse) String() string { return proto.CompactTextString(m) }
func (*MsgBridgeResponse) ProtoMessage()    {}
func (*MsgBridgeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{37}
}
func (m *MsgBridgeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBridgeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBridgeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBridgeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBridgeResponse.Merge(m, src)
}
func (m *MsgBridgeResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgBridgeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBridgeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBridgeResponse proto.InternalMessageInfo

// MsgBridgeReceive is the Msg/BridgeReceive request type.
type MsgBridgeReceive struct {
	// issuer is the account address of the service bridging the credits.
	Issuer string `protobuf:"bytes,1,opt,name=issuer,proto3" json:"issuer,omitempty"`
	// class_id is the unique identifier of the credit class within which the
	// project and credit batch already exist or will be created.
	ClassId string `protobuf:"bytes,2,opt,name=class_id,json=classId,proto3" json:"class_id,omitempty"`
	// project defines the project information for the bridged credits.
	Project *MsgBridgeReceive_Project `protobuf:"bytes,3,opt,name=project,proto3" json:"project,omitempty"`
	// batch defines the credit batch information for the bridged credits.
	Batch *MsgBridgeReceive_Batch `protobuf:"bytes,4,opt,name=batch,proto3" json:"batch,omitempty"`
	// origin_tx is a reference to a transaction which caused the transfer from
	// another chain or registry.
	OriginTx *OriginTx `protobuf:"bytes,5,opt,name=origin_tx,json=originTx,proto3" json:"origin_tx,omitempty"`
}

func (m *MsgBridgeReceive) Reset()         { *m = MsgBridgeReceive{} }
func (m *MsgBridgeReceive) String() string { return proto.CompactTextString(m) }
func (*MsgBridgeReceive) ProtoMessage()    {}
func (*MsgBridgeReceive) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{38}
}
func (m *MsgBridgeReceive) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBridgeReceive) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBridgeReceive.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBridgeReceive) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBridgeReceive.Merge(m, src)
}
func (m *MsgBridgeReceive) XXX_Size() int {
	return m.Size()
}
func (m *MsgBridgeReceive) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBridgeReceive.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBridgeReceive proto.InternalMessageInfo

func (m *MsgBridgeReceive) GetIssuer() string {
	if m != nil {
		return m.Issuer
	}
	return ""
}

func (m *MsgBridgeReceive) GetClassId() string {
	if m != nil {
		return m.ClassId
	}
	return ""
}

func (m *MsgBridgeReceive) GetProject() *MsgBridgeReceive_Project {
	if m != nil {
		return m.Project
	}
	return nil
}

func (m *MsgBridgeReceive) GetBatch() *MsgBridgeReceive_Batch {
	if m != nil {
		return m.Batch
	}
	return nil
}

func (m *MsgBridgeReceive) GetOriginTx() *OriginTx {
	if m != nil {
		return m.OriginTx
	}
	return nil
}

// Batch defines the credit batch information for the bridged credits. This
// information will be used to create a credit batch or to dynamically mint
// credits to an existing credit batch.
type MsgBridgeReceive_Batch struct {
	// recipient is the recipient of the bridged credits.
	Recipient string `protobuf:"bytes,1,opt,name=recipient,proto3" json:"recipient,omitempty"`
	// amount is the amount of credits being bridged.
	Amount string `protobuf:"bytes,2,opt,name=amount,proto3" json:"amount,omitempty"`
	// start_date is the beginning of the period during which this credit batch
	// was quantified and verified.
	StartDate *time.Time `protobuf:"bytes,3,opt,name=start_date,json=startDate,proto3,stdtime" json:"start_date,omitempty"`
	// end_date is the end of the period during which this credit batch was
	// quantified and verified.
	EndDate *time.Time `protobuf:"bytes,4,opt,name=end_date,json=endDate,proto3,stdtime" json:"end_date,omitempty"`
	// metadata is the metadata for the credit batch.
	Metadata string `protobuf:"bytes,5,opt,name=metadata,proto3" json:"metadata,omitempty"`
}

func (m *MsgBridgeReceive_Batch) Reset()         { *m = MsgBridgeReceive_Batch{} }
func (m *MsgBridgeReceive_Batch) String() string { return proto.CompactTextString(m) }
func (*MsgBridgeReceive_Batch) ProtoMessage()    {}
func (*MsgBridgeReceive_Batch) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{38, 0}
}
func (m *MsgBridgeReceive_Batch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBridgeReceive_Batch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBridgeReceive_Batch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBridgeReceive_Batch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBridgeReceive_Batch.Merge(m, src)
}
func (m *MsgBridgeReceive_Batch) XXX_Size() int {
	return m.Size()
}
func (m *MsgBridgeReceive_Batch) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBridgeReceive_Batch.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBridgeReceive_Batch proto.InternalMessageInfo

func (m *MsgBridgeReceive_Batch) GetRecipient() string {
	if m != nil {
		return m.Recipient
	}
	return ""
}

func (m *MsgBridgeReceive_Batch) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *MsgBridgeReceive_Batch) GetStartDate() *time.Time {
	if m != nil {
		return m.StartDate
	}
	return nil
}

func (m *MsgBridgeReceive_Batch) GetEndDate() *time.Time {
	if m != nil {
		return m.EndDate
	}
	return nil
}

func (m *MsgBridgeReceive_Batch) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

// Project defines the project information for the bridged credits. This
// information will be used to find an existing project or to create a new
// project if a project with the same reference id does not already exist.
type MsgBridgeReceive_Project struct {
	// reference_id is the reference id of the project.
	ReferenceId string `protobuf:"bytes,1,opt,name=reference_id,json=referenceId,proto3" json:"reference_id,omitempty"`
	// jurisdiction is the project jurisdiction.
	Jurisdiction string `protobuf:"bytes,2,opt,name=jurisdiction,proto3" json:"jurisdiction,omitempty"`
	// metadata is the metadata for the project.
	Metadata string `protobuf:"bytes,3,opt,name=metadata,proto3" json:"metadata,omitempty"`
}

func (m *MsgBridgeReceive_Project) Reset()         { *m = MsgBridgeReceive_Project{} }
func (m *MsgBridgeReceive_Project) String() string { return proto.CompactTextString(m) }
func (*MsgBridgeReceive_Project) ProtoMessage()    {}
func (*MsgBridgeReceive_Project) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{38, 1}
}
func (m *MsgBridgeReceive_Project) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBridgeReceive_Project) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBridgeReceive_Project.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBridgeReceive_Project) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBridgeReceive_Project.Merge(m, src)
}
func (m *MsgBridgeReceive_Project) XXX_Size() int {
	return m.Size()
}
func (m *MsgBridgeReceive_Project) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBridgeReceive_Project.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBridgeReceive_Project proto.InternalMessageInfo

func (m *MsgBridgeReceive_Project) GetReferenceId() string {
	if m != nil {
		return m.ReferenceId
	}
	return ""
}

func (m *MsgBridgeReceive_Project) GetJurisdiction() string {
	if m != nil {
		return m.Jurisdiction
	}
	return ""
}

func (m *MsgBridgeReceive_Project) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

// MsgBridgeReceiveResponse is the Msg/BridgeReceive response type.
type MsgBridgeReceiveResponse struct {
	// batch_denom is the unique identifier of the credit batch either created
	// or within which the credits were dynamically minted.
	BatchDenom string `protobuf:"bytes,1,opt,name=batch_denom,json=batchDenom,proto3" json:"batch_denom,omitempty"`
	// project_id is the unique identifier of the project that was either created
	// or the existing project within which the credit batch exists.
	ProjectId string `protobuf:"bytes,2,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
}

func (m *MsgBridgeReceiveResponse) Reset()         { *m = MsgBridgeReceiveResponse{} }
func (m *MsgBridgeReceiveResponse) String() string { return proto.CompactTextString(m) }
func (*MsgBridgeReceiveResponse) ProtoMessage()    {}
func (*MsgBridgeReceiveResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{39}
}
func (m *MsgBridgeReceiveResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBridgeReceiveResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBridgeReceiveResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBridgeReceiveResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBridgeReceiveResponse.Merge(m, src)
}
func (m *MsgBridgeReceiveResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgBridgeReceiveResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBridgeReceiveResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBridgeReceiveResponse proto.InternalMessageInfo

func (m *MsgBridgeReceiveResponse) GetBatchDenom() string {
	if m != nil {
		return m.BatchDenom
	}
	return ""
}

func (m *MsgBridgeReceiveResponse) GetProjectId() string {
	if m != nil {
		return m.ProjectId
	}
	return ""
}

// MsgAddClassCreator is the Msg/AddClassCreator request type.
//
// Since Revision 2
type MsgAddClassCreator struct {
	// authority is the address of the governance account.
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// creator is the address to add to the class creator list.
	Creator string `protobuf:"bytes,2,opt,name=creator,proto3" json:"creator,omitempty"`
}

func (m *MsgAddClassCreator) Reset()         { *m = MsgAddClassCreator{} }
func (m *MsgAddClassCreator) String() string { return proto.CompactTextString(m) }
func (*MsgAddClassCreator) ProtoMessage()    {}
func (*MsgAddClassCreator) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{40}
}
func (m *MsgAddClassCreator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAddClassCreator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAddClassCreator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAddClassCreator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAddClassCreator.Merge(m, src)
}
func (m *MsgAddClassCreator) XXX_Size() int {
	return m.Size()
}
func (m *MsgAddClassCreator) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAddClassCreator.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAddClassCreator proto.InternalMessageInfo

func (m *MsgAddClassCreator) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgAddClassCreator) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

// MsgAddClassCreatorResponse is the Msg/AddClassCreator response type.
//
// Since Revision 2
type MsgAddClassCreatorResponse struct {
}

func (m *MsgAddClassCreatorResponse) Reset()         { *m = MsgAddClassCreatorResponse{} }
func (m *MsgAddClassCreatorResponse) String() string { return proto.CompactTextString(m) }
func (*MsgAddClassCreatorResponse) ProtoMessage()    {}
func (*MsgAddClassCreatorResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{41}
}
func (m *MsgAddClassCreatorResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAddClassCreatorResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAddClassCreatorResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAddClassCreatorResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAddClassCreatorResponse.Merge(m, src)
}
func (m *MsgAddClassCreatorResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgAddClassCreatorResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAddClassCreatorResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAddClassCreatorResponse proto.InternalMessageInfo

// MsgSetClassCreatorAllowlist is the Msg/SetClassCreatorAllowlist request
// type.
//
// Since Revision 2
type MsgSetClassCreatorAllowlist struct {
	// authority is the address of the governance account.
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// enabled defines the boolean value to set the allowlist on or off.
	Enabled bool `protobuf:"varint,2,opt,name=enabled,proto3" json:"enabled,omitempty"`
}

func (m *MsgSetClassCreatorAllowlist) Reset()         { *m = MsgSetClassCreatorAllowlist{} }
func (m *MsgSetClassCreatorAllowlist) String() string { return proto.CompactTextString(m) }
func (*MsgSetClassCreatorAllowlist) ProtoMessage()    {}
func (*MsgSetClassCreatorAllowlist) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{42}
}
func (m *MsgSetClassCreatorAllowlist) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetClassCreatorAllowlist) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetClassCreatorAllowlist.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetClassCreatorAllowlist) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetClassCreatorAllowlist.Merge(m, src)
}
func (m *MsgSetClassCreatorAllowlist) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetClassCreatorAllowlist) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetClassCreatorAllowlist.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetClassCreatorAllowlist proto.InternalMessageInfo

func (m *MsgSetClassCreatorAllowlist) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgSetClassCreatorAllowlist) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

// MsgSetClassCreatorAllowlistResponse is the Msg/SetClassCreatorAllowlist
// response type.
//
// Since Revision 2
type MsgSetClassCreatorAllowlistResponse struct {
}

func (m *MsgSetClassCreatorAllowlistResponse) Reset()         { *m = MsgSetClassCreatorAllowlistResponse{} }
func (m *MsgSetClassCreatorAllowlistResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSetClassCreatorAllowlistResponse) ProtoMessage()    {}
func (*MsgSetClassCreatorAllowlistResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{43}
}
func (m *MsgSetClassCreatorAllowlistResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetClassCreatorAllowlistResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetClassCreatorAllowlistResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetClassCreatorAllowlistResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetClassCreatorAllowlistResponse.Merge(m, src)
}
func (m *MsgSetClassCreatorAllowlistResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetClassCreatorAllowlistResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetClassCreatorAllowlistResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetClassCreatorAllowlistResponse proto.InternalMessageInfo

// MsgRemoveClassCreator is the Msg/RemoveClassCreator request type.
//
// Since Revision 2
type MsgRemoveClassCreator struct {
	// authority is the address of the governance account.
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// creator is the address to remove from the class creator list.
	Creator string `protobuf:"bytes,2,opt,name=creator,proto3" json:"creator,omitempty"`
}

func (m *MsgRemoveClassCreator) Reset()         { *m = MsgRemoveClassCreator{} }
func (m *MsgRemoveClassCreator) String() string { return proto.CompactTextString(m) }
func (*MsgRemoveClassCreator) ProtoMessage()    {}
func (*MsgRemoveClassCreator) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{44}
}
func (m *MsgRemoveClassCreator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRemoveClassCreator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRemoveClassCreator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRemoveClassCreator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRemoveClassCreator.Merge(m, src)
}
func (m *MsgRemoveClassCreator) XXX_Size() int {
	return m.Size()
}
func (m *MsgRemoveClassCreator) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRemoveClassCreator.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRemoveClassCreator proto.InternalMessageInfo

func (m *MsgRemoveClassCreator) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgRemoveClassCreator) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

// MsgRemoveClassCreatorResponse is the Msg/RemoveClasssCreator response type.
//
// Since Revision 2
type MsgRemoveClassCreatorResponse struct {
}

func (m *MsgRemoveClassCreatorResponse) Reset()         { *m = MsgRemoveClassCreatorResponse{} }
func (m *MsgRemoveClassCreatorResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRemoveClassCreatorResponse) ProtoMessage()    {}
func (*MsgRemoveClassCreatorResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{45}
}
func (m *MsgRemoveClassCreatorResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRemoveClassCreatorResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRemoveClassCreatorResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRemoveClassCreatorResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRemoveClassCreatorResponse.Merge(m, src)
}
func (m *MsgRemoveClassCreatorResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRemoveClassCreatorResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRemoveClassCreatorResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRemoveClassCreatorResponse proto.InternalMessageInfo

// MsgUpdateClassFee is the Msg/UpdateClassFee request type.
//
// Since Revision 2
type MsgUpdateClassFee struct {
	// authority is the address of the governance account.
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// fee is the credit class creation fee. If not set, the credit class creation
	// fee will be removed and no fee will be required to create a credit class.
	Fee *types.Coin `protobuf:"bytes,2,opt,name=fee,proto3" json:"fee,omitempty"`
}

func (m *MsgUpdateClassFee) Reset()         { *m = MsgUpdateClassFee{} }
func (m *MsgUpdateClassFee) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateClassFee) ProtoMessage()    {}
func (*MsgUpdateClassFee) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{46}
}
func (m *MsgUpdateClassFee) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateClassFee) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateClassFee.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateClassFee) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateClassFee.Merge(m, src)
}
func (m *MsgUpdateClassFee) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateClassFee) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateClassFee.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateClassFee proto.InternalMessageInfo

func (m *MsgUpdateClassFee) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgUpdateClassFee) GetFee() *types.Coin {
	if m != nil {
		return m.Fee
	}
	return nil
}

// MsgUpdateClassFeeResponse is the Msg/UpdateClassFee response type.
//
// Since Revision 2
type MsgUpdateClassFeeResponse struct {
}

func (m *MsgUpdateClassFeeResponse) Reset()         { *m = MsgUpdateClassFeeResponse{} }
func (m *MsgUpdateClassFeeResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateClassFeeResponse) ProtoMessage()    {}
func (*MsgUpdateClassFeeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{47}
}
func (m *MsgUpdateClassFeeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateClassFeeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateClassFeeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateClassFeeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateClassFeeResponse.Merge(m, src)
}
func (m *MsgUpdateClassFeeResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateClassFeeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateClassFeeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateClassFeeResponse proto.InternalMessageInfo

// MsgUpdateProjectFee is the Msg/UpdateProjectFee request type.
type MsgUpdateProjectFee struct {
	// authority is the address of the governance account.
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// fee is the project creation fee. If not set, the project creation fee will
	// be removed and no fee will be required to create a project.
	Fee *types.Coin `protobuf:"bytes,2,opt,name=fee,proto3" json:"fee,omitempty"`
}

func (m *MsgUpdateProjectFee) Reset()         { *m = MsgUpdateProjectFee{} }
func (m *MsgUpdateProjectFee) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateProjectFee) ProtoMessage()    {}
func (*MsgUpdateProjectFee) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{48}
}
func (m *MsgUpdateProjectFee) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateProjectFee) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateProjectFee.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateProjectFee) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateProjectFee.Merge(m, src)
}
func (m *MsgUpdateProjectFee) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateProjectFee) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateProjectFee.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateProjectFee proto.InternalMessageInfo

func (m *MsgUpdateProjectFee) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgUpdateProjectFee) GetFee() *types.Coin {
	if m != nil {
		return m.Fee
	}
	return nil
}

// MsgUpdateProjectFeeResponse is the Msg/UpdateProjectFee response type.
type MsgUpdateProjectFeeResponse struct {
}

func (m *MsgUpdateProjectFeeResponse) Reset()         { *m = MsgUpdateProjectFeeResponse{} }
func (m *MsgUpdateProjectFeeResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateProjectFeeResponse) ProtoMessage()    {}
func (*MsgUpdateProjectFeeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{49}
}
func (m *MsgUpdateProjectFeeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateProjectFeeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateProjectFeeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateProjectFeeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateProjectFeeResponse.Merge(m, src)
}
func (m *MsgUpdateProjectFeeResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateProjectFeeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateProjectFeeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateProjectFeeResponse proto.InternalMessageInfo

// MsgAddAllowedBridgeChain is the Msg/AddAllowedBridgeChain request type.
//
// Since Revision 2
type MsgAddAllowedBridgeChain struct {
	// authority is the address of the governance account.
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// chain_name is the name of the chain to allow bridging of ecocredits to
	// (i.e. polygon, ethereum, celo).
	ChainName string `protobuf:"bytes,2,opt,name=chain_name,json=chainName,proto3" json:"chain_name,omitempty"`
}

func (m *MsgAddAllowedBridgeChain) Reset()         { *m = MsgAddAllowedBridgeChain{} }
func (m *MsgAddAllowedBridgeChain) String() string { return proto.CompactTextString(m) }
func (*MsgAddAllowedBridgeChain) ProtoMessage()    {}
func (*MsgAddAllowedBridgeChain) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{50}
}
func (m *MsgAddAllowedBridgeChain) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAddAllowedBridgeChain) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAddAllowedBridgeChain.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAddAllowedBridgeChain) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAddAllowedBridgeChain.Merge(m, src)
}
func (m *MsgAddAllowedBridgeChain) XXX_Size() int {
	return m.Size()
}
func (m *MsgAddAllowedBridgeChain) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAddAllowedBridgeChain.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAddAllowedBridgeChain proto.InternalMessageInfo

func (m *MsgAddAllowedBridgeChain) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgAddAllowedBridgeChain) GetChainName() string {
	if m != nil {
		return m.ChainName
	}
	return ""
}

// MsgAddAllowedBridgeChainResponse is the Msg/AddAllowedBridgeChain response
// type.
//
// Since Revision 2
type MsgAddAllowedBridgeChainResponse struct {
}

func (m *MsgAddAllowedBridgeChainResponse) Reset()         { *m = MsgAddAllowedBridgeChainResponse{} }
func (m *MsgAddAllowedBridgeChainResponse) String() string { return proto.CompactTextString(m) }
func (*MsgAddAllowedBridgeChainResponse) ProtoMessage()    {}
func (*MsgAddAllowedBridgeChainResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{51}
}
func (m *MsgAddAllowedBridgeChainResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAddAllowedBridgeChainResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAddAllowedBridgeChainResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAddAllowedBridgeChainResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAddAllowedBridgeChainResponse.Merge(m, src)
}
func (m *MsgAddAllowedBridgeChainResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgAddAllowedBridgeChainResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAddAllowedBridgeChainResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAddAllowedBridgeChainResponse proto.InternalMessageInfo

// MsgRemoveAllowedBridgeChain is the Msg/RemoveAllowedBridgeChain request type.
//
// Since Revision 2
type MsgRemoveAllowedBridgeChain struct {
	// authority is the address of the governance account.
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// chain_name is the name of the chain to remove from the list of allowed
	// chains to bridge ecocredits to (i.e. polygon, ethereum, celo).
	ChainName string `protobuf:"bytes,2,opt,name=chain_name,json=chainName,proto3" json:"chain_name,omitempty"`
}

func (m *MsgRemoveAllowedBridgeChain) Reset()         { *m = MsgRemoveAllowedBridgeChain{} }
func (m *MsgRemoveAllowedBridgeChain) String() string { return proto.CompactTextString(m) }
func (*MsgRemoveAllowedBridgeChain) ProtoMessage()    {}
func (*MsgRemoveAllowedBridgeChain) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{52}
}
func (m *MsgRemoveAllowedBridgeChain) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRemoveAllowedBridgeChain) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRemoveAllowedBridgeChain.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRemoveAllowedBridgeChain) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRemoveAllowedBridgeChain.Merge(m, src)
}
func (m *MsgRemoveAllowedBridgeChain) XXX_Size() int {
	return m.Size()
}
func (m *MsgRemoveAllowedBridgeChain) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRemoveAllowedBridgeChain.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRemoveAllowedBridgeChain proto.InternalMessageInfo

func (m *MsgRemoveAllowedBridgeChain) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgRemoveAllowedBridgeChain) GetChainName() string {
	if m != nil {
		return m.ChainName
	}
	return ""
}

// MsgRemoveAllowedBridgeChainResponse is the Msg/RemoveAllowedBridgeChain
// response type.
//
// Since Revision 2
type MsgRemoveAllowedBridgeChainResponse struct {
}

func (m *MsgRemoveAllowedBridgeChainResponse) Reset()         { *m = MsgRemoveAllowedBridgeChainResponse{} }
func (m *MsgRemoveAllowedBridgeChainResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRemoveAllowedBridgeChainResponse) ProtoMessage()    {}
func (*MsgRemoveAllowedBridgeChainResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{53}
}
func (m *MsgRemoveAllowedBridgeChainResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRemoveAllowedBridgeChainResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRemoveAllowedBridgeChainResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRemoveAllowedBridgeChainResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRemoveAllowedBridgeChainResponse.Merge(m, src)
}
func (m *MsgRemoveAllowedBridgeChainResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRemoveAllowedBridgeChainResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRemoveAllowedBridgeChainResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRemoveAllowedBridgeChainResponse proto.InternalMessageInfo

// MsgBurnRegen is the Msg/BurnRegen request type.
//
// Since Revision 3
type MsgBurnRegen struct {
	// burner is the address of the account burning REGEN tokens.
	Burner string `protobuf:"bytes,1,opt,name=burner,proto3" json:"burner,omitempty"`
	// amount is the integer amount of uregen tokens to burn.
	Amount string `protobuf:"bytes,2,opt,name=amount,proto3" json:"amount,omitempty"`
	// reason is any arbitrary string that specifies the reason for burning
	// REGEN tokens. It may be at most 256 characters long.
	Reason string `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *MsgBurnRegen) Reset()         { *m = MsgBurnRegen{} }
func (m *MsgBurnRegen) String() string { return proto.CompactTextString(m) }
func (*MsgBurnRegen) ProtoMessage()    {}
func (*MsgBurnRegen) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{54}
}
func (m *MsgBurnRegen) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBurnRegen) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBurnRegen.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBurnRegen) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBurnRegen.Merge(m, src)
}
func (m *MsgBurnRegen) XXX_Size() int {
	return m.Size()
}
func (m *MsgBurnRegen) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBurnRegen.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBurnRegen proto.InternalMessageInfo

func (m *MsgBurnRegen) GetBurner() string {
	if m != nil {
		return m.Burner
	}
	return ""
}

func (m *MsgBurnRegen) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *MsgBurnRegen) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

// MsgBurnResponse is the Msg/Burn response type.
//
// Since Revision 3
type MsgBurnRegenResponse struct {
}

func (m *MsgBurnRegenResponse) Reset()         { *m = MsgBurnRegenResponse{} }
func (m *MsgBurnRegenResponse) String() string { return proto.CompactTextString(m) }
func (*MsgBurnRegenResponse) ProtoMessage()    {}
func (*MsgBurnRegenResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b8ae49f50a3ddbd, []int{55}
}
func (m *MsgBurnRegenResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBurnRegenResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBurnRegenResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBurnRegenResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBurnRegenResponse.Merge(m, src)
}
func (m *MsgBurnRegenResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgBurnRegenResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBurnRegenResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBurnRegenResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*MsgAddCreditType)(nil), "regen.ecocredit.v1.MsgAddCreditType")
	proto.RegisterType((*MsgAddCreditTypeResponse)(nil), "regen.ecocredit.v1.MsgAddCreditTypeResponse")
	proto.RegisterType((*MsgCreateClass)(nil), "regen.ecocredit.v1.MsgCreateClass")
	proto.RegisterType((*MsgCreateClassResponse)(nil), "regen.ecocredit.v1.MsgCreateClassResponse")
	proto.RegisterType((*MsgCreateProject)(nil), "regen.ecocredit.v1.MsgCreateProject")
	proto.RegisterType((*MsgCreateProjectResponse)(nil), "regen.ecocredit.v1.MsgCreateProjectResponse")
	proto.RegisterType((*MsgCreateUnregisteredProject)(nil), "regen.ecocredit.v1.MsgCreateUnregisteredProject")
	proto.RegisterType((*MsgCreateUnregisteredProjectResponse)(nil), "regen.ecocredit.v1.MsgCreateUnregisteredProjectResponse")
	proto.RegisterType((*MsgCreateOrUpdateApplication)(nil), "regen.ecocredit.v1.MsgCreateOrUpdateApplication")
	proto.RegisterType((*MsgCreateOrUpdateApplicationResponse)(nil), "regen.ecocredit.v1.MsgCreateOrUpdateApplicationResponse")
	proto.RegisterType((*MsgUpdateProjectEnrollment)(nil), "regen.ecocredit.v1.MsgUpdateProjectEnrollment")
	proto.RegisterType((*MsgUpdateProjectEnrollmentResponse)(nil), "regen.ecocredit.v1.MsgUpdateProjectEnrollmentResponse")
	proto.RegisterType((*MsgCreateBatch)(nil), "regen.ecocredit.v1.MsgCreateBatch")
	proto.RegisterType((*MsgCreateBatchResponse)(nil), "regen.ecocredit.v1.MsgCreateBatchResponse")
	proto.RegisterType((*MsgMintBatchCredits)(nil), "regen.ecocredit.v1.MsgMintBatchCredits")
	proto.RegisterType((*MsgMintBatchCreditsResponse)(nil), "regen.ecocredit.v1.MsgMintBatchCreditsResponse")
	proto.RegisterType((*MsgSealBatch)(nil), "regen.ecocredit.v1.MsgSealBatch")
	proto.RegisterType((*MsgSealBatchResponse)(nil), "regen.ecocredit.v1.MsgSealBatchResponse")
	proto.RegisterType((*MsgSend)(nil), "regen.ecocredit.v1.MsgSend")
	proto.RegisterType((*MsgSend_SendCredits)(nil), "regen.ecocredit.v1.MsgSend.SendCredits")
	proto.RegisterType((*MsgSendResponse)(nil), "regen.ecocredit.v1.MsgSendResponse")
	proto.RegisterType((*MsgRetire)(nil), "regen.ecocredit.v1.MsgRetire")
	proto.RegisterType((*MsgRetireResponse)(nil), "regen.ecocredit.v1.MsgRetireResponse")
	proto.RegisterType((*MsgCancel)(nil), "regen.ecocredit.v1.MsgCancel")
	proto.RegisterType((*MsgCancelResponse)(nil), "regen.ecocredit.v1.MsgCancelResponse")
	proto.RegisterType((*MsgUpdateClassAdmin)(nil), "regen.ecocredit.v1.MsgUpdateClassAdmin")
	proto.RegisterType((*MsgUpdateClassAdminResponse)(nil), "regen.ecocredit.v1.MsgUpdateClassAdminResponse")
	proto.RegisterType((*MsgUpdateClassIssuers)(nil), "regen.ecocredit.v1.MsgUpdateClassIssuers")
	proto.RegisterType((*MsgUpdateClassIssuersResponse)(nil), "regen.ecocredit.v1.MsgUpdateClassIssuersResponse")
	proto.RegisterType((*MsgUpdateClassMetadata)(nil), "regen.ecocredit.v1.MsgUpdateClassMetadata")
	proto.RegisterType((*MsgUpdateClassMetadataResponse)(nil), "regen.ecocredit.v1.MsgUpdateClassMetadataResponse")
	proto.RegisterType((*MsgUpdateProjectAdmin)(nil), "regen.ecocredit.v1.MsgUpdateProjectAdmin")
	proto.RegisterType((*MsgUpdateProjectAdminResponse)(nil), "regen.ecocredit.v1.MsgUpdateProjectAdminResponse")
	proto.RegisterType((*MsgUpdateProjectMetadata)(nil), "regen.ecocredit.v1.MsgUpdateProjectMetadata")
	proto.RegisterType((*MsgUpdateProjectMetadataResponse)(nil), "regen.ecocredit.v1.MsgUpdateProjectMetadataResponse")
	proto.RegisterType((*MsgBridge)(nil), "regen.ecocredit.v1.MsgBridge")
	proto.RegisterType((*MsgUpdateBatchMetadata)(nil), "regen.ecocredit.v1.MsgUpdateBatchMetadata")
	proto.RegisterType((*MsgUpdateBatchMetadataResponse)(nil), "regen.ecocredit.v1.MsgUpdateBatchMetadataResponse")
	proto.RegisterType((*MsgBridgeResponse)(nil), "regen.ecocredit.v1.MsgBridgeResponse")
	proto.RegisterType((*MsgBridgeReceive)(nil), "regen.ecocredit.v1.MsgBridgeReceive")
	proto.RegisterType((*MsgBridgeReceive_Batch)(nil), "regen.ecocredit.v1.MsgBridgeReceive.Batch")
	proto.RegisterType((*MsgBridgeReceive_Project)(nil), "regen.ecocredit.v1.MsgBridgeReceive.Project")
	proto.RegisterType((*MsgBridgeReceiveResponse)(nil), "regen.ecocredit.v1.MsgBridgeReceiveResponse")
	proto.RegisterType((*MsgAddClassCreator)(nil), "regen.ecocredit.v1.MsgAddClassCreator")
	proto.RegisterType((*MsgAddClassCreatorResponse)(nil), "regen.ecocredit.v1.MsgAddClassCreatorResponse")
	proto.RegisterType((*MsgSetClassCreatorAllowlist)(nil), "regen.ecocredit.v1.MsgSetClassCreatorAllowlist")
	proto.RegisterType((*MsgSetClassCreatorAllowlistResponse)(nil), "regen.ecocredit.v1.MsgSetClassCreatorAllowlistResponse")
	proto.RegisterType((*MsgRemoveClassCreator)(nil), "regen.ecocredit.v1.MsgRemoveClassCreator")
	proto.RegisterType((*MsgRemoveClassCreatorResponse)(nil), "regen.ecocredit.v1.MsgRemoveClassCreatorResponse")
	proto.RegisterType((*MsgUpdateClassFee)(nil), "regen.ecocredit.v1.MsgUpdateClassFee")
	proto.RegisterType((*MsgUpdateClassFeeResponse)(nil), "regen.ecocredit.v1.MsgUpdateClassFeeResponse")
	proto.RegisterType((*MsgUpdateProjectFee)(nil), "regen.ecocredit.v1.MsgUpdateProjectFee")
	proto.RegisterType((*MsgUpdateProjectFeeResponse)(nil), "regen.ecocredit.v1.MsgUpdateProjectFeeResponse")
	proto.RegisterType((*MsgAddAllowedBridgeChain)(nil), "regen.ecocredit.v1.MsgAddAllowedBridgeChain")
	proto.RegisterType((*MsgAddAllowedBridgeChainResponse)(nil), "regen.ecocredit.v1.MsgAddAllowedBridgeChainResponse")
	proto.RegisterType((*MsgRemoveAllowedBridgeChain)(nil), "regen.ecocredit.v1.MsgRemoveAllowedBridgeChain")
	proto.RegisterType((*MsgRemoveAllowedBridgeChainResponse)(nil), "regen.ecocredit.v1.MsgRemoveAllowedBridgeChainResponse")
	proto.RegisterType((*MsgBurnRegen)(nil), "regen.ecocredit.v1.MsgBurnRegen")
	proto.RegisterType((*MsgBurnRegenResponse)(nil), "regen.ecocredit.v1.MsgBurnRegenResponse")
}

func init() { proto.RegisterFile("regen/ecocredit/v1/tx.proto", fileDescriptor_2b8ae49f50a3ddbd) }

var fileDescriptor_2b8ae49f50a3ddbd = []byte{
	// 2202 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x5a, 0xcf, 0x6f, 0xdb, 0xc8,
	0xf5, 0x0f, 0x25, 0xf9, 0x87, 0x9e, 0x1c, 0x27, 0x61, 0xb2, 0x8e, 0x42, 0xc7, 0xb2, 0xa3, 0x24,
	0x1b, 0xc7, 0xc9, 0x4a, 0x5f, 0x7b, 0xbf, 0x6d, 0x9a, 0x14, 0x45, 0x6a, 0x7b, 0x37, 0xa8, 0x17,
	0xd0, 0xee, 0x42, 0xc9, 0xa2, 0xe8, 0xa2, 0x85, 0x40, 0x91, 0x13, 0x9a, 0xa9, 0x44, 0x0a, 0xe4,
	0xc8, 0x72, 0xd0, 0xa2, 0x68, 0x8a, 0x02, 0xbd, 0xee, 0xad, 0x40, 0xd1, 0x43, 0xff, 0x84, 0xfd,
	0x1f, 0x7a, 0x69, 0x6f, 0xb9, 0x14, 0xed, 0x2d, 0x45, 0x52, 0x60, 0x2f, 0x3d, 0xf7, 0x5c, 0x70,
	0x66, 0x38, 0x9a, 0xa1, 0x38, 0x24, 0xb5, 0x69, 0x2e, 0x06, 0x67, 0xe6, 0xcd, 0x7b, 0x9f, 0xf7,
	0xe6, 0xcd, 0xfb, 0x31, 0x16, 0xac, 0x07, 0xc8, 0x41, 0x5e, 0x1b, 0x59, 0xbe, 0x15, 0x20, 0xdb,
	0xc5, 0xed, 0x93, 0xdd, 0x36, 0x3e, 0x6d, 0x8d, 0x02, 0x1f, 0xfb, 0xba, 0x4e, 0x16, 0x5b, 0x7c,
	0xb1, 0x75, 0xb2, 0x6b, 0x34, 0x2c, 0x3f, 0x1c, 0xfa, 0x61, 0xbb, 0x6f, 0x86, 0xa8, 0x7d, 0xb2,
	0xdb, 0x47, 0xd8, 0xdc, 0x6d, 0x5b, 0xbe, 0xeb, 0xd1, 0x3d, 0xc6, 0x65, 0xb6, 0x3e, 0x0c, 0x9d,
	0x88, 0xd7, 0x30, 0x74, 0xd8, 0xc2, 0x25, 0xc7, 0x77, 0x7c, 0xf2, 0xd9, 0x8e, 0xbe, 0xd8, 0xec,
	0xa6, 0xe3, 0xfb, 0xce, 0x00, 0xb5, 0xc9, 0xa8, 0x3f, 0x7e, 0xda, 0xc6, 0xee, 0x10, 0x85, 0xd8,
	0x1c, 0x8e, 0x18, 0x41, 0x23, 0x05, 0x60, 0x88, 0x4d, 0x8c, 0x32, 0xd6, 0xf1, 0xf3, 0x11, 0x0a,
	0xe9, 0x7a, 0xf3, 0x85, 0x06, 0xe7, 0x3b, 0xa1, 0xb3, 0x6f, 0xdb, 0x87, 0x64, 0xfd, 0xc9, 0xf3,
	0x11, 0xd2, 0xaf, 0x42, 0xd5, 0x1c, 0xe3, 0x63, 0x3f, 0x70, 0xf1, 0xf3, 0xba, 0xb6, 0xa5, 0x6d,
	0x57, 0xbb, 0xd3, 0x09, 0xfd, 0x21, 0xd4, 0x28, 0xaf, 0x5e, 0xc4, 0xa8, 0x5e, 0xda, 0xd2, 0xb6,
	0x6b, 0x7b, 0x8d, 0xd6, 0xac, 0x31, 0x5a, 0x53, 0x96, 0x5d, 0xb0, 0xf8, 0xf7, 0x83, 0xd5, 0xdf,
	0x7c, 0xf3, 0xf5, 0xce, 0x94, 0x61, 0xd3, 0x80, 0x7a, 0x12, 0x42, 0x17, 0x85, 0x23, 0xdf, 0x0b,
	0x51, 0xf3, 0xcf, 0x1a, 0xac, 0x76, 0x42, 0xe7, 0x30, 0x40, 0x26, 0x46, 0x87, 0x03, 0x33, 0x0c,
	0xf5, 0x4b, 0xb0, 0x60, 0xda, 0x43, 0xd7, 0x63, 0xc8, 0xe8, 0x40, 0xaf, 0xc3, 0x92, 0x1b, 0x86,
	0x63, 0x14, 0x84, 0xf5, 0xd2, 0x56, 0x79, 0xbb, 0xda, 0x8d, 0x87, 0xba, 0x01, 0xcb, 0x43, 0x84,
	0x4d, 0xdb, 0xc4, 0x66, 0xbd, 0x4c, 0xb6, 0xf0, 0xb1, 0x7e, 0x17, 0x74, 0x41, 0x97, 0x9e, 0xd9,
	0xef, 0x07, 0xe8, 0xa4, 0x5e, 0x21, 0x54, 0xe7, 0xa7, 0x90, 0xf7, 0xc9, 0xbc, 0x7e, 0x07, 0xca,
	0x4f, 0x11, 0xaa, 0x2f, 0x10, 0x8d, 0xaf, 0xb4, 0xe8, 0x51, 0xb6, 0xa2, 0xa3, 0x6e, 0xb1, 0xa3,
	0x6e, 0x1d, 0xfa, 0xae, 0xd7, 0x8d, 0xa8, 0x1e, 0x40, 0xa4, 0x25, 0x05, 0xd7, 0xfc, 0x10, 0xd6,
	0x64, 0x25, 0x62, 0xfd, 0xf4, 0x2b, 0xb0, 0x6c, 0x45, 0x13, 0x3d, 0xd7, 0x66, 0xfa, 0x2c, 0x91,
	0xf1, 0x91, 0xdd, 0x7c, 0x45, 0x8f, 0x86, 0xee, 0xfa, 0x3c, 0xf0, 0x9f, 0x21, 0x0b, 0x2b, 0x94,
	0x17, 0xb9, 0x94, 0x24, 0x2e, 0x99, 0xda, 0x37, 0x61, 0xe5, 0xd9, 0x38, 0x70, 0x43, 0xdb, 0xb5,
	0xb0, 0xeb, 0x7b, 0x4c, 0x6f, 0x69, 0x4e, 0xbf, 0x06, 0x2b, 0x01, 0x7a, 0x8a, 0x02, 0xe4, 0x59,
	0x28, 0x62, 0xbf, 0x40, 0x68, 0x6a, 0x7c, 0xee, 0xc8, 0x8e, 0xcd, 0xb2, 0x38, 0xb7, 0x59, 0xee,
	0x93, 0x83, 0x97, 0x14, 0xe4, 0x86, 0xd9, 0x00, 0x18, 0xd1, 0xa9, 0xa9, 0x69, 0xaa, 0x6c, 0xe6,
	0xc8, 0x6e, 0xbe, 0xd4, 0xe0, 0x2a, 0xdf, 0xfb, 0x85, 0x17, 0x20, 0xc7, 0x0d, 0x31, 0x0a, 0x90,
	0x9d, 0x6d, 0x28, 0xd1, 0x1a, 0xa5, 0x1c, 0x6b, 0x94, 0x0b, 0x58, 0xa3, 0xa2, 0xb4, 0xc6, 0xfc,
	0x4e, 0xf2, 0x31, 0xdc, 0xc8, 0xd2, 0xa8, 0xa8, 0x65, 0xfe, 0x2a, 0x5a, 0xe6, 0xb3, 0xe0, 0x8b,
	0x91, 0x6d, 0x62, 0xb4, 0x3f, 0x1a, 0x0d, 0x5c, 0xcb, 0x24, 0x3a, 0x5c, 0x87, 0xb3, 0xf1, 0x7e,
	0xd1, 0x42, 0x2b, 0x6c, 0x72, 0x9f, 0x18, 0x4a, 0x16, 0x52, 0x4a, 0x08, 0x91, 0x1c, 0xae, 0xac,
	0x76, 0xb8, 0x4a, 0xc2, 0xc4, 0x06, 0x2c, 0x4f, 0x5c, 0x7c, 0x6c, 0x07, 0xe6, 0x84, 0x18, 0x68,
	0xb9, 0xcb, 0xc7, 0x0f, 0xf4, 0xc8, 0x14, 0x32, 0xb2, 0xe6, 0xfb, 0x82, 0x49, 0x52, 0x54, 0xe1,
	0x51, 0xe2, 0x8d, 0x06, 0x46, 0x27, 0x74, 0x28, 0x01, 0xb3, 0xd7, 0xc7, 0x5e, 0xe0, 0x0f, 0x06,
	0x43, 0xe4, 0x61, 0x7d, 0x0d, 0x16, 0x69, 0x30, 0x60, 0xaa, 0xb2, 0xd1, 0x5b, 0x28, 0xf9, 0x09,
	0x80, 0x87, 0x26, 0xbd, 0x28, 0xd2, 0x8e, 0x43, 0xa2, 0xe6, 0xea, 0xde, 0x9d, 0xb4, 0x10, 0x38,
	0x03, 0xe6, 0x31, 0xd9, 0xd2, 0xad, 0x7a, 0x68, 0x42, 0x3f, 0x25, 0x83, 0x2d, 0xc8, 0x06, 0x7b,
	0x50, 0x8b, 0x8c, 0xc2, 0xe0, 0x36, 0x6f, 0x40, 0x53, 0xad, 0x24, 0xb7, 0xc5, 0xef, 0xcb, 0x42,
	0xc4, 0x3c, 0x30, 0xb1, 0x75, 0xfc, 0x6d, 0xf5, 0xff, 0x01, 0x2c, 0x47, 0x84, 0xa6, 0x67, 0xa1,
	0x7a, 0x79, 0xab, 0xbc, 0x5d, 0xdb, 0xbb, 0x96, 0xa6, 0x22, 0x91, 0x71, 0xc4, 0x08, 0xbb, 0x7c,
	0x4b, 0xa6, 0x23, 0x3c, 0x04, 0x08, 0xb1, 0x19, 0xe0, 0x5e, 0xa4, 0x0b, 0xbb, 0x2b, 0x46, 0x8b,
	0x26, 0xbb, 0x56, 0x9c, 0xec, 0x5a, 0x4f, 0xe2, 0x64, 0x77, 0x50, 0xf9, 0xea, 0xd5, 0xa6, 0xd6,
	0xad, 0x92, 0x3d, 0x1f, 0x99, 0x18, 0xe9, 0xdf, 0x87, 0x65, 0xe4, 0xd9, 0x74, 0xfb, 0x62, 0xc1,
	0xed, 0x4b, 0xc8, 0xb3, 0xc9, 0x66, 0x1d, 0x2a, 0xfe, 0x08, 0x79, 0xf5, 0x25, 0xe2, 0x82, 0xe4,
	0x5b, 0xbf, 0x0f, 0x55, 0x3f, 0x70, 0x1d, 0xd7, 0xeb, 0xe1, 0xd3, 0xfa, 0x32, 0xe1, 0x78, 0x35,
	0x4d, 0xdb, 0xcf, 0x08, 0xd1, 0x93, 0xd3, 0xee, 0xb2, 0xcf, 0xbe, 0x24, 0x3f, 0xa9, 0x4a, 0x7e,
	0x22, 0x9f, 0xdf, 0x7d, 0x21, 0x0b, 0x10, 0xa3, 0xf1, 0x2b, 0xbd, 0x09, 0xb5, 0x7e, 0x34, 0xd1,
	0xb3, 0x91, 0xe7, 0x0f, 0xd9, 0x29, 0x01, 0x99, 0xfa, 0x28, 0x9a, 0x69, 0xfe, 0x4d, 0x83, 0x8b,
	0x9d, 0xd0, 0xe9, 0xb8, 0x1e, 0x26, 0x3b, 0x69, 0xa6, 0x0c, 0x95, 0x27, 0x9b, 0x60, 0x58, 0x4a,
	0x32, 0x7c, 0xdb, 0xb3, 0x95, 0xac, 0x55, 0x99, 0xc7, 0x5a, 0xb2, 0x49, 0x36, 0x60, 0x3d, 0x45,
	0x2d, 0xee, 0xcb, 0x4f, 0x60, 0xa5, 0x13, 0x3a, 0x8f, 0x91, 0x39, 0xc8, 0x76, 0xe4, 0x3c, 0x75,
	0x65, 0xa1, 0x6b, 0x70, 0x49, 0xe4, 0xca, 0xa5, 0xfd, 0xa7, 0x04, 0x4b, 0x64, 0xc1, 0xb3, 0x23,
	0x49, 0x21, 0xf2, 0xec, 0xa9, 0x24, 0x3a, 0x8a, 0x4a, 0xa3, 0x00, 0x59, 0xee, 0xc8, 0x45, 0x1e,
	0x8e, 0x6f, 0x0c, 0x9f, 0xd0, 0xf7, 0x61, 0x89, 0xea, 0x1e, 0x32, 0xa3, 0xde, 0x4a, 0x33, 0x0a,
	0x93, 0xd1, 0x8a, 0xfe, 0xc4, 0x1a, 0xc7, 0xfb, 0x8c, 0x7f, 0x69, 0x50, 0x13, 0x16, 0x72, 0x5d,
	0x43, 0xbf, 0x05, 0xe7, 0x70, 0x60, 0xda, 0x66, 0x7f, 0x80, 0x7a, 0xe6, 0xd0, 0x1f, 0x73, 0x5c,
	0xab, 0xf1, 0xf4, 0x3e, 0x99, 0xd5, 0x6f, 0xc2, 0x6a, 0x80, 0xb0, 0x1b, 0x20, 0x3b, 0xa6, 0xa3,
	0x41, 0xed, 0x2c, 0x9b, 0x65, 0x64, 0xf7, 0xe0, 0x32, 0x9d, 0x88, 0xa2, 0x4a, 0x2f, 0xa5, 0x3e,
	0x58, 0x9b, 0x2e, 0x7f, 0x22, 0xe6, 0xc6, 0x3b, 0x70, 0x41, 0xd8, 0x18, 0x20, 0x33, 0xf4, 0x3d,
	0x16, 0xd0, 0xce, 0x4f, 0x17, 0xba, 0x64, 0x9e, 0x1d, 0x08, 0x35, 0x6a, 0xf3, 0x02, 0x9c, 0x63,
	0x36, 0xe1, 0x67, 0xf1, 0x27, 0x0d, 0xaa, 0x9d, 0xd0, 0xe9, 0x92, 0x7d, 0x51, 0x32, 0xf7, 0x27,
	0x1e, 0x3f, 0x0c, 0x3a, 0xd0, 0xbf, 0x33, 0xb5, 0x76, 0x89, 0x58, 0x7b, 0x5d, 0x5d, 0x84, 0x4e,
	0x2d, 0x5c, 0x28, 0xcf, 0xaf, 0xc1, 0x22, 0x53, 0x80, 0xea, 0xcc, 0x46, 0x2c, 0x5f, 0x13, 0xf1,
	0xcd, 0x8b, 0x70, 0x81, 0x23, 0xe4, 0xb8, 0x7f, 0x49, 0x60, 0x1f, 0x46, 0x97, 0x64, 0xf0, 0xbf,
	0x85, 0x3d, 0x85, 0x54, 0xce, 0x81, 0x44, 0xa5, 0x73, 0x48, 0x3e, 0x09, 0x1d, 0x34, 0x6d, 0x90,
	0xe2, 0x93, 0x66, 0xf8, 0xb9, 0x2b, 0xc9, 0x75, 0x88, 0x92, 0x16, 0xab, 0x19, 0x58, 0x29, 0xe9,
	0xa1, 0x09, 0xe1, 0x26, 0x15, 0x32, 0xf4, 0x52, 0x27, 0x05, 0x72, 0x3c, 0x7f, 0xd4, 0xe0, 0x3d,
	0x79, 0xfd, 0x88, 0x55, 0xea, 0x73, 0x43, 0xda, 0x84, 0x9a, 0x69, 0xdb, 0xbd, 0xb8, 0xf0, 0x2f,
	0x93, 0xc2, 0x1f, 0x4c, 0xdb, 0x8e, 0x39, 0x12, 0x9f, 0x1f, 0xfa, 0x27, 0x88, 0xd3, 0x54, 0x08,
	0xcd, 0x59, 0x3a, 0xcb, 0xc8, 0x24, 0xf4, 0x9b, 0xb0, 0x91, 0x8a, 0x8e, 0xe3, 0x3f, 0x25, 0x61,
	0x5c, 0x20, 0xe8, 0xc4, 0x59, 0x6d, 0x6e, 0xfc, 0xd7, 0x60, 0x25, 0x32, 0x69, 0xa2, 0x40, 0xaf,
	0x79, 0x68, 0x12, 0xf3, 0x94, 0xa0, 0x6d, 0x41, 0x23, 0x5d, 0x32, 0xc7, 0x36, 0x16, 0x4c, 0xfb,
	0xb9, 0x58, 0xcf, 0xa5, 0x43, 0xcb, 0x29, 0x00, 0x0a, 0x9f, 0xb8, 0x68, 0x33, 0x51, 0x2c, 0xc7,
	0xf5, 0x2b, 0x52, 0xe9, 0x4b, 0x04, 0x39, 0x56, 0xcb, 0x81, 0x36, 0xa7, 0xe5, 0x9a, 0xb0, 0xa5,
	0x92, 0xcf, 0x31, 0xfe, 0x81, 0x86, 0x9c, 0x83, 0xc0, 0xb5, 0x1d, 0x55, 0xc8, 0x59, 0x83, 0x45,
	0x6c, 0x06, 0x0e, 0x8a, 0x63, 0x2c, 0x1b, 0xc9, 0x69, 0xa1, 0x9c, 0x4c, 0x0b, 0xc2, 0x8d, 0xaf,
	0x14, 0xbf, 0xf1, 0xd2, 0xcd, 0x7e, 0xa1, 0x09, 0x5e, 0x47, 0xd2, 0x16, 0xb7, 0xdf, 0xb7, 0xae,
	0x01, 0x0a, 0xd8, 0x50, 0xca, 0x9b, 0xa2, 0xfb, 0x49, 0x10, 0xb8, 0x09, 0x69, 0xfc, 0xa1, 0x16,
	0xe4, 0x93, 0xaf, 0x2a, 0xa4, 0x8f, 0x8d, 0x67, 0x2d, 0xe4, 0x9e, 0x20, 0x25, 0xe8, 0x8c, 0xcb,
	0xf2, 0x08, 0x96, 0xd8, 0xf9, 0x13, 0xa4, 0xb5, 0xbd, 0xbb, 0x8a, 0xe4, 0x2a, 0x49, 0x8a, 0x2b,
	0xf0, 0x6e, 0xbc, 0x59, 0xff, 0x21, 0x2c, 0x10, 0x23, 0xb0, 0xba, 0x65, 0xa7, 0x10, 0x17, 0x5a,
	0x29, 0xd0, 0x8d, 0x72, 0xf5, 0xb3, 0x30, 0x4f, 0xf5, 0x63, 0xfc, 0x5d, 0x83, 0x05, 0x5a, 0xcb,
	0x48, 0x2e, 0xa3, 0x25, 0x5d, 0x66, 0x0d, 0x16, 0xa5, 0x64, 0xce, 0x46, 0x89, 0xc2, 0xb9, 0xfc,
	0x76, 0x85, 0x73, 0x65, 0xde, 0xc2, 0x39, 0xa3, 0x55, 0x31, 0x06, 0xb0, 0x14, 0xf7, 0xde, 0xc9,
	0x2e, 0x59, 0x9b, 0xed, 0x92, 0x93, 0x49, 0xb8, 0x94, 0x92, 0x84, 0x33, 0x9e, 0x2e, 0x64, 0xc7,
	0xfc, 0x92, 0x44, 0x17, 0xe9, 0xc0, 0x0a, 0x97, 0xd6, 0x39, 0x81, 0xa6, 0xf9, 0x53, 0xd0, 0xd9,
	0xe3, 0x54, 0xe4, 0x86, 0xa4, 0x78, 0xf7, 0x83, 0x9c, 0x17, 0xb2, 0x3a, 0xb9, 0xef, 0x11, 0x21,
	0xf7, 0x61, 0x3a, 0x9c, 0x79, 0xfa, 0xba, 0x4a, 0xfa, 0xd6, 0x04, 0x77, 0x7e, 0x73, 0x10, 0x49,
	0xa4, 0x8f, 0x11, 0x16, 0x57, 0xf7, 0x07, 0x03, 0x7f, 0x32, 0x70, 0x43, 0x9c, 0x0f, 0x02, 0x79,
	0x51, 0xf9, 0x47, 0x95, 0x5a, 0xee, 0xc6, 0xc3, 0x19, 0x10, 0x37, 0xe1, 0x7a, 0x86, 0x18, 0x8e,
	0xa6, 0x47, 0x72, 0x4b, 0x97, 0x24, 0xce, 0x77, 0x62, 0x0c, 0x9a, 0x45, 0x66, 0x05, 0x70, 0x04,
	0x1e, 0x09, 0x2f, 0x42, 0xfe, 0x7b, 0x84, 0xf2, 0x1e, 0x2b, 0xd9, 0x6b, 0x4c, 0xa9, 0xd0, 0x6b,
	0x4c, 0x12, 0xd0, 0x3a, 0x5c, 0x99, 0x91, 0xc7, 0xc1, 0x8c, 0x84, 0xb2, 0x8a, 0x39, 0xfe, 0x3b,
	0x86, 0x23, 0xd6, 0x55, 0x53, 0x89, 0x1c, 0x90, 0x13, 0x3f, 0xa3, 0x92, 0xa3, 0x43, 0x36, 0xbd,
	0x0f, 0x87, 0xc7, 0xa6, 0xeb, 0xe5, 0xa0, 0xda, 0x00, 0xb0, 0x22, 0xb2, 0x9e, 0x67, 0x0e, 0x51,
	0x7c, 0x05, 0xc8, 0xcc, 0xa7, 0xe6, 0x70, 0x16, 0x07, 0x4d, 0xa6, 0xa9, 0x82, 0x38, 0x98, 0x67,
	0x04, 0x2b, 0x3d, 0xcb, 0x77, 0x8d, 0x87, 0xfa, 0xaf, 0x4a, 0x16, 0x87, 0x64, 0x91, 0x66, 0xf2,
	0x60, 0x1c, 0x78, 0xdd, 0x28, 0x54, 0x47, 0x21, 0xb6, 0x3f, 0x0e, 0xa6, 0x29, 0x9e, 0x8d, 0x94,
	0xa1, 0x57, 0x55, 0x80, 0xd3, 0x50, 0x44, 0x37, 0xb3, 0xde, 0x92, 0x0b, 0x89, 0x85, 0xef, 0xfd,
	0xfb, 0x32, 0x94, 0x3b, 0xa1, 0xa3, 0xff, 0x0c, 0x6a, 0xe2, 0x5b, 0x76, 0x53, 0x91, 0x7c, 0x04,
	0x1a, 0x63, 0x27, 0x9f, 0x86, 0x47, 0x3b, 0x0b, 0xce, 0xca, 0xef, 0xc5, 0x37, 0x32, 0x37, 0x33,
	0x2a, 0xe3, 0x6e, 0x11, 0x2a, 0x2e, 0xe4, 0x77, 0x1a, 0x5c, 0x51, 0x3f, 0xbc, 0xfe, 0x5f, 0x26,
	0xaf, 0x94, 0x1d, 0xc6, 0xf7, 0xe6, 0xdd, 0x91, 0x82, 0x24, 0xed, 0xa1, 0x33, 0x1b, 0x49, 0xca,
	0x8e, 0x1c, 0x24, 0x19, 0x2f, 0x90, 0xfa, 0x0b, 0x0d, 0x2e, 0xab, 0x9e, 0x1f, 0x5b, 0x0a, 0xae,
	0x0a, 0x7a, 0xe3, 0xbb, 0xf3, 0xd1, 0x73, 0x0c, 0xdc, 0xb7, 0x68, 0x81, 0x91, 0xed, 0x5b, 0x84,
	0x26, 0xc7, 0xb7, 0xe4, 0x47, 0xaa, 0x01, 0x9c, 0x9f, 0x79, 0x7f, 0x52, 0xbd, 0x6f, 0x24, 0x09,
	0x8d, 0x76, 0x41, 0x42, 0x2e, 0xed, 0xc7, 0x50, 0x9d, 0xbe, 0xfb, 0x6c, 0x29, 0x9f, 0x51, 0x18,
	0x85, 0xb1, 0x9d, 0x47, 0xc1, 0x19, 0xff, 0x08, 0x2a, 0xe4, 0x85, 0x67, 0x3d, 0xe3, 0x69, 0xc6,
	0xb8, 0x9e, 0xb1, 0xc8, 0x39, 0x7d, 0x0a, 0x8b, 0xec, 0x7d, 0x62, 0x43, 0x41, 0x4e, 0x97, 0x8d,
	0x9b, 0x99, 0xcb, 0x22, 0x3f, 0xf6, 0x70, 0xa0, 0xe2, 0x47, 0x97, 0x95, 0xfc, 0xe4, 0xc6, 0x3f,
	0x3a, 0xb0, 0x99, 0xae, 0xff, 0x56, 0xa6, 0x6f, 0x4d, 0x09, 0x95, 0x07, 0xa6, 0x6a, 0xeb, 0xf5,
	0x00, 0xf4, 0x94, 0x96, 0xfe, 0x76, 0x3e, 0x1b, 0x46, 0x6a, 0xec, 0x16, 0x26, 0xe5, 0x32, 0xc7,
	0x70, 0x31, 0xad, 0x0f, 0xdf, 0xc9, 0xe7, 0x14, 0xd3, 0x1a, 0x7b, 0xc5, 0x69, 0x67, 0x55, 0x95,
	0x5a, 0xec, 0xdb, 0x45, 0xae, 0x2d, 0x35, 0xee, 0x6e, 0x61, 0x52, 0x2e, 0xf3, 0x17, 0xf0, 0x5e,
	0x7a, 0xfb, 0x7c, 0xb7, 0x08, 0x2f, 0xae, 0xee, 0xff, 0xcf, 0x43, 0x3d, 0x6b, 0x67, 0xb9, 0xf3,
	0xcc, 0xb6, 0xb3, 0x44, 0x9b, 0x63, 0xe7, 0xd4, 0x76, 0x32, 0xba, 0x10, 0xac, 0x1b, 0xdf, 0xc8,
	0x6c, 0xd2, 0x94, 0x17, 0x42, 0xee, 0x44, 0xa3, 0xec, 0x28, 0x77, 0xa1, 0x37, 0x8a, 0xf4, 0x7e,
	0x46, 0xa1, 0x3e, 0x53, 0x14, 0x22, 0xff, 0x37, 0x5d, 0x25, 0x44, 0xa2, 0x52, 0x0a, 0x49, 0xfd,
	0xb7, 0xb8, 0xfe, 0x5b, 0x0d, 0xea, 0xca, 0xbe, 0xa0, 0xad, 0x0c, 0x5e, 0xe9, 0x1b, 0x8c, 0x7b,
	0x73, 0x6e, 0xe0, 0x30, 0x5c, 0x38, 0x97, 0xec, 0x8c, 0xde, 0xcf, 0xd0, 0x43, 0xa0, 0x33, 0x5a,
	0xc5, 0xe8, 0xc4, 0x3b, 0x97, 0xd2, 0x7a, 0xdc, 0x56, 0x46, 0xd6, 0x24, 0xa9, 0xf2, 0xce, 0xa9,
	0xfb, 0x0d, 0xfd, 0x29, 0xac, 0x26, 0x9a, 0x8d, 0x9b, 0xf9, 0xd1, 0xe2, 0x11, 0x42, 0xc6, 0x07,
	0x85, 0xc8, 0x66, 0x03, 0xb5, 0xd0, 0x47, 0xdc, 0x2a, 0x72, 0x51, 0x23, 0x59, 0xed, 0x82, 0x84,
	0x62, 0x24, 0x49, 0x6f, 0x12, 0x32, 0x5c, 0x70, 0x96, 0x5a, 0x19, 0x49, 0x32, 0xfb, 0x02, 0xe2,
	0xb8, 0xca, 0xae, 0xa0, 0x9d, 0x79, 0x44, 0x29, 0x18, 0xee, 0xcd, 0xb9, 0x41, 0xac, 0x2e, 0xa6,
	0x8d, 0x80, 0xaa, 0xba, 0xe0, 0x14, 0xca, 0xea, 0x62, 0xa6, 0xce, 0x37, 0x16, 0x7e, 0xfd, 0xcd,
	0xd7, 0x3b, 0xda, 0xc1, 0x4f, 0xfe, 0xf2, 0xba, 0xa1, 0xbd, 0x7c, 0xdd, 0xd0, 0xfe, 0xf9, 0xba,
	0xa1, 0x7d, 0xf5, 0xa6, 0x71, 0xe6, 0xe5, 0x9b, 0xc6, 0x99, 0x7f, 0xbc, 0x69, 0x9c, 0xf9, 0xf2,
	0xa1, 0xe3, 0xe2, 0xe3, 0x71, 0xbf, 0x65, 0xf9, 0xc3, 0x36, 0x61, 0xfa, 0x81, 0x87, 0xf0, 0xc4,
	0x0f, 0x7e, 0xce, 0x46, 0x03, 0x64, 0x3b, 0x28, 0x68, 0x9f, 0x0a, 0x3f, 0xd9, 0x21, 0xbf, 0x25,
	0x22, 0x3f, 0xda, 0x69, 0x9f, 0xec, 0xf6, 0x17, 0xc9, 0x33, 0xcd, 0x87, 0xff, 0x0d, 0x00, 0x00,
	0xff, 0xff, 0x38, 0xb2, 0xf7, 0x3f, 0x9b, 0x24, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	// CreateClass creates a new credit class under the given credit type with an
	// approved list of issuers and optional metadata. If the class fee parameter
	// is set, the fee field must be populated with equal value. A greater fee can
	// be provided, however, the creator will only be charged the amount specified
	// in the fee parameter. The creator of the credit class becomes the admin of
	// the credit class upon creation.
	CreateClass(ctx context.Context, in *MsgCreateClass, opts ...grpc.CallOption) (*MsgCreateClassResponse, error)
	// CreateProject creates a new project under the given credit class with a
	// jurisdiction, optional metadata, and an optional reference ID. The creator
	// of the project must be an approved credit class issuer for the given credit
	// class. The creator becomes the admin of the project upon creation.
	CreateProject(ctx context.Context, in *MsgCreateProject, opts ...grpc.CallOption) (*MsgCreateProjectResponse, error)
	// CreateUnregisteredProject creates a new project without registering it
	// under a credit class. This method is intended to be used by project proponents
	// who are not yet ready to register their project under a credit class, but who
	// want to create a project and receive a project ID.
	CreateUnregisteredProject(ctx context.Context, in *MsgCreateUnregisteredProject, opts ...grpc.CallOption) (*MsgCreateUnregisteredProjectResponse, error)
	// CreateOrUpdateApplicaton creates a new project credit class application, updates
	// the metadata for an existing one when changes have been requested, or withdraws
	// the application. When an application is withdrawn, its data will be deleted from
	// state and the project may apply again to the same credit class in the future.
	//
	// Since Revision 3
	CreateOrUpdateApplication(ctx context.Context, in *MsgCreateOrUpdateApplication, opts ...grpc.CallOption) (*MsgCreateOrUpdateApplicationResponse, error)
	// UpdateProjectEnrollment allows a credit class issuer to evaluate a project
	// application - either approving, requesting changes to, or
	// rejecting it, or to terminate an existing enrollment.
	// Any issuer in the credit class may update the project credit
	// class enrollment status using this method. If more sophisticated rules are
	// required to coordinate between different issuers, the credit class admin
	// should set up an on or off-chain governance process to coordinate this.
	// Issuers may not admit projects into credit classes using this method
	// without the project first creating an application. For an issuer to
	// admit a project into a credit class without an
	// application the CreateProject method should be used instead.
	//
	// If a project has not yet been accepted then the issuer may change the
	// status to either changes requested, accepted or rejected. If the status
	// is already accepted, the issuer may only change the status to terminated.
	// Whenever a project is rejected or terminated, the project's enrollment
	// the enrollment state will be deleted and the project may apply again
	// to the same credit class in the future.
	//
	// Since Revision 3
	UpdateProjectEnrollment(ctx context.Context, in *MsgUpdateProjectEnrollment, opts ...grpc.CallOption) (*MsgUpdateProjectEnrollmentResponse, error)
	// CreateBatch creates a new batch of credits under the given project with a
	// start and end date representing the monitoring period, a list of credits to
	// be issued with each issuance specifying a recipient, the amount of tradable
	// and retired credits, and the retirement jurisdiction (if credits are to be
	// retired upon receipt), and optional metadata. The credit batch creator must
	// be listed as an approved issuer within the credit class of the project that
	// the credits are being issued under.
	//
	// The default behavior is for a new credit batch to be "sealed" as opposed to
	// being "open". When a credit batch is "open", new credits can be dynamically
	// minted to the credit batch following the creation of the credit batch. This
	// "open" option should only be set to true when bridging credits from another
	// chain or registry as a result of a bridge operation and is not intended for
	// native credit issuance.
	CreateBatch(ctx context.Context, in *MsgCreateBatch, opts ...grpc.CallOption) (*MsgCreateBatchResponse, error)
	// MintBatchCredits dynamically mints credits to an "open" credit batch. This
	// feature is only meant to be used when bridging credits from another chain
	// or registry and is not intended for native credit issuance. When bridging
	// credits from the same vintage (or monitoring period) as an existing credit
	// batch, the credits can be dynamically minted to the existing credit batch
	// if the credit batch is "open".
	MintBatchCredits(ctx context.Context, in *MsgMintBatchCredits, opts ...grpc.CallOption) (*MsgMintBatchCreditsResponse, error)
	// MsgSealBatch seals an "open" credit batch. Once a credit batch is sealed
	// (i.e. once "open" is set to false), credits can no longer be dynamically
	// minted to the credit batch. A sealed credit batch cannot be unsealed and
	// only the credit batch issuer can seal a credit batch.
	SealBatch(ctx context.Context, in *MsgSealBatch, opts ...grpc.CallOption) (*MsgSealBatchResponse, error)
	// Send sends a specified amount of tradable credits from the credit owner's
	// account to another account. Sent credits can either remain tradable or be
	// retired upon receipt.
	Send(ctx context.Context, in *MsgSend, opts ...grpc.CallOption) (*MsgSendResponse, error)
	// Retire retires a specified amount of tradable credits, removing the amount
	// from the credit owner's tradable balance and adding it to their retired
	// balance. Retiring credits is permanent and implies the credits are being
	// consumed as a offset.
	Retire(ctx context.Context, in *MsgRetire, opts ...grpc.CallOption) (*MsgRetireResponse, error)
	// Cancel cancels a specified amount of tradable credits, removing the amount
	// from the credit owner's tradable balance and removing the amount from the
	// credit batch's tradable supply. Cancelling credits is permanent and implies
	// the credits have been moved to another chain or registry.
	Cancel(ctx context.Context, in *MsgCancel, opts ...grpc.CallOption) (*MsgCancelResponse, error)
	// UpdateClassAdmin updates the credit class admin. Only the admin of the
	// credit class can update the credit class.
	UpdateClassAdmin(ctx context.Context, in *MsgUpdateClassAdmin, opts ...grpc.CallOption) (*MsgUpdateClassAdminResponse, error)
	// UpdateClassIssuers updates the credit class issuer list. Only the admin of
	// the credit class can update the credit class.
	UpdateClassIssuers(ctx context.Context, in *MsgUpdateClassIssuers, opts ...grpc.CallOption) (*MsgUpdateClassIssuersResponse, error)
	// UpdateClassMetadata updates the credit class metadata. Only the admin of
	// the credit class can update the credit class.
	UpdateClassMetadata(ctx context.Context, in *MsgUpdateClassMetadata, opts ...grpc.CallOption) (*MsgUpdateClassMetadataResponse, error)
	// UpdateProjectAdmin updates the project admin address. Only the admin of the
	// project can update the project.
	UpdateProjectAdmin(ctx context.Context, in *MsgUpdateProjectAdmin, opts ...grpc.CallOption) (*MsgUpdateProjectAdminResponse, error)
	// UpdateProjectMetadata updates the project metadata. Only the admin of the
	// project can update the project.
	UpdateProjectMetadata(ctx context.Context, in *MsgUpdateProjectMetadata, opts ...grpc.CallOption) (*MsgUpdateProjectMetadataResponse, error)
	// UpdateBatchMetadata updates the batch metadata. Only an "open" batch can be
	// updated and only the issuer of the batch can update the batch.
	//
	// Since Revision 2
	UpdateBatchMetadata(ctx context.Context, in *MsgUpdateBatchMetadata, opts ...grpc.CallOption) (*MsgUpdateBatchMetadataResponse, error)
	// Bridge processes credits being sent back to the source chain. When credits
	// are sent back to the source chain, the credits are cancelled and an event
	// is emitted to be handled by an external bridge service.
	Bridge(ctx context.Context, in *MsgBridge, opts ...grpc.CallOption) (*MsgBridgeResponse, error)
	// BridgeReceive processes credits being sent from another chain. When the
	// credits are sent from the same vintage as an existing credit batch within
	// the scope of the provided credit class, the credits will be minted to the
	// existing credit batch, otherwise the credits will be issued in a new credit
	// batch. The new credit batch will be created under an existing project if a
	// project with a matching reference id already exists within the scope of the
	// credit class, otherwise a new project will be created.
	BridgeReceive(ctx context.Context, in *MsgBridgeReceive, opts ...grpc.CallOption) (*MsgBridgeReceiveResponse, error)
	// AddCreditType is a governance method that allows the addition of new
	// credit types to the network.
	//
	// Since Revision 2
	AddCreditType(ctx context.Context, in *MsgAddCreditType, opts ...grpc.CallOption) (*MsgAddCreditTypeResponse, error)
	// SetClassCreatorAllowlist is a governance method that updates the class
	// creator allowlist enabled setting. When enabled, only addresses listed in
	// the allowlist can create credit classes. When disabled, any address can
	// create credit classes.
	//
	// Since Revision 2
	SetClassCreatorAllowlist(ctx context.Context, in *MsgSetClassCreatorAllowlist, opts ...grpc.CallOption) (*MsgSetClassCreatorAllowlistResponse, error)
	// AddClassCreator is a governance method that allows the addition of a new
	// address to the class creation allowlist.
	//
	// Since Revision 2
	AddClassCreator(ctx context.Context, in *MsgAddClassCreator, opts ...grpc.CallOption) (*MsgAddClassCreatorResponse, error)
	// RemoveClassCreator is a governance method that removes an
	// address from the class creation allowlist.
	//
	// Since Revision 2
	RemoveClassCreator(ctx context.Context, in *MsgRemoveClassCreator, opts ...grpc.CallOption) (*MsgRemoveClassCreatorResponse, error)
	// UpdateClassFee is a governance method that allows for updating the credit
	// class creation fee. If no fee is specified in the request, the credit
	// class creation fee will be removed and no fee will be required to create
	// a credit class.
	//
	// Since Revision 2
	UpdateClassFee(ctx context.Context, in *MsgUpdateClassFee, opts ...grpc.CallOption) (*MsgUpdateClassFeeResponse, error)
	// UpdateProjectFee is a governance method that allows for updating the
	// project creation fee. If no fee is specified in the request, the project
	// creation fee will be removed and no fee will be required to create a
	// project.
	//
	// Since Revision 3
	UpdateProjectFee(ctx context.Context, in *MsgUpdateProjectFee, opts ...grpc.CallOption) (*MsgUpdateProjectFeeResponse, error)
	// AddAllowedBridgeChain is a governance method that allows for the
	// addition of a chain to bridge ecocredits to.
	//
	// Since Revision 2
	AddAllowedBridgeChain(ctx context.Context, in *MsgAddAllowedBridgeChain, opts ...grpc.CallOption) (*MsgAddAllowedBridgeChainResponse, error)
	// RemoveAllowedBridgeChain is a governance method that allows for the
	// removal of a chain to bridge ecocredits to.
	//
	// Since Revision 2
	RemoveAllowedBridgeChain(ctx context.Context, in *MsgRemoveAllowedBridgeChain, opts ...grpc.CallOption) (*MsgRemoveAllowedBridgeChainResponse, error)
	// BurnRegen burns REGEN tokens to account for platform fees when creating or transferring credits.
	//
	// Since Revision 3
	BurnRegen(ctx context.Context, in *MsgBurnRegen, opts ...grpc.CallOption) (*MsgBurnRegenResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) CreateClass(ctx context.Context, in *MsgCreateClass, opts ...grpc.CallOption) (*MsgCreateClassResponse, error) {
	out := new(MsgCreateClassResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.v1.Msg/CreateClass", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateProject(ctx context.Context, in *MsgCreateProject, opts ...grpc.CallOption) (*MsgCreateProjectResponse, error) {
	out := new(MsgCreateProjectResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.v1.Msg/CreateProject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateUnregisteredProject(ctx context.Context, in *MsgCreateUnregisteredProject, opts ...grpc.CallOption) (*MsgCreateUnregisteredProjectResponse, error) {
	out := new(MsgCreateUnregisteredProjectResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.v1.Msg/CreateUnregisteredProject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateOrUpdateApplication(ctx context.Context, in *MsgCreateOrUpdateApplication, opts ...grpc.CallOption) (*MsgCreateOrUpdateApplicationResponse, error) {
	out := new(MsgCreateOrUpdateApplicationResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.v1.Msg/CreateOrUpdateApplication", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateProjectEnrollment(ctx context.Context, in *MsgUpdateProjectEnrollment, opts ...grpc.CallOption) (*MsgUpdateProjectEnrollmentResponse, error) {
	out := new(MsgUpdateProjectEnrollmentResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.v1.Msg/UpdateProjectEnrollment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateBatch(ctx context.Context, in *MsgCreateBatch, opts ...grpc.CallOption) (*MsgCreateBatchResponse, error) {
	out := new(MsgCreateBatchResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.v1.Msg/CreateBatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) MintBatchCredits(ctx context.Context, in *MsgMintBatchCredits, opts ...grpc.CallOption) (*MsgMintBatchCreditsResponse, error) {
	out := new(MsgMintBatchCreditsResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.v1.Msg/MintBatchCredits", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SealBatch(ctx context.Context, in *MsgSealBatch, opts ...grpc.CallOption) (*MsgSealBatchResponse, error) {
	out := new(MsgSealBatchResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.v1.Msg/SealBatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Send(ctx context.Context, in *MsgSend, opts ...grpc.CallOption) (*MsgSendResponse, error) {
	out := new(MsgSendResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.v1.Msg/Send", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Retire(ctx context.Context, in *MsgRetire, opts ...grpc.CallOption) (*MsgRetireResponse, error) {
	out := new(MsgRetireResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.v1.Msg/Retire", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Cancel(ctx context.Context, in *MsgCancel, opts ...grpc.CallOption) (*MsgCancelResponse, error) {
	out := new(MsgCancelResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.v1.Msg/Cancel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateClassAdmin(ctx context.Context, in *MsgUpdateClassAdmin, opts ...grpc.CallOption) (*MsgUpdateClassAdminResponse, error) {
	out := new(MsgUpdateClassAdminResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.v1.Msg/UpdateClassAdmin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateClassIssuers(ctx context.Context, in *MsgUpdateClassIssuers, opts ...grpc.CallOption) (*MsgUpdateClassIssuersResponse, error) {
	out := new(MsgUpdateClassIssuersResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.v1.Msg/UpdateClassIssuers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateClassMetadata(ctx context.Context, in *MsgUpdateClassMetadata, opts ...grpc.CallOption) (*MsgUpdateClassMetadataResponse, error) {
	out := new(MsgUpdateClassMetadataResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.v1.Msg/UpdateClassMetadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateProjectAdmin(ctx context.Context, in *MsgUpdateProjectAdmin, opts ...grpc.CallOption) (*MsgUpdateProjectAdminResponse, error) {
	out := new(MsgUpdateProjectAdminResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.v1.Msg/UpdateProjectAdmin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateProjectMetadata(ctx context.Context, in *MsgUpdateProjectMetadata, opts ...grpc.CallOption) (*MsgUpdateProjectMetadataResponse, error) {
	out := new(MsgUpdateProjectMetadataResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.v1.Msg/UpdateProjectMetadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateBatchMetadata(ctx context.Context, in *MsgUpdateBatchMetadata, opts ...grpc.CallOption) (*MsgUpdateBatchMetadataResponse, error) {
	out := new(MsgUpdateBatchMetadataResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.v1.Msg/UpdateBatchMetadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Bridge(ctx context.Context, in *MsgBridge, opts ...grpc.CallOption) (*MsgBridgeResponse, error) {
	out := new(MsgBridgeResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.v1.Msg/Bridge", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) BridgeReceive(ctx context.Context, in *MsgBridgeReceive, opts ...grpc.CallOption) (*MsgBridgeReceiveResponse, error) {
	out := new(MsgBridgeReceiveResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.v1.Msg/BridgeReceive", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) AddCreditType(ctx context.Context, in *MsgAddCreditType, opts ...grpc.CallOption) (*MsgAddCreditTypeResponse, error) {
	out := new(MsgAddCreditTypeResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.v1.Msg/AddCreditType", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetClassCreatorAllowlist(ctx context.Context, in *MsgSetClassCreatorAllowlist, opts ...grpc.CallOption) (*MsgSetClassCreatorAllowlistResponse, error) {
	out := new(MsgSetClassCreatorAllowlistResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.v1.Msg/SetClassCreatorAllowlist", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) AddClassCreator(ctx context.Context, in *MsgAddClassCreator, opts ...grpc.CallOption) (*MsgAddClassCreatorResponse, error) {
	out := new(MsgAddClassCreatorResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.v1.Msg/AddClassCreator", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RemoveClassCreator(ctx context.Context, in *MsgRemoveClassCreator, opts ...grpc.CallOption) (*MsgRemoveClassCreatorResponse, error) {
	out := new(MsgRemoveClassCreatorResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.v1.Msg/RemoveClassCreator", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateClassFee(ctx context.Context, in *MsgUpdateClassFee, opts ...grpc.CallOption) (*MsgUpdateClassFeeResponse, error) {
	out := new(MsgUpdateClassFeeResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.v1.Msg/UpdateClassFee", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateProjectFee(ctx context.Context, in *MsgUpdateProjectFee, opts ...grpc.CallOption) (*MsgUpdateProjectFeeResponse, error) {
	out := new(MsgUpdateProjectFeeResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.v1.Msg/UpdateProjectFee", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) AddAllowedBridgeChain(ctx context.Context, in *MsgAddAllowedBridgeChain, opts ...grpc.CallOption) (*MsgAddAllowedBridgeChainResponse, error) {
	out := new(MsgAddAllowedBridgeChainResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.v1.Msg/AddAllowedBridgeChain", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RemoveAllowedBridgeChain(ctx context.Context, in *MsgRemoveAllowedBridgeChain, opts ...grpc.CallOption) (*MsgRemoveAllowedBridgeChainResponse, error) {
	out := new(MsgRemoveAllowedBridgeChainResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.v1.Msg/RemoveAllowedBridgeChain", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) BurnRegen(ctx context.Context, in *MsgBurnRegen, opts ...grpc.CallOption) (*MsgBurnRegenResponse, error) {
	out := new(MsgBurnRegenResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.v1.Msg/BurnRegen", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	// CreateClass creates a new credit class under the given credit type with an
	// approved list of issuers and optional metadata. If the class fee parameter
	// is set, the fee field must be populated with equal value. A greater fee can
	// be provided, however, the creator will only be charged the amount specified
	// in the fee parameter. The creator of the credit class becomes the admin of
	// the credit class upon creation.
	CreateClass(context.Context, *MsgCreateClass) (*MsgCreateClassResponse, error)
	// CreateProject creates a new project under the given credit class with a
	// jurisdiction, optional metadata, and an optional reference ID. The creator
	// of the project must be an approved credit class issuer for the given credit
	// class. The creator becomes the admin of the project upon creation.
	CreateProject(context.Context, *MsgCreateProject) (*MsgCreateProjectResponse, error)
	// CreateUnregisteredProject creates a new project without registering it
	// under a credit class. This method is intended to be used by project proponents
	// who are not yet ready to register their project under a credit class, but who
	// want to create a project and receive a project ID.
	CreateUnregisteredProject(context.Context, *MsgCreateUnregisteredProject) (*MsgCreateUnregisteredProjectResponse, error)
	// CreateOrUpdateApplicaton creates a new project credit class application, updates
	// the metadata for an existing one when changes have been requested, or withdraws
	// the application. When an application is withdrawn, its data will be deleted from
	// state and the project may apply again to the same credit class in the future.
	//
	// Since Revision 3
	CreateOrUpdateApplication(context.Context, *MsgCreateOrUpdateApplication) (*MsgCreateOrUpdateApplicationResponse, error)
	// UpdateProjectEnrollment allows a credit class issuer to evaluate a project
	// application - either approving, requesting changes to, or
	// rejecting it, or to terminate an existing enrollment.
	// Any issuer in the credit class may update the project credit
	// class enrollment status using this method. If more sophisticated rules are
	// required to coordinate between different issuers, the credit class admin
	// should set up an on or off-chain governance process to coordinate this.
	// Issuers may not admit projects into credit classes using this method
	// without the project first creating an application. For an issuer to
	// admit a project into a credit class without an
	// application the CreateProject method should be used instead.
	//
	// If a project has not yet been accepted then the issuer may change the
	// status to either changes requested, accepted or rejected. If the status
	// is already accepted, the issuer may only change the status to terminated.
	// Whenever a project is rejected or terminated, the project's enrollment
	// the enrollment state will be deleted and the project may apply again
	// to the same credit class in the future.
	//
	// Since Revision 3
	UpdateProjectEnrollment(context.Context, *MsgUpdateProjectEnrollment) (*MsgUpdateProjectEnrollmentResponse, error)
	// CreateBatch creates a new batch of credits under the given project with a
	// start and end date representing the monitoring period, a list of credits to
	// be issued with each issuance specifying a recipient, the amount of tradable
	// and retired credits, and the retirement jurisdiction (if credits are to be
	// retired upon receipt), and optional metadata. The credit batch creator must
	// be listed as an approved issuer within the credit class of the project that
	// the credits are being issued under.
	//
	// The default behavior is for a new credit batch to be "sealed" as opposed to
	// being "open". When a credit batch is "open", new credits can be dynamically
	// minted to the credit batch following the creation of the credit batch. This
	// "open" option should only be set to true when bridging credits from another
	// chain or registry as a result of a bridge operation and is not intended for
	// native credit issuance.
	CreateBatch(context.Context, *MsgCreateBatch) (*MsgCreateBatchResponse, error)
	// MintBatchCredits dynamically mints credits to an "open" credit batch. This
	// feature is only meant to be used when bridging credits from another chain
	// or registry and is not intended for native credit issuance. When bridging
	// credits from the same vintage (or monitoring period) as an existing credit
	// batch, the credits can be dynamically minted to the existing credit batch
	// if the credit batch is "open".
	MintBatchCredits(context.Context, *MsgMintBatchCredits) (*MsgMintBatchCreditsResponse, error)
	// MsgSealBatch seals an "open" credit batch. Once a credit batch is sealed
	// (i.e. once "open" is set to false), credits can no longer be dynamically
	// minted to the credit batch. A sealed credit batch cannot be unsealed and
	// only the credit batch issuer can seal a credit batch.
	SealBatch(context.Context, *MsgSealBatch) (*MsgSealBatchResponse, error)
	// Send sends a specified amount of tradable credits from the credit owner's
	// account to another account. Sent credits can either remain tradable or be
	// retired upon receipt.
	Send(context.Context, *MsgSend) (*MsgSendResponse, error)
	// Retire retires a specified amount of tradable credits, removing the amount
	// from the credit owner's tradable balance and adding it to their retired
	// balance. Retiring credits is permanent and implies the credits are being
	// consumed as a offset.
	Retire(context.Context, *MsgRetire) (*MsgRetireResponse, error)
	// Cancel cancels a specified amount of tradable credits, removing the amount
	// from the credit owner's tradable balance and removing the amount from the
	// credit batch's tradable supply. Cancelling credits is permanent and implies
	// the credits have been moved to another chain or registry.
	Cancel(context.Context, *MsgCancel) (*MsgCancelResponse, error)
	// UpdateClassAdmin updates the credit class admin. Only the admin of the
	// credit class can update the credit class.
	UpdateClassAdmin(context.Context, *MsgUpdateClassAdmin) (*MsgUpdateClassAdminResponse, error)
	// UpdateClassIssuers updates the credit class issuer list. Only the admin of
	// the credit class can update the credit class.
	UpdateClassIssuers(context.Context, *MsgUpdateClassIssuers) (*MsgUpdateClassIssuersResponse, error)
	// UpdateClassMetadata updates the credit class metadata. Only the admin of
	// the credit class can update the credit class.
	UpdateClassMetadata(context.Context, *MsgUpdateClassMetadata) (*MsgUpdateClassMetadataResponse, error)
	// UpdateProjectAdmin updates the project admin address. Only the admin of the
	// project can update the project.
	UpdateProjectAdmin(context.Context, *MsgUpdateProjectAdmin) (*MsgUpdateProjectAdminResponse, error)
	// UpdateProjectMetadata updates the project metadata. Only the admin of the
	// project can update the project.
	UpdateProjectMetadata(context.Context, *MsgUpdateProjectMetadata) (*MsgUpdateProjectMetadataResponse, error)
	// UpdateBatchMetadata updates the batch metadata. Only an "open" batch can be
	// updated and only the issuer of the batch can update the batch.
	//
	// Since Revision 2
	UpdateBatchMetadata(context.Context, *MsgUpdateBatchMetadata) (*MsgUpdateBatchMetadataResponse, error)
	// Bridge processes credits being sent back to the source chain. When credits
	// are sent back to the source chain, the credits are cancelled and an event
	// is emitted to be handled by an external bridge service.
	Bridge(context.Context, *MsgBridge) (*MsgBridgeResponse, error)
	// BridgeReceive processes credits being sent from another chain. When the
	// credits are sent from the same vintage as an existing credit batch within
	// the scope of the provided credit class, the credits will be minted to the
	// existing credit batch, otherwise the credits will be issued in a new credit
	// batch. The new credit batch will be created under an existing project if a
	// project with a matching reference id already exists within the scope of the
	// credit class, otherwise a new project will be created.
	BridgeReceive(context.Context, *MsgBridgeReceive) (*MsgBridgeReceiveResponse, error)
	// AddCreditType is a governance method that allows the addition of new
	// credit types to the network.
	//
	// Since Revision 2
	AddCreditType(context.Context, *MsgAddCreditType) (*MsgAddCreditTypeResponse, error)
	// SetClassCreatorAllowlist is a governance method that updates the class
	// creator allowlist enabled setting. When enabled, only addresses listed in
	// the allowlist can create credit classes. When disabled, any address can
	// create credit classes.
	//
	// Since Revision 2
	SetClassCreatorAllowlist(context.Context, *MsgSetClassCreatorAllowlist) (*MsgSetClassCreatorAllowlistResponse, error)
	// AddClassCreator is a governance method that allows the addition of a new
	// address to the class creation allowlist.
	//
	// Since Revision 2
	AddClassCreator(context.Context, *MsgAddClassCreator) (*MsgAddClassCreatorResponse, error)
	// RemoveClassCreator is a governance method that removes an
	// address from the class creation allowlist.
	//
	// Since Revision 2
	RemoveClassCreator(context.Context, *MsgRemoveClassCreator) (*MsgRemoveClassCreatorResponse, error)
	// UpdateClassFee is a governance method that allows for updating the credit
	// class creation fee. If no fee is specified in the request, the credit
	// class creation fee will be removed and no fee will be required to create
	// a credit class.
	//
	// Since Revision 2
	UpdateClassFee(context.Context, *MsgUpdateClassFee) (*MsgUpdateClassFeeResponse, error)
	// UpdateProjectFee is a governance method that allows for updating the
	// project creation fee. If no fee is specified in the request, the project
	// creation fee will be removed and no fee will be required to create a
	// project.
	//
	// Since Revision 3
	UpdateProjectFee(context.Context, *MsgUpdateProjectFee) (*MsgUpdateProjectFeeResponse, error)
	// AddAllowedBridgeChain is a governance method that allows for the
	// addition of a chain to bridge ecocredits to.
	//
	// Since Revision 2
	AddAllowedBridgeChain(context.Context, *MsgAddAllowedBridgeChain) (*MsgAddAllowedBridgeChainResponse, error)
	// RemoveAllowedBridgeChain is a governance method that allows for the
	// removal of a chain to bridge ecocredits to.
	//
	// Since Revision 2
	RemoveAllowedBridgeChain(context.Context, *MsgRemoveAllowedBridgeChain) (*MsgRemoveAllowedBridgeChainResponse, error)
	// BurnRegen burns REGEN tokens to account for platform fees when creating or transferring credits.
	//
	// Since Revision 3
	BurnRegen(context.Context, *MsgBurnRegen) (*MsgBurnRegenResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) CreateClass(ctx context.Context, req *MsgCreateClass) (*MsgCreateClassResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateClass not implemented")
}
func (*UnimplementedMsgServer) CreateProject(ctx context.Context, req *MsgCreateProject) (*MsgCreateProjectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateProject not implemented")
}
func (*UnimplementedMsgServer) CreateUnregisteredProject(ctx context.Context, req *MsgCreateUnregisteredProject) (*MsgCreateUnregisteredProjectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateUnregisteredProject not implemented")
}
func (*UnimplementedMsgServer) CreateOrUpdateApplication(ctx context.Context, req *MsgCreateOrUpdateApplication) (*MsgCreateOrUpdateApplicationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateOrUpdateApplication not implemented")
}
func (*UnimplementedMsgServer) UpdateProjectEnrollment(ctx context.Context, req *MsgUpdateProjectEnrollment) (*MsgUpdateProjectEnrollmentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateProjectEnrollment not implemented")
}
func (*UnimplementedMsgServer) CreateBatch(ctx context.Context, req *MsgCreateBatch) (*MsgCreateBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBatch not implemented")
}
func (*UnimplementedMsgServer) MintBatchCredits(ctx context.Context, req *MsgMintBatchCredits) (*MsgMintBatchCreditsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MintBatchCredits not implemented")
}
func (*UnimplementedMsgServer) SealBatch(ctx context.Context, req *MsgSealBatch) (*MsgSealBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SealBatch not implemented")
}
func (*UnimplementedMsgServer) Send(ctx context.Context, req *MsgSend) (*MsgSendResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Send not implemented")
}
func (*UnimplementedMsgServer) Retire(ctx context.Context, req *MsgRetire) (*MsgRetireResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Retire not implemented")
}
func (*UnimplementedMsgServer) Cancel(ctx context.Context, req *MsgCancel) (*MsgCancelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Cancel not implemented")
}
func (*UnimplementedMsgServer) UpdateClassAdmin(ctx context.Context, req *MsgUpdateClassAdmin) (*MsgUpdateClassAdminResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateClassAdmin not implemented")
}
func (*UnimplementedMsgServer) UpdateClassIssuers(ctx context.Context, req *MsgUpdateClassIssuers) (*MsgUpdateClassIssuersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateClassIssuers not implemented")
}
func (*UnimplementedMsgServer) UpdateClassMetadata(ctx context.Context, req *MsgUpdateClassMetadata) (*MsgUpdateClassMetadataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateClassMetadata not implemented")
}
func (*UnimplementedMsgServer) UpdateProjectAdmin(ctx context.Context, req *MsgUpdateProjectAdmin) (*MsgUpdateProjectAdminResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateProjectAdmin not implemented")
}
func (*UnimplementedMsgServer) UpdateProjectMetadata(ctx context.Context, req *MsgUpdateProjectMetadata) (*MsgUpdateProjectMetadataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateProjectMetadata not implemented")
}
func (*UnimplementedMsgServer) UpdateBatchMetadata(ctx context.Context, req *MsgUpdateBatchMetadata) (*MsgUpdateBatchMetadataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateBatchMetadata not implemented")
}
func (*UnimplementedMsgServer) Bridge(ctx context.Context, req *MsgBridge) (*MsgBridgeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Bridge not implemented")
}
func (*UnimplementedMsgServer) BridgeReceive(ctx context.Context, req *MsgBridgeReceive) (*MsgBridgeReceiveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BridgeReceive not implemented")
}
func (*UnimplementedMsgServer) AddCreditType(ctx context.Context, req *MsgAddCreditType) (*MsgAddCreditTypeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddCreditType not implemented")
}
func (*UnimplementedMsgServer) SetClassCreatorAllowlist(ctx context.Context, req *MsgSetClassCreatorAllowlist) (*MsgSetClassCreatorAllowlistResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetClassCreatorAllowlist not implemented")
}
func (*UnimplementedMsgServer) AddClassCreator(ctx context.Context, req *MsgAddClassCreator) (*MsgAddClassCreatorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddClassCreator not implemented")
}
func (*UnimplementedMsgServer) RemoveClassCreator(ctx context.Context, req *MsgRemoveClassCreator) (*MsgRemoveClassCreatorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveClassCreator not implemented")
}
func (*UnimplementedMsgServer) UpdateClassFee(ctx context.Context, req *MsgUpdateClassFee) (*MsgUpdateClassFeeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateClassFee not implemented")
}
func (*UnimplementedMsgServer) UpdateProjectFee(ctx context.Context, req *MsgUpdateProjectFee) (*MsgUpdateProjectFeeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateProjectFee not implemented")
}
func (*UnimplementedMsgServer) AddAllowedBridgeChain(ctx context.Context, req *MsgAddAllowedBridgeChain) (*MsgAddAllowedBridgeChainResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddAllowedBridgeChain not implemented")
}
func (*UnimplementedMsgServer) RemoveAllowedBridgeChain(ctx context.Context, req *MsgRemoveAllowedBridgeChain) (*MsgRemoveAllowedBridgeChainResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveAllowedBridgeChain not implemented")
}
func (*UnimplementedMsgServer) BurnRegen(ctx context.Context, req *MsgBurnRegen) (*MsgBurnRegenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BurnRegen not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_CreateClass_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateClass)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateClass(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.v1.Msg/CreateClass",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateClass(ctx, req.(*MsgCreateClass))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateProject)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.v1.Msg/CreateProject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateProject(ctx, req.(*MsgCreateProject))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateUnregisteredProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateUnregisteredProject)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateUnregisteredProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.v1.Msg/CreateUnregisteredProject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateUnregisteredProject(ctx, req.(*MsgCreateUnregisteredProject))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateOrUpdateApplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateOrUpdateApplication)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateOrUpdateApplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.v1.Msg/CreateOrUpdateApplication",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateOrUpdateApplication(ctx, req.(*MsgCreateOrUpdateApplication))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateProjectEnrollment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateProjectEnrollment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateProjectEnrollment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.v1.Msg/UpdateProjectEnrollment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateProjectEnrollment(ctx, req.(*MsgUpdateProjectEnrollment))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateBatch)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.v1.Msg/CreateBatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateBatch(ctx, req.(*MsgCreateBatch))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_MintBatchCredits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgMintBatchCredits)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).MintBatchCredits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.v1.Msg/MintBatchCredits",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).MintBatchCredits(ctx, req.(*MsgMintBatchCredits))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SealBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSealBatch)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SealBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.v1.Msg/SealBatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SealBatch(ctx, req.(*MsgSealBatch))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Send_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSend)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Send(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.v1.Msg/Send",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Send(ctx, req.(*MsgSend))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Retire_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRetire)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Retire(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.v1.Msg/Retire",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Retire(ctx, req.(*MsgRetire))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Cancel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCancel)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Cancel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.v1.Msg/Cancel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Cancel(ctx, req.(*MsgCancel))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateClassAdmin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateClassAdmin)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateClassAdmin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.v1.Msg/UpdateClassAdmin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateClassAdmin(ctx, req.(*MsgUpdateClassAdmin))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateClassIssuers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateClassIssuers)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateClassIssuers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.v1.Msg/UpdateClassIssuers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateClassIssuers(ctx, req.(*MsgUpdateClassIssuers))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateClassMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateClassMetadata)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateClassMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.v1.Msg/UpdateClassMetadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateClassMetadata(ctx, req.(*MsgUpdateClassMetadata))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateProjectAdmin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateProjectAdmin)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateProjectAdmin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.v1.Msg/UpdateProjectAdmin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateProjectAdmin(ctx, req.(*MsgUpdateProjectAdmin))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateProjectMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateProjectMetadata)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateProjectMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.v1.Msg/UpdateProjectMetadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateProjectMetadata(ctx, req.(*MsgUpdateProjectMetadata))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateBatchMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateBatchMetadata)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateBatchMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.v1.Msg/UpdateBatchMetadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateBatchMetadata(ctx, req.(*MsgUpdateBatchMetadata))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Bridge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBridge)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Bridge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.v1.Msg/Bridge",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Bridge(ctx, req.(*MsgBridge))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_BridgeReceive_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBridgeReceive)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).BridgeReceive(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.v1.Msg/BridgeReceive",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).BridgeReceive(ctx, req.(*MsgBridgeReceive))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_AddCreditType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgAddCreditType)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).AddCreditType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.v1.Msg/AddCreditType",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).AddCreditType(ctx, req.(*MsgAddCreditType))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetClassCreatorAllowlist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetClassCreatorAllowlist)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetClassCreatorAllowlist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.v1.Msg/SetClassCreatorAllowlist",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetClassCreatorAllowlist(ctx, req.(*MsgSetClassCreatorAllowlist))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_AddClassCreator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgAddClassCreator)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).AddClassCreator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.v1.Msg/AddClassCreator",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).AddClassCreator(ctx, req.(*MsgAddClassCreator))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RemoveClassCreator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRemoveClassCreator)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RemoveClassCreator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.v1.Msg/RemoveClassCreator",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RemoveClassCreator(ctx, req.(*MsgRemoveClassCreator))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateClassFee_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateClassFee)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateClassFee(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.v1.Msg/UpdateClassFee",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateClassFee(ctx, req.(*MsgUpdateClassFee))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateProjectFee_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateProjectFee)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateProjectFee(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.v1.Msg/UpdateProjectFee",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateProjectFee(ctx, req.(*MsgUpdateProjectFee))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_AddAllowedBridgeChain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgAddAllowedBridgeChain)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).AddAllowedBridgeChain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.v1.Msg/AddAllowedBridgeChain",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).AddAllowedBridgeChain(ctx, req.(*MsgAddAllowedBridgeChain))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RemoveAllowedBridgeChain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRemoveAllowedBridgeChain)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RemoveAllowedBridgeChain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.v1.Msg/RemoveAllowedBridgeChain",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RemoveAllowedBridgeChain(ctx, req.(*MsgRemoveAllowedBridgeChain))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_BurnRegen_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBurnRegen)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).BurnRegen(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.v1.Msg/BurnRegen",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).BurnRegen(ctx, req.(*MsgBurnRegen))
	}
	return interceptor(ctx, in, info, handler)
}

var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "regen.ecocredit.v1.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateClass",
			Handler:    _Msg_CreateClass_Handler,
		},
		{
			MethodName: "CreateProject",
			Handler:    _Msg_CreateProject_Handler,
		},
		{
			MethodName: "CreateUnregisteredProject",
			Handler:    _Msg_CreateUnregisteredProject_Handler,
		},
		{
			MethodName: "CreateOrUpdateApplication",
			Handler:    _Msg_CreateOrUpdateApplication_Handler,
		},
		{
			MethodName: "UpdateProjectEnrollment",
			Handler:    _Msg_UpdateProjectEnrollment_Handler,
		},
		{
			MethodName: "CreateBatch",
			Handler:    _Msg_CreateBatch_Handler,
		},
		{
			MethodName: "MintBatchCredits",
			Handler:    _Msg_MintBatchCredits_Handler,
		},
		{
			MethodName: "SealBatch",
			Handler:    _Msg_SealBatch_Handler,
		},
		{
			MethodName: "Send",
			Handler:    _Msg_Send_Handler,
		},
		{
			MethodName: "Retire",
			Handler:    _Msg_Retire_Handler,
		},
		{
			MethodName: "Cancel",
			Handler:    _Msg_Cancel_Handler,
		},
		{
			MethodName: "UpdateClassAdmin",
			Handler:    _Msg_UpdateClassAdmin_Handler,
		},
		{
			MethodName: "UpdateClassIssuers",
			Handler:    _Msg_UpdateClassIssuers_Handler,
		},
		{
			MethodName: "UpdateClassMetadata",
			Handler:    _Msg_UpdateClassMetadata_Handler,
		},
		{
			MethodName: "UpdateProjectAdmin",
			Handler:    _Msg_UpdateProjectAdmin_Handler,
		},
		{
			MethodName: "UpdateProjectMetadata",
			Handler:    _Msg_UpdateProjectMetadata_Handler,
		},
		{
			MethodName: "UpdateBatchMetadata",
			Handler:    _Msg_UpdateBatchMetadata_Handler,
		},
		{
			MethodName: "Bridge",
			Handler:    _Msg_Bridge_Handler,
		},
		{
			MethodName: "BridgeReceive",
			Handler:    _Msg_BridgeReceive_Handler,
		},
		{
			MethodName: "AddCreditType",
			Handler:    _Msg_AddCreditType_Handler,
		},
		{
			MethodName: "SetClassCreatorAllowlist",
			Handler:    _Msg_SetClassCreatorAllowlist_Handler,
		},
		{
			MethodName: "AddClassCreator",
			Handler:    _Msg_AddClassCreator_Handler,
		},
		{
			MethodName: "RemoveClassCreator",
			Handler:    _Msg_RemoveClassCreator_Handler,
		},
		{
			MethodName: "UpdateClassFee",
			Handler:    _Msg_UpdateClassFee_Handler,
		},
		{
			MethodName: "UpdateProjectFee",
			Handler:    _Msg_UpdateProjectFee_Handler,
		},
		{
			MethodName: "AddAllowedBridgeChain",
			Handler:    _Msg_AddAllowedBridgeChain_Handler,
		},
		{
			MethodName: "RemoveAllowedBridgeChain",
			Handler:    _Msg_RemoveAllowedBridgeChain_Handler,
		},
		{
			MethodName: "BurnRegen",
			Handler:    _Msg_BurnRegen_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "regen/ecocredit/v1/tx.proto",
}

func (m *MsgAddCreditType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAddCreditType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAddCreditType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CreditType != nil {
		{
			size, err := m.CreditType.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgAddCreditTypeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAddCreditTypeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAddCreditTypeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgCreateClass) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateClass) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateClass) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Fee != nil {
		{
			size, err := m.Fee.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.CreditTypeAbbrev) > 0 {
		i -= len(m.CreditTypeAbbrev)
		copy(dAtA[i:], m.CreditTypeAbbrev)
		i = encodeVarintTx(dAtA, i, uint64(len(m.CreditTypeAbbrev)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Metadata) > 0 {
		i -= len(m.Metadata)
		copy(dAtA[i:], m.Metadata)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Metadata)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Issuers) > 0 {
		for iNdEx := len(m.Issuers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Issuers[iNdEx])
			copy(dAtA[i:], m.Issuers[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.Issuers[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Admin) > 0 {
		i -= len(m.Admin)
		copy(dAtA[i:], m.Admin)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Admin)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateClassResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateClassResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateClassResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ClassId) > 0 {
		i -= len(m.ClassId)
		copy(dAtA[i:], m.ClassId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ClassId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateProject) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateProject) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateProject) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Fee != nil {
		{
			size, err := m.Fee.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.ReferenceId) > 0 {
		i -= len(m.ReferenceId)
		copy(dAtA[i:], m.ReferenceId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ReferenceId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Jurisdiction) > 0 {
		i -= len(m.Jurisdiction)
		copy(dAtA[i:], m.Jurisdiction)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Jurisdiction)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Metadata) > 0 {
		i -= len(m.Metadata)
		copy(dAtA[i:], m.Metadata)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Metadata)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ClassId) > 0 {
		i -= len(m.ClassId)
		copy(dAtA[i:], m.ClassId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ClassId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Admin) > 0 {
		i -= len(m.Admin)
		copy(dAtA[i:], m.Admin)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Admin)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateProjectResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateProjectResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateProjectResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ProjectId) > 0 {
		i -= len(m.ProjectId)
		copy(dAtA[i:], m.ProjectId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ProjectId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateUnregisteredProject) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateUnregisteredProject) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateUnregisteredProject) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Fee != nil {
		{
			size, err := m.Fee.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ReferenceId) > 0 {
		i -= len(m.ReferenceId)
		copy(dAtA[i:], m.ReferenceId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ReferenceId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Jurisdiction) > 0 {
		i -= len(m.Jurisdiction)
		copy(dAtA[i:], m.Jurisdiction)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Jurisdiction)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Metadata) > 0 {
		i -= len(m.Metadata)
		copy(dAtA[i:], m.Metadata)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Metadata)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Admin) > 0 {
		i -= len(m.Admin)
		copy(dAtA[i:], m.Admin)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Admin)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateUnregisteredProjectResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateUnregisteredProjectResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateUnregisteredProjectResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ProjectId) > 0 {
		i -= len(m.ProjectId)
		copy(dAtA[i:], m.ProjectId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ProjectId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateOrUpdateApplication) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateOrUpdateApplication) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateOrUpdateApplication) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Withdraw {
		i--
		if m.Withdraw {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.Metadata) > 0 {
		i -= len(m.Metadata)
		copy(dAtA[i:], m.Metadata)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Metadata)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ClassId) > 0 {
		i -= len(m.ClassId)
		copy(dAtA[i:], m.ClassId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ClassId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ProjectId) > 0 {
		i -= len(m.ProjectId)
		copy(dAtA[i:], m.ProjectId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ProjectId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ProjectAdmin) > 0 {
		i -= len(m.ProjectAdmin)
		copy(dAtA[i:], m.ProjectAdmin)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ProjectAdmin)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateOrUpdateApplicationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateOrUpdateApplicationResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateOrUpdateApplicationResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgUpdateProjectEnrollment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateProjectEnrollment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateProjectEnrollment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Metadata) > 0 {
		i -= len(m.Metadata)
		copy(dAtA[i:], m.Metadata)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Metadata)))
		i--
		dAtA[i] = 0x2a
	}
	if m.NewStatus != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.NewStatus))
		i--
		dAtA[i] = 0x20
	}
	if len(m.ClassId) > 0 {
		i -= len(m.ClassId)
		copy(dAtA[i:], m.ClassId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ClassId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ProjectId) > 0 {
		i -= len(m.ProjectId)
		copy(dAtA[i:], m.ProjectId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ProjectId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Issuer) > 0 {
		i -= len(m.Issuer)
		copy(dAtA[i:], m.Issuer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Issuer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateProjectEnrollmentResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateProjectEnrollmentResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateProjectEnrollmentResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgCreateBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateBatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateBatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ClassId) > 0 {
		i -= len(m.ClassId)
		copy(dAtA[i:], m.ClassId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ClassId)))
		i--
		dAtA[i] = 0x4a
	}
	if m.OriginTx != nil {
		{
			size, err := m.OriginTx.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Open {
		i--
		if m.Open {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.EndDate != nil {
		n6, err6 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.EndDate, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.EndDate):])
		if err6 != nil {
			return 0, err6
		}
		i -= n6
		i = encodeVarintTx(dAtA, i, uint64(n6))
		i--
		dAtA[i] = 0x32
	}
	if m.StartDate != nil {
		n7, err7 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.StartDate, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.StartDate):])
		if err7 != nil {
			return 0, err7
		}
		i -= n7
		i = encodeVarintTx(dAtA, i, uint64(n7))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Metadata) > 0 {
		i -= len(m.Metadata)
		copy(dAtA[i:], m.Metadata)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Metadata)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Issuance) > 0 {
		for iNdEx := len(m.Issuance) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Issuance[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ProjectId) > 0 {
		i -= len(m.ProjectId)
		copy(dAtA[i:], m.ProjectId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ProjectId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Issuer) > 0 {
		i -= len(m.Issuer)
		copy(dAtA[i:], m.Issuer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Issuer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateBatchResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateBatchResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateBatchResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BatchDenom) > 0 {
		i -= len(m.BatchDenom)
		copy(dAtA[i:], m.BatchDenom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.BatchDenom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgMintBatchCredits) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgMintBatchCredits) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgMintBatchCredits) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OriginTx != nil {
		{
			size, err := m.OriginTx.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Issuance) > 0 {
		for iNdEx := len(m.Issuance) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Issuance[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.BatchDenom) > 0 {
		i -= len(m.BatchDenom)
		copy(dAtA[i:], m.BatchDenom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.BatchDenom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Issuer) > 0 {
		i -= len(m.Issuer)
		copy(dAtA[i:], m.Issuer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Issuer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgMintBatchCreditsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgMintBatchCreditsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgMintBatchCreditsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgSealBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSealBatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSealBatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BatchDenom) > 0 {
		i -= len(m.BatchDenom)
		copy(dAtA[i:], m.BatchDenom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.BatchDenom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Issuer) > 0 {
		i -= len(m.Issuer)
		copy(dAtA[i:], m.Issuer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Issuer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSealBatchResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSealBatchResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSealBatchResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgSend) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSend) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSend) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Credits) > 0 {
		for iNdEx := len(m.Credits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Credits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Recipient) > 0 {
		i -= len(m.Recipient)
		copy(dAtA[i:], m.Recipient)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Recipient)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSend_SendCredits) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSend_SendCredits) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSend_SendCredits) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RetirementReason) > 0 {
		i -= len(m.RetirementReason)
		copy(dAtA[i:], m.RetirementReason)
		i = encodeVarintTx(dAtA, i, uint64(len(m.RetirementReason)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.RetirementJurisdiction) > 0 {
		i -= len(m.RetirementJurisdiction)
		copy(dAtA[i:], m.RetirementJurisdiction)
		i = encodeVarintTx(dAtA, i, uint64(len(m.RetirementJurisdiction)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.RetiredAmount) > 0 {
		i -= len(m.RetiredAmount)
		copy(dAtA[i:], m.RetiredAmount)
		i = encodeVarintTx(dAtA, i, uint64(len(m.RetiredAmount)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TradableAmount) > 0 {
		i -= len(m.TradableAmount)
		copy(dAtA[i:], m.TradableAmount)
		i = encodeVarintTx(dAtA, i, uint64(len(m.TradableAmount)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.BatchDenom) > 0 {
		i -= len(m.BatchDenom)
		copy(dAtA[i:], m.BatchDenom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.BatchDenom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSendResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSendResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSendResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgRetire) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRetire) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRetire) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Jurisdiction) > 0 {
		i -= len(m.Jurisdiction)
		copy(dAtA[i:], m.Jurisdiction)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Jurisdiction)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Credits) > 0 {
		for iNdEx := len(m.Credits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Credits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRetireResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRetireResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRetireResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgCancel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCancel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCancel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Credits) > 0 {
		for iNdEx := len(m.Credits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Credits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCancelResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCancelResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCancelResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgUpdateClassAdmin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateClassAdmin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateClassAdmin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewAdmin) > 0 {
		i -= len(m.NewAdmin)
		copy(dAtA[i:], m.NewAdmin)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NewAdmin)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ClassId) > 0 {
		i -= len(m.ClassId)
		copy(dAtA[i:], m.ClassId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ClassId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Admin) > 0 {
		i -= len(m.Admin)
		copy(dAtA[i:], m.Admin)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Admin)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateClassAdminResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateClassAdminResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateClassAdminResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgUpdateClassIssuers) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateClassIssuers) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateClassIssuers) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RemoveIssuers) > 0 {
		for iNdEx := len(m.RemoveIssuers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RemoveIssuers[iNdEx])
			copy(dAtA[i:], m.RemoveIssuers[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.RemoveIssuers[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.AddIssuers) > 0 {
		for iNdEx := len(m.AddIssuers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AddIssuers[iNdEx])
			copy(dAtA[i:], m.AddIssuers[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.AddIssuers[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ClassId) > 0 {
		i -= len(m.ClassId)
		copy(dAtA[i:], m.ClassId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ClassId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Admin) > 0 {
		i -= len(m.Admin)
		copy(dAtA[i:], m.Admin)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Admin)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateClassIssuersResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateClassIssuersResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateClassIssuersResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgUpdateClassMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateClassMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateClassMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewMetadata) > 0 {
		i -= len(m.NewMetadata)
		copy(dAtA[i:], m.NewMetadata)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NewMetadata)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ClassId) > 0 {
		i -= len(m.ClassId)
		copy(dAtA[i:], m.ClassId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ClassId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Admin) > 0 {
		i -= len(m.Admin)
		copy(dAtA[i:], m.Admin)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Admin)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateClassMetadataResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateClassMetadataResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateClassMetadataResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgUpdateProjectAdmin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateProjectAdmin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateProjectAdmin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewAdmin) > 0 {
		i -= len(m.NewAdmin)
		copy(dAtA[i:], m.NewAdmin)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NewAdmin)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ProjectId) > 0 {
		i -= len(m.ProjectId)
		copy(dAtA[i:], m.ProjectId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ProjectId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Admin) > 0 {
		i -= len(m.Admin)
		copy(dAtA[i:], m.Admin)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Admin)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateProjectAdminResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateProjectAdminResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateProjectAdminResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgUpdateProjectMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateProjectMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateProjectMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewMetadata) > 0 {
		i -= len(m.NewMetadata)
		copy(dAtA[i:], m.NewMetadata)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NewMetadata)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ProjectId) > 0 {
		i -= len(m.ProjectId)
		copy(dAtA[i:], m.ProjectId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ProjectId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Admin) > 0 {
		i -= len(m.Admin)
		copy(dAtA[i:], m.Admin)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Admin)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateProjectMetadataResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateProjectMetadataResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateProjectMetadataResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgBridge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBridge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBridge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Credits) > 0 {
		for iNdEx := len(m.Credits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Credits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Recipient) > 0 {
		i -= len(m.Recipient)
		copy(dAtA[i:], m.Recipient)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Recipient)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Target) > 0 {
		i -= len(m.Target)
		copy(dAtA[i:], m.Target)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Target)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateBatchMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateBatchMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateBatchMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewMetadata) > 0 {
		i -= len(m.NewMetadata)
		copy(dAtA[i:], m.NewMetadata)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NewMetadata)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.BatchDenom) > 0 {
		i -= len(m.BatchDenom)
		copy(dAtA[i:], m.BatchDenom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.BatchDenom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Issuer) > 0 {
		i -= len(m.Issuer)
		copy(dAtA[i:], m.Issuer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Issuer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateBatchMetadataResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateBatchMetadataResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateBatchMetadataResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgBridgeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBridgeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBridgeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgBridgeReceive) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBridgeReceive) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBridgeReceive) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OriginTx != nil {
		{
			size, err := m.OriginTx.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Batch != nil {
		{
			size, err := m.Batch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Project != nil {
		{
			size, err := m.Project.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ClassId) > 0 {
		i -= len(m.ClassId)
		copy(dAtA[i:], m.ClassId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ClassId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Issuer) > 0 {
		i -= len(m.Issuer)
		copy(dAtA[i:], m.Issuer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Issuer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgBridgeReceive_Batch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBridgeReceive_Batch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBridgeReceive_Batch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Metadata) > 0 {
		i -= len(m.Metadata)
		copy(dAtA[i:], m.Metadata)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Metadata)))
		i--
		dAtA[i] = 0x2a
	}
	if m.EndDate != nil {
		n12, err12 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.EndDate, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.EndDate):])
		if err12 != nil {
			return 0, err12
		}
		i -= n12
		i = encodeVarintTx(dAtA, i, uint64(n12))
		i--
		dAtA[i] = 0x22
	}
	if m.StartDate != nil {
		n13, err13 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.StartDate, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.StartDate):])
		if err13 != nil {
			return 0, err13
		}
		i -= n13
		i = encodeVarintTx(dAtA, i, uint64(n13))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Recipient) > 0 {
		i -= len(m.Recipient)
		copy(dAtA[i:], m.Recipient)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Recipient)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgBridgeReceive_Project) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBridgeReceive_Project) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBridgeReceive_Project) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Metadata) > 0 {
		i -= len(m.Metadata)
		copy(dAtA[i:], m.Metadata)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Metadata)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Jurisdiction) > 0 {
		i -= len(m.Jurisdiction)
		copy(dAtA[i:], m.Jurisdiction)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Jurisdiction)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ReferenceId) > 0 {
		i -= len(m.ReferenceId)
		copy(dAtA[i:], m.ReferenceId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ReferenceId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgBridgeReceiveResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBridgeReceiveResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBridgeReceiveResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ProjectId) > 0 {
		i -= len(m.ProjectId)
		copy(dAtA[i:], m.ProjectId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ProjectId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.BatchDenom) > 0 {
		i -= len(m.BatchDenom)
		copy(dAtA[i:], m.BatchDenom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.BatchDenom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgAddClassCreator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAddClassCreator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAddClassCreator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgAddClassCreatorResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAddClassCreatorResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAddClassCreatorResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgSetClassCreatorAllowlist) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetClassCreatorAllowlist) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetClassCreatorAllowlist) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSetClassCreatorAllowlistResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetClassCreatorAllowlistResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetClassCreatorAllowlistResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgRemoveClassCreator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRemoveClassCreator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRemoveClassCreator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRemoveClassCreatorResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRemoveClassCreatorResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRemoveClassCreatorResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgUpdateClassFee) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateClassFee) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateClassFee) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Fee != nil {
		{
			size, err := m.Fee.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateClassFeeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateClassFeeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateClassFeeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgUpdateProjectFee) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateProjectFee) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateProjectFee) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Fee != nil {
		{
			size, err := m.Fee.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateProjectFeeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateProjectFeeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateProjectFeeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgAddAllowedBridgeChain) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAddAllowedBridgeChain) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAddAllowedBridgeChain) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChainName) > 0 {
		i -= len(m.ChainName)
		copy(dAtA[i:], m.ChainName)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ChainName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgAddAllowedBridgeChainResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAddAllowedBridgeChainResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAddAllowedBridgeChainResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgRemoveAllowedBridgeChain) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRemoveAllowedBridgeChain) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRemoveAllowedBridgeChain) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChainName) > 0 {
		i -= len(m.ChainName)
		copy(dAtA[i:], m.ChainName)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ChainName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRemoveAllowedBridgeChainResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRemoveAllowedBridgeChainResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRemoveAllowedBridgeChainResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgBurnRegen) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBurnRegen) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBurnRegen) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Burner) > 0 {
		i -= len(m.Burner)
		copy(dAtA[i:], m.Burner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Burner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgBurnRegenResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBurnRegenResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBurnRegenResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgAddCreditType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.CreditType != nil {
		l = m.CreditType.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgAddCreditTypeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgCreateClass) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Issuers) > 0 {
		for _, s := range m.Issuers {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.CreditTypeAbbrev)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Fee != nil {
		l = m.Fee.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgCreateClassResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClassId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgCreateProject) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ClassId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Jurisdiction)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ReferenceId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Fee != nil {
		l = m.Fee.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgCreateProjectResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProjectId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgCreateUnregisteredProject) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Jurisdiction)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ReferenceId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Fee != nil {
		l = m.Fee.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgCreateUnregisteredProjectResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProjectId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgCreateOrUpdateApplication) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProjectAdmin)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ProjectId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ClassId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Withdraw {
		n += 2
	}
	return n
}

func (m *MsgCreateOrUpdateApplicationResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgUpdateProjectEnrollment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Issuer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ProjectId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ClassId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.NewStatus != 0 {
		n += 1 + sovTx(uint64(m.NewStatus))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateProjectEnrollmentResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgCreateBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Issuer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ProjectId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Issuance) > 0 {
		for _, e := range m.Issuance {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.StartDate != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.StartDate)
		n += 1 + l + sovTx(uint64(l))
	}
	if m.EndDate != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.EndDate)
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Open {
		n += 2
	}
	if m.OriginTx != nil {
		l = m.OriginTx.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ClassId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgCreateBatchResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BatchDenom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgMintBatchCredits) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Issuer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.BatchDenom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Issuance) > 0 {
		for _, e := range m.Issuance {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.OriginTx != nil {
		l = m.OriginTx.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgMintBatchCreditsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgSealBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Issuer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.BatchDenom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgSealBatchResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgSend) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Recipient)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Credits) > 0 {
		for _, e := range m.Credits {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgSend_SendCredits) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BatchDenom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.TradableAmount)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.RetiredAmount)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.RetirementJurisdiction)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.RetirementReason)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgSendResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgRetire) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Credits) > 0 {
		for _, e := range m.Credits {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	l = len(m.Jurisdiction)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgRetireResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgCancel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Credits) > 0 {
		for _, e := range m.Credits {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgCancelResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgUpdateClassAdmin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ClassId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.NewAdmin)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateClassAdminResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgUpdateClassIssuers) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ClassId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.AddIssuers) > 0 {
		for _, s := range m.AddIssuers {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.RemoveIssuers) > 0 {
		for _, s := range m.RemoveIssuers {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgUpdateClassIssuersResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgUpdateClassMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ClassId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.NewMetadata)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateClassMetadataResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgUpdateProjectAdmin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ProjectId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.NewAdmin)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateProjectAdminResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgUpdateProjectMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ProjectId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.NewMetadata)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateProjectMetadataResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgBridge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Target)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Recipient)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Credits) > 0 {
		for _, e := range m.Credits {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgUpdateBatchMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Issuer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.BatchDenom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.NewMetadata)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateBatchMetadataResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgBridgeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgBridgeReceive) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Issuer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ClassId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Project != nil {
		l = m.Project.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Batch != nil {
		l = m.Batch.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.OriginTx != nil {
		l = m.OriginTx.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgBridgeReceive_Batch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Recipient)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.StartDate != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.StartDate)
		n += 1 + l + sovTx(uint64(l))
	}
	if m.EndDate != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.EndDate)
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgBridgeReceive_Project) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ReferenceId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Jurisdiction)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgBridgeReceiveResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BatchDenom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ProjectId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgAddClassCreator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgAddClassCreatorResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgSetClassCreatorAllowlist) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Enabled {
		n += 2
	}
	return n
}

func (m *MsgSetClassCreatorAllowlistResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgRemoveClassCreator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgRemoveClassCreatorResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgUpdateClassFee) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Fee != nil {
		l = m.Fee.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateClassFeeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgUpdateProjectFee) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Fee != nil {
		l = m.Fee.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateProjectFeeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgAddAllowedBridgeChain) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ChainName)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgAddAllowedBridgeChainResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgRemoveAllowedBridgeChain) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ChainName)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgRemoveAllowedBridgeChainResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgBurnRegen) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Burner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgBurnRegenResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgAddCreditType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAddCreditType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAddCreditType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreditType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreditType == nil {
				m.CreditType = &CreditType{}
			}
			if err := m.CreditType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAddCreditTypeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAddCreditTypeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAddCreditTypeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateClass) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateClass: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateClass: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issuers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Issuers = append(m.Issuers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreditTypeAbbrev", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreditTypeAbbrev = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fee == nil {
				m.Fee = &types.Coin{}
			}
			if err := m.Fee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateClassResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateClassResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateClassResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClassId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateProject) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateProject: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateProject: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClassId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jurisdiction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Jurisdiction = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReferenceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fee == nil {
				m.Fee = &types.Coin{}
			}
			if err := m.Fee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateProjectResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateProjectResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateProjectResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateUnregisteredProject) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateUnregisteredProject: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateUnregisteredProject: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jurisdiction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Jurisdiction = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReferenceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fee == nil {
				m.Fee = &types.Coin{}
			}
			if err := m.Fee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateUnregisteredProjectResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateUnregisteredProjectResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateUnregisteredProjectResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateOrUpdateApplication) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateOrUpdateApplication: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateOrUpdateApplication: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectAdmin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectAdmin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClassId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Withdraw", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Withdraw = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateOrUpdateApplicationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateOrUpdateApplicationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateOrUpdateApplicationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateProjectEnrollment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateProjectEnrollment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateProjectEnrollment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issuer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Issuer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClassId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewStatus", wireType)
			}
			m.NewStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewStatus |= ProjectEnrollmentStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateProjectEnrollmentResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateProjectEnrollmentResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateProjectEnrollmentResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateBatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateBatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issuer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Issuer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issuance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Issuance = append(m.Issuance, &BatchIssuance{})
			if err := m.Issuance[len(m.Issuance)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartDate == nil {
				m.StartDate = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.StartDate, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndDate == nil {
				m.EndDate = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.EndDate, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Open", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Open = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginTx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OriginTx == nil {
				m.OriginTx = &OriginTx{}
			}
			if err := m.OriginTx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClassId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateBatchResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateBatchResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateBatchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgMintBatchCredits) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgMintBatchCredits: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgMintBatchCredits: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issuer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Issuer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issuance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Issuance = append(m.Issuance, &BatchIssuance{})
			if err := m.Issuance[len(m.Issuance)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginTx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OriginTx == nil {
				m.OriginTx = &OriginTx{}
			}
			if err := m.OriginTx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgMintBatchCreditsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgMintBatchCreditsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgMintBatchCreditsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSealBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSealBatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSealBatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issuer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Issuer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSealBatchResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSealBatchResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSealBatchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSend) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSend: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSend: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recipient", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Recipient = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Credits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Credits = append(m.Credits, &MsgSend_SendCredits{})
			if err := m.Credits[len(m.Credits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSend_SendCredits) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendCredits: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendCredits: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradableAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TradableAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetiredAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetiredAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetirementJurisdiction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetirementJurisdiction = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetirementReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetirementReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSendResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSendResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSendResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRetire) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRetire: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRetire: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Credits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Credits = append(m.Credits, &Credits{})
			if err := m.Credits[len(m.Credits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jurisdiction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Jurisdiction = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRetireResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRetireResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRetireResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCancel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCancel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCancel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Credits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Credits = append(m.Credits, &Credits{})
			if err := m.Credits[len(m.Credits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCancelResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCancelResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCancelResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateClassAdmin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateClassAdmin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateClassAdmin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClassId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewAdmin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewAdmin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateClassAdminResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateClassAdminResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateClassAdminResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateClassIssuers) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateClassIssuers: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateClassIssuers: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClassId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddIssuers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddIssuers = append(m.AddIssuers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveIssuers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoveIssuers = append(m.RemoveIssuers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateClassIssuersResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateClassIssuersResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateClassIssuersResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateClassMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateClassMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateClassMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClassId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewMetadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewMetadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateClassMetadataResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateClassMetadataResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateClassMetadataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateProjectAdmin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateProjectAdmin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateProjectAdmin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewAdmin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewAdmin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateProjectAdminResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateProjectAdminResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateProjectAdminResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateProjectMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateProjectMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateProjectMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewMetadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewMetadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateProjectMetadataResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateProjectMetadataResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateProjectMetadataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBridge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBridge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBridge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recipient", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Recipient = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Credits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Credits = append(m.Credits, &Credits{})
			if err := m.Credits[len(m.Credits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateBatchMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateBatchMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateBatchMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issuer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Issuer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewMetadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewMetadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateBatchMetadataResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateBatchMetadataResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateBatchMetadataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBridgeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBridgeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBridgeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBridgeReceive) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBridgeReceive: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBridgeReceive: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issuer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Issuer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClassId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Project", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Project == nil {
				m.Project = &MsgBridgeReceive_Project{}
			}
			if err := m.Project.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Batch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Batch == nil {
				m.Batch = &MsgBridgeReceive_Batch{}
			}
			if err := m.Batch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginTx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OriginTx == nil {
				m.OriginTx = &OriginTx{}
			}
			if err := m.OriginTx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBridgeReceive_Batch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Batch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Batch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recipient", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Recipient = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartDate == nil {
				m.StartDate = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.StartDate, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndDate == nil {
				m.EndDate = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.EndDate, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBridgeReceive_Project) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Project: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Project: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReferenceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jurisdiction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Jurisdiction = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBridgeReceiveResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBridgeReceiveResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBridgeReceiveResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAddClassCreator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAddClassCreator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAddClassCreator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAddClassCreatorResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAddClassCreatorResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAddClassCreatorResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetClassCreatorAllowlist) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetClassCreatorAllowlist: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetClassCreatorAllowlist: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetClassCreatorAllowlistResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetClassCreatorAllowlistResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetClassCreatorAllowlistResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRemoveClassCreator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRemoveClassCreator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRemoveClassCreator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRemoveClassCreatorResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRemoveClassCreatorResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRemoveClassCreatorResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateClassFee) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateClassFee: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateClassFee: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fee == nil {
				m.Fee = &types.Coin{}
			}
			if err := m.Fee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateClassFeeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateClassFeeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateClassFeeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateProjectFee) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateProjectFee: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateProjectFee: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fee == nil {
				m.Fee = &types.Coin{}
			}
			if err := m.Fee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateProjectFeeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateProjectFeeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateProjectFeeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAddAllowedBridgeChain) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAddAllowedBridgeChain: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAddAllowedBridgeChain: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAddAllowedBridgeChainResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAddAllowedBridgeChainResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAddAllowedBridgeChainResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRemoveAllowedBridgeChain) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRemoveAllowedBridgeChain: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRemoveAllowedBridgeChain: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRemoveAllowedBridgeChainResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRemoveAllowedBridgeChainResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRemoveAllowedBridgeChainResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBurnRegen) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBurnRegen: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBurnRegen: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Burner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Burner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBurnRegenResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBurnRegenResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBurnRegenResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
