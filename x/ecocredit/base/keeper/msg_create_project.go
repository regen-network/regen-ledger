package keeper

import (
	"context"

	sdk "github.com/cosmos/cosmos-sdk/types"
	sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"

	api "github.com/regen-network/regen-ledger/api/v2/regen/ecocredit/v1"
	"github.com/regen-network/regen-ledger/x/ecocredit/v3/base"
	types "github.com/regen-network/regen-ledger/x/ecocredit/v3/base/types/v1"
)

// CreateProject creates a new project for a specific credit class.
func (k Keeper) CreateProject(ctx context.Context, req *types.MsgCreateProject) (*types.MsgCreateProjectResponse, error) {
	sdkCtx := sdk.UnwrapSDKContext(ctx)
	classInfo, err := k.stateStore.ClassTable().GetById(ctx, req.ClassId)
	if err != nil {
		return nil, sdkerrors.ErrInvalidRequest.Wrapf("could not get class with id %s: %s", req.ClassId, err.Error())
	}

	adminAddress, err := sdk.AccAddressFromBech32(req.Admin)
	if err != nil {
		return nil, err
	}

	// TODO deduct fee

	err = k.assertClassIssuer(ctx, classInfo.Key, adminAddress)
	if err != nil {
		return nil, err
	}

	project, projectID, err := k.createNewProject(ctx)
	if err != nil {
		return nil, err
	}

	// check if non-empty reference id is unique within the scope of the credit class
	err = k.verifyReferenceID(ctx, classInfo.Key, req.ReferenceId)
	if err != nil {
		return nil, err
	}

	project.Admin = adminAddress
	project.Jurisdiction = req.Jurisdiction
	project.Metadata = req.Metadata
	project.ReferenceId = req.ReferenceId

	if err = k.stateStore.ProjectTable().Save(ctx, project); err != nil {
		return nil, err
	}

	// create enrollment
	enrollment := &api.ProjectEnrollment{
		ProjectKey: project.Key,
		ClassKey:   classInfo.Key,
		Status:     api.ProjectEnrollmentStatus_PROJECT_ENROLLMENT_STATUS_ACCEPTED,
	}
	if err = k.stateStore.ProjectEnrollmentTable().Insert(ctx, enrollment); err != nil {
		return nil, err
	}

	if err := sdkCtx.EventManager().EmitTypedEvent(&types.EventCreateProject{
		ProjectId: projectID,
	}); err != nil {
		return nil, err
	}

	return &types.MsgCreateProjectResponse{
		ProjectId: projectID,
	}, nil
}

// createNewProject generates a projectID when no projectID was given for CreateProject.
// The ID is generated by concatenating the classID and a sequence number.
func (k Keeper) createNewProject(ctx context.Context) (*api.Project, string, error) {
	newProject := &api.Project{}
	id, err := k.stateStore.ProjectTable().InsertReturningID(ctx, newProject)
	if err != nil {
		return nil, "", err
	}

	projectID := base.FormatProjectID(id)
	return newProject, projectID, nil
}

// verifyReferenceID prevents multiple projects from having the same reference id within the
// scope of a credit class. We verify this here at the message server level rather than at the
// ORM level because reference id is optional and therefore multiple projects within the scope
// of a credit class can have an empty reference id (see BridgeReceive for more information)
func (k Keeper) verifyReferenceID(ctx context.Context, classKey uint64, referenceID string) error {
	if referenceID == "" {
		// reference id is optional so an empty reference id is valid
		return nil
	}

	key := api.ProjectClassKeyReferenceIdIndexKey{}.WithClassKeyReferenceId(classKey, referenceID)
	it, err := k.stateStore.ProjectTable().List(ctx, key)
	if err != nil {
		return err
	}
	defer it.Close()
	if it.Next() {
		return sdkerrors.ErrInvalidRequest.Wrapf(
			"a project with reference id %s already exists within this credit class", referenceID,
		)
	}

	return nil
}
