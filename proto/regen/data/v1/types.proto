syntax = "proto3";

package regen.data.v1;

option go_package = "github.com/regen-network/regen-ledger/x/data";

// ContentHash specifies a hash-based content identifier for a piece of data.
message ContentHash {
  // Deprecated: use RawV2 instead.
  // Raw specifies "raw" data which does not specify a deterministic, canonical
  // encoding. Users of these hashes MUST maintain a copy of the hashed data
  // which is preserved bit by bit. All other content encodings specify a
  // deterministic, canonical encoding allowing implementations to choose from a
  // variety of alternative formats for transport and encoding while maintaining
  // the guarantee that the canonical hash will not change. The media type for
  // "raw" data is defined by the MediaType enum.
  Raw raw = 1 [deprecated = true];

  // Deprecated: use GraphV2 instead.
  // Graph specifies graph data that conforms to the RDF data model.
  // The canonicalization algorithm used for an RDF graph is specified by
  // GraphCanonicalizationAlgorithm.
  Graph graph = 2 [deprecated = true];

  // raw_v2 specifies "raw" data which does not specify a deterministic, canonical
  // encoding. Users of these hashes MUST maintain a copy of the hashed data
  // which is preserved bit by bit. All other content encodings specify a
  // deterministic, canonical encoding allowing implementations to choose from a
  // variety of alternative formats for transport and encoding while maintaining
  // the guarantee that the canonical hash will not change. The media type for
  // "raw" data is defined by the MediaType enum.
  RawV2 raw_v2 = 3;

  // graph_v2 specifies graph data that conforms to the RDF data model.
  // The canonicalization algorithm used for an RDF graph is specified by
  // GraphCanonicalizationAlgorithm.
  GraphV2 graph_v2 = 4;

  // Raw is the content hash type used for raw data.
  message Raw {
    // hash represents the hash of the data based on the specified
    // digest_algorithm.
    bytes hash = 1;

    // digest_algorithm represents the hash digest algorithm.
    DigestAlgorithm digest_algorithm = 2;

    // media_type represents the media type for raw data.
    RawMediaType media_type = 3;
  }

  // Graph is the content hash type used for RDF graph data.
  message Graph {
    // hash represents the hash of the data based on the specified
    // digest_algorithm.
    bytes hash = 1;

    // digest_algorithm represents the hash digest algorithm.
    DigestAlgorithm digest_algorithm = 2;

    // graph_canonicalization_algorithm represents the RDF graph
    // canonicalization algorithm.
    GraphCanonicalizationAlgorithm canonicalization_algorithm = 3;

    // merkle_tree is the merkle tree type used for the graph hash, if any.
    GraphMerkleTree merkle_tree = 4;
  }

  // RawV2 is the content hash type used for raw data.
  message RawV2 {
    // hash represents the hash of the data based on the specified
    // digest_algorithm.
    bytes hash = 1;

    // digest_algorithm represents the hash digest algorithm.
    uint32 digest_algorithm = 2;

    // file_extension represents the file extension for raw data. It can be
    // up to six characters long, must be all lower-case and should represent
    // the canonical extension for the media type.
    //
    // A list of canonical extensions which should be used is provided here
    // and SHOULD be used by implementations: txt, json, csv, xml, pdf, tiff,
    // jpg, png, svg, webp, avif, gif, apng, mpeg, mp4, webm, ogg, heic, raw.
    //
    // The above list should be updated as new media types come into common usage
    // especially when there are two or more possible extensions (i.e. jpg vs jpeg or tif vs tiff).
    string file_extension = 3;
  }

  // GraphV2 is the content hash type used for RDF graph data.
  message GraphV2 {
    // hash represents the hash of the data based on the specified
    // digest_algorithm.
    bytes hash = 1;

    // digest_algorithm represents the hash digest algorithm and should be a value from the DigestAlgorithm enum.
    uint32 digest_algorithm = 2;

    // graph_canonicalization_algorithm represents the RDF graph
    // canonicalization algorithm and should be a value from the GraphCanonicalizationAlgorithm enum.
    uint32 canonicalization_algorithm = 3;

    // merkle_tree is the merkle tree type used for the graph hash, if any and should be a value from the GraphMerkleTree enum
    // or left unspecified.
    uint32 merkle_tree = 4;
  }
}

// DigestAlgorithm is the hash digest algorithm
enum DigestAlgorithm {
  // unspecified and invalid
  DIGEST_ALGORITHM_UNSPECIFIED = 0;

  // BLAKE2b-256
  DIGEST_ALGORITHM_BLAKE2B_256 = 1;
}

// Deprecated: use RawV2 instead.
// RawMediaType defines MIME media types to be used with a ContentHash.Raw hash.
enum RawMediaType {
  // RAW_MEDIA_TYPE_UNSPECIFIED can be used for raw binary data
  RAW_MEDIA_TYPE_UNSPECIFIED = 0;

  // basic formats

  // plain text
  RAW_MEDIA_TYPE_TEXT_PLAIN = 1;

  // JSON
  RAW_MEDIA_TYPE_JSON = 2;

  // CSV
  RAW_MEDIA_TYPE_CSV = 3;

  // XML
  RAW_MEDIA_TYPE_XML = 4;

  // PDF
  RAW_MEDIA_TYPE_PDF = 5;

  // images

  // TIIF
  RAW_MEDIA_TYPE_TIFF = 16;

  // JPG
  RAW_MEDIA_TYPE_JPG = 17;

  // PNG
  RAW_MEDIA_TYPE_PNG = 18;

  // SVG
  RAW_MEDIA_TYPE_SVG = 19;

  // WEBP
  RAW_MEDIA_TYPE_WEBP = 20;

  // AVIF
  RAW_MEDIA_TYPE_AVIF = 21;

  // GIF
  RAW_MEDIA_TYPE_GIF = 22;

  // APNG
  RAW_MEDIA_TYPE_APNG = 23;

  // audio-visual media containers

  // MPEG
  RAW_MEDIA_TYPE_MPEG = 32;

  // MP4
  RAW_MEDIA_TYPE_MP4 = 33;

  // WEBM
  RAW_MEDIA_TYPE_WEBM = 34;

  // OGG
  RAW_MEDIA_TYPE_OGG = 35;
}

// GraphCanonicalizationAlgorithm is the graph canonicalization algorithm
enum GraphCanonicalizationAlgorithm {
  // unspecified and invalid
  GRAPH_CANONICALIZATION_ALGORITHM_UNSPECIFIED = 0;

  // URDNA2015 graph hashing
  GRAPH_CANONICALIZATION_ALGORITHM_URDNA2015 = 1;
}

// GraphMerkleTree is the graph merkle tree type used for hashing, if any
enum GraphMerkleTree {
  // unspecified and valid
  GRAPH_MERKLE_TREE_NONE_UNSPECIFIED = 0;
}

// ContentHashes contains list of content ContentHash.
message ContentHashes {
  // data is a list of content hashes which the resolver claims to serve.
  repeated ContentHash content_hashes = 1;
}