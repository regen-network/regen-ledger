// Code generated by protoc-gen-go-cosmos-orm. DO NOT EDIT.

package datav1alpha2

import (
	context "context"
	ormlist "github.com/cosmos/cosmos-sdk/orm/model/ormlist"
	ormtable "github.com/cosmos/cosmos-sdk/orm/model/ormtable"
	ormerrors "github.com/cosmos/cosmos-sdk/orm/types/ormerrors"
)

type DataIDStore interface {
	Insert(ctx context.Context, dataID *DataID) error
	Update(ctx context.Context, dataID *DataID) error
	Save(ctx context.Context, dataID *DataID) error
	Delete(ctx context.Context, dataID *DataID) error
	Has(ctx context.Context, id []byte) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, id []byte) (*DataID, error)
	HasByIri(ctx context.Context, iri string) (found bool, err error)
	// GetByIri returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	GetByIri(ctx context.Context, iri string) (*DataID, error)
	List(ctx context.Context, prefixKey DataIDIndexKey, opts ...ormlist.Option) (DataIDIterator, error)
	ListRange(ctx context.Context, from, to DataIDIndexKey, opts ...ormlist.Option) (DataIDIterator, error)
	DeleteBy(ctx context.Context, prefixKey DataIDIndexKey) error
	DeleteRange(ctx context.Context, from, to DataIDIndexKey) error

	doNotImplement()
}

type DataIDIterator struct {
	ormtable.Iterator
}

func (i DataIDIterator) Value() (*DataID, error) {
	var dataID DataID
	err := i.UnmarshalMessage(&dataID)
	return &dataID, err
}

type DataIDIndexKey interface {
	id() uint32
	values() []interface{}
	dataIDIndexKey()
}

// primary key starting index..
type DataIDPrimaryKey = DataIDIdIndexKey

type DataIDIdIndexKey struct {
	vs []interface{}
}

func (x DataIDIdIndexKey) id() uint32            { return 0 }
func (x DataIDIdIndexKey) values() []interface{} { return x.vs }
func (x DataIDIdIndexKey) dataIDIndexKey()       {}

func (this DataIDIdIndexKey) WithId(id []byte) DataIDIdIndexKey {
	this.vs = []interface{}{id}
	return this
}

type DataIDIriIndexKey struct {
	vs []interface{}
}

func (x DataIDIriIndexKey) id() uint32            { return 1 }
func (x DataIDIriIndexKey) values() []interface{} { return x.vs }
func (x DataIDIriIndexKey) dataIDIndexKey()       {}

func (this DataIDIriIndexKey) WithIri(iri string) DataIDIriIndexKey {
	this.vs = []interface{}{iri}
	return this
}

type dataIDStore struct {
	table ormtable.Table
}

func (this dataIDStore) Insert(ctx context.Context, dataID *DataID) error {
	return this.table.Insert(ctx, dataID)
}

func (this dataIDStore) Update(ctx context.Context, dataID *DataID) error {
	return this.table.Update(ctx, dataID)
}

func (this dataIDStore) Save(ctx context.Context, dataID *DataID) error {
	return this.table.Save(ctx, dataID)
}

func (this dataIDStore) Delete(ctx context.Context, dataID *DataID) error {
	return this.table.Delete(ctx, dataID)
}

func (this dataIDStore) Has(ctx context.Context, id []byte) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, id)
}

func (this dataIDStore) Get(ctx context.Context, id []byte) (*DataID, error) {
	var dataID DataID
	found, err := this.table.PrimaryKey().Get(ctx, &dataID, id)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &dataID, nil
}

func (this dataIDStore) HasByIri(ctx context.Context, iri string) (found bool, err error) {
	return this.table.GetIndexByID(1).(ormtable.UniqueIndex).Has(ctx,
		iri,
	)
}

func (this dataIDStore) GetByIri(ctx context.Context, iri string) (*DataID, error) {
	var dataID DataID
	found, err := this.table.GetIndexByID(1).(ormtable.UniqueIndex).Get(ctx, &dataID,
		iri,
	)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &dataID, nil
}

func (this dataIDStore) List(ctx context.Context, prefixKey DataIDIndexKey, opts ...ormlist.Option) (DataIDIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return DataIDIterator{it}, err
}

func (this dataIDStore) ListRange(ctx context.Context, from, to DataIDIndexKey, opts ...ormlist.Option) (DataIDIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return DataIDIterator{it}, err
}

func (this dataIDStore) DeleteBy(ctx context.Context, prefixKey DataIDIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this dataIDStore) DeleteRange(ctx context.Context, from, to DataIDIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this dataIDStore) doNotImplement() {}

var _ DataIDStore = dataIDStore{}

func NewDataIDStore(db ormtable.Schema) (DataIDStore, error) {
	table := db.GetTable(&DataID{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&DataID{}).ProtoReflect().Descriptor().FullName()))
	}
	return dataIDStore{table}, nil
}

type DataAnchorStore interface {
	Insert(ctx context.Context, dataAnchor *DataAnchor) error
	Update(ctx context.Context, dataAnchor *DataAnchor) error
	Save(ctx context.Context, dataAnchor *DataAnchor) error
	Delete(ctx context.Context, dataAnchor *DataAnchor) error
	Has(ctx context.Context, id []byte) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, id []byte) (*DataAnchor, error)
	List(ctx context.Context, prefixKey DataAnchorIndexKey, opts ...ormlist.Option) (DataAnchorIterator, error)
	ListRange(ctx context.Context, from, to DataAnchorIndexKey, opts ...ormlist.Option) (DataAnchorIterator, error)
	DeleteBy(ctx context.Context, prefixKey DataAnchorIndexKey) error
	DeleteRange(ctx context.Context, from, to DataAnchorIndexKey) error

	doNotImplement()
}

type DataAnchorIterator struct {
	ormtable.Iterator
}

func (i DataAnchorIterator) Value() (*DataAnchor, error) {
	var dataAnchor DataAnchor
	err := i.UnmarshalMessage(&dataAnchor)
	return &dataAnchor, err
}

type DataAnchorIndexKey interface {
	id() uint32
	values() []interface{}
	dataAnchorIndexKey()
}

// primary key starting index..
type DataAnchorPrimaryKey = DataAnchorIdIndexKey

type DataAnchorIdIndexKey struct {
	vs []interface{}
}

func (x DataAnchorIdIndexKey) id() uint32            { return 0 }
func (x DataAnchorIdIndexKey) values() []interface{} { return x.vs }
func (x DataAnchorIdIndexKey) dataAnchorIndexKey()   {}

func (this DataAnchorIdIndexKey) WithId(id []byte) DataAnchorIdIndexKey {
	this.vs = []interface{}{id}
	return this
}

type dataAnchorStore struct {
	table ormtable.Table
}

func (this dataAnchorStore) Insert(ctx context.Context, dataAnchor *DataAnchor) error {
	return this.table.Insert(ctx, dataAnchor)
}

func (this dataAnchorStore) Update(ctx context.Context, dataAnchor *DataAnchor) error {
	return this.table.Update(ctx, dataAnchor)
}

func (this dataAnchorStore) Save(ctx context.Context, dataAnchor *DataAnchor) error {
	return this.table.Save(ctx, dataAnchor)
}

func (this dataAnchorStore) Delete(ctx context.Context, dataAnchor *DataAnchor) error {
	return this.table.Delete(ctx, dataAnchor)
}

func (this dataAnchorStore) Has(ctx context.Context, id []byte) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, id)
}

func (this dataAnchorStore) Get(ctx context.Context, id []byte) (*DataAnchor, error) {
	var dataAnchor DataAnchor
	found, err := this.table.PrimaryKey().Get(ctx, &dataAnchor, id)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &dataAnchor, nil
}

func (this dataAnchorStore) List(ctx context.Context, prefixKey DataAnchorIndexKey, opts ...ormlist.Option) (DataAnchorIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return DataAnchorIterator{it}, err
}

func (this dataAnchorStore) ListRange(ctx context.Context, from, to DataAnchorIndexKey, opts ...ormlist.Option) (DataAnchorIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return DataAnchorIterator{it}, err
}

func (this dataAnchorStore) DeleteBy(ctx context.Context, prefixKey DataAnchorIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this dataAnchorStore) DeleteRange(ctx context.Context, from, to DataAnchorIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this dataAnchorStore) doNotImplement() {}

var _ DataAnchorStore = dataAnchorStore{}

func NewDataAnchorStore(db ormtable.Schema) (DataAnchorStore, error) {
	table := db.GetTable(&DataAnchor{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&DataAnchor{}).ProtoReflect().Descriptor().FullName()))
	}
	return dataAnchorStore{table}, nil
}

type DataSignerStore interface {
	Insert(ctx context.Context, dataSigner *DataSigner) error
	Update(ctx context.Context, dataSigner *DataSigner) error
	Save(ctx context.Context, dataSigner *DataSigner) error
	Delete(ctx context.Context, dataSigner *DataSigner) error
	Has(ctx context.Context, id []byte, signer []byte) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, id []byte, signer []byte) (*DataSigner, error)
	List(ctx context.Context, prefixKey DataSignerIndexKey, opts ...ormlist.Option) (DataSignerIterator, error)
	ListRange(ctx context.Context, from, to DataSignerIndexKey, opts ...ormlist.Option) (DataSignerIterator, error)
	DeleteBy(ctx context.Context, prefixKey DataSignerIndexKey) error
	DeleteRange(ctx context.Context, from, to DataSignerIndexKey) error

	doNotImplement()
}

type DataSignerIterator struct {
	ormtable.Iterator
}

func (i DataSignerIterator) Value() (*DataSigner, error) {
	var dataSigner DataSigner
	err := i.UnmarshalMessage(&dataSigner)
	return &dataSigner, err
}

type DataSignerIndexKey interface {
	id() uint32
	values() []interface{}
	dataSignerIndexKey()
}

// primary key starting index..
type DataSignerPrimaryKey = DataSignerIdSignerIndexKey

type DataSignerIdSignerIndexKey struct {
	vs []interface{}
}

func (x DataSignerIdSignerIndexKey) id() uint32            { return 0 }
func (x DataSignerIdSignerIndexKey) values() []interface{} { return x.vs }
func (x DataSignerIdSignerIndexKey) dataSignerIndexKey()   {}

func (this DataSignerIdSignerIndexKey) WithId(id []byte) DataSignerIdSignerIndexKey {
	this.vs = []interface{}{id}
	return this
}

func (this DataSignerIdSignerIndexKey) WithIdSigner(id []byte, signer []byte) DataSignerIdSignerIndexKey {
	this.vs = []interface{}{id, signer}
	return this
}

type dataSignerStore struct {
	table ormtable.Table
}

func (this dataSignerStore) Insert(ctx context.Context, dataSigner *DataSigner) error {
	return this.table.Insert(ctx, dataSigner)
}

func (this dataSignerStore) Update(ctx context.Context, dataSigner *DataSigner) error {
	return this.table.Update(ctx, dataSigner)
}

func (this dataSignerStore) Save(ctx context.Context, dataSigner *DataSigner) error {
	return this.table.Save(ctx, dataSigner)
}

func (this dataSignerStore) Delete(ctx context.Context, dataSigner *DataSigner) error {
	return this.table.Delete(ctx, dataSigner)
}

func (this dataSignerStore) Has(ctx context.Context, id []byte, signer []byte) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, id, signer)
}

func (this dataSignerStore) Get(ctx context.Context, id []byte, signer []byte) (*DataSigner, error) {
	var dataSigner DataSigner
	found, err := this.table.PrimaryKey().Get(ctx, &dataSigner, id, signer)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &dataSigner, nil
}

func (this dataSignerStore) List(ctx context.Context, prefixKey DataSignerIndexKey, opts ...ormlist.Option) (DataSignerIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return DataSignerIterator{it}, err
}

func (this dataSignerStore) ListRange(ctx context.Context, from, to DataSignerIndexKey, opts ...ormlist.Option) (DataSignerIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return DataSignerIterator{it}, err
}

func (this dataSignerStore) DeleteBy(ctx context.Context, prefixKey DataSignerIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this dataSignerStore) DeleteRange(ctx context.Context, from, to DataSignerIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this dataSignerStore) doNotImplement() {}

var _ DataSignerStore = dataSignerStore{}

func NewDataSignerStore(db ormtable.Schema) (DataSignerStore, error) {
	table := db.GetTable(&DataSigner{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&DataSigner{}).ProtoReflect().Descriptor().FullName()))
	}
	return dataSignerStore{table}, nil
}

type ResolverInfoStore interface {
	Insert(ctx context.Context, resolverInfo *ResolverInfo) error
	InsertReturningID(ctx context.Context, resolverInfo *ResolverInfo) (uint64, error)
	Update(ctx context.Context, resolverInfo *ResolverInfo) error
	Save(ctx context.Context, resolverInfo *ResolverInfo) error
	Delete(ctx context.Context, resolverInfo *ResolverInfo) error
	Has(ctx context.Context, id uint64) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, id uint64) (*ResolverInfo, error)
	HasByUrl(ctx context.Context, url string) (found bool, err error)
	// GetByUrl returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	GetByUrl(ctx context.Context, url string) (*ResolverInfo, error)
	List(ctx context.Context, prefixKey ResolverInfoIndexKey, opts ...ormlist.Option) (ResolverInfoIterator, error)
	ListRange(ctx context.Context, from, to ResolverInfoIndexKey, opts ...ormlist.Option) (ResolverInfoIterator, error)
	DeleteBy(ctx context.Context, prefixKey ResolverInfoIndexKey) error
	DeleteRange(ctx context.Context, from, to ResolverInfoIndexKey) error

	doNotImplement()
}

type ResolverInfoIterator struct {
	ormtable.Iterator
}

func (i ResolverInfoIterator) Value() (*ResolverInfo, error) {
	var resolverInfo ResolverInfo
	err := i.UnmarshalMessage(&resolverInfo)
	return &resolverInfo, err
}

type ResolverInfoIndexKey interface {
	id() uint32
	values() []interface{}
	resolverInfoIndexKey()
}

// primary key starting index..
type ResolverInfoPrimaryKey = ResolverInfoIdIndexKey

type ResolverInfoIdIndexKey struct {
	vs []interface{}
}

func (x ResolverInfoIdIndexKey) id() uint32            { return 0 }
func (x ResolverInfoIdIndexKey) values() []interface{} { return x.vs }
func (x ResolverInfoIdIndexKey) resolverInfoIndexKey() {}

func (this ResolverInfoIdIndexKey) WithId(id uint64) ResolverInfoIdIndexKey {
	this.vs = []interface{}{id}
	return this
}

type ResolverInfoUrlIndexKey struct {
	vs []interface{}
}

func (x ResolverInfoUrlIndexKey) id() uint32            { return 1 }
func (x ResolverInfoUrlIndexKey) values() []interface{} { return x.vs }
func (x ResolverInfoUrlIndexKey) resolverInfoIndexKey() {}

func (this ResolverInfoUrlIndexKey) WithUrl(url string) ResolverInfoUrlIndexKey {
	this.vs = []interface{}{url}
	return this
}

type ResolverInfoManagerIndexKey struct {
	vs []interface{}
}

func (x ResolverInfoManagerIndexKey) id() uint32            { return 2 }
func (x ResolverInfoManagerIndexKey) values() []interface{} { return x.vs }
func (x ResolverInfoManagerIndexKey) resolverInfoIndexKey() {}

func (this ResolverInfoManagerIndexKey) WithManager(manager []byte) ResolverInfoManagerIndexKey {
	this.vs = []interface{}{manager}
	return this
}

type resolverInfoStore struct {
	table ormtable.AutoIncrementTable
}

func (this resolverInfoStore) Insert(ctx context.Context, resolverInfo *ResolverInfo) error {
	return this.table.Insert(ctx, resolverInfo)
}

func (this resolverInfoStore) Update(ctx context.Context, resolverInfo *ResolverInfo) error {
	return this.table.Update(ctx, resolverInfo)
}

func (this resolverInfoStore) Save(ctx context.Context, resolverInfo *ResolverInfo) error {
	return this.table.Save(ctx, resolverInfo)
}

func (this resolverInfoStore) Delete(ctx context.Context, resolverInfo *ResolverInfo) error {
	return this.table.Delete(ctx, resolverInfo)
}

func (this resolverInfoStore) InsertReturningID(ctx context.Context, resolverInfo *ResolverInfo) (uint64, error) {
	return this.table.InsertReturningID(ctx, resolverInfo)
}

func (this resolverInfoStore) Has(ctx context.Context, id uint64) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, id)
}

func (this resolverInfoStore) Get(ctx context.Context, id uint64) (*ResolverInfo, error) {
	var resolverInfo ResolverInfo
	found, err := this.table.PrimaryKey().Get(ctx, &resolverInfo, id)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &resolverInfo, nil
}

func (this resolverInfoStore) HasByUrl(ctx context.Context, url string) (found bool, err error) {
	return this.table.GetIndexByID(1).(ormtable.UniqueIndex).Has(ctx,
		url,
	)
}

func (this resolverInfoStore) GetByUrl(ctx context.Context, url string) (*ResolverInfo, error) {
	var resolverInfo ResolverInfo
	found, err := this.table.GetIndexByID(1).(ormtable.UniqueIndex).Get(ctx, &resolverInfo,
		url,
	)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &resolverInfo, nil
}

func (this resolverInfoStore) List(ctx context.Context, prefixKey ResolverInfoIndexKey, opts ...ormlist.Option) (ResolverInfoIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return ResolverInfoIterator{it}, err
}

func (this resolverInfoStore) ListRange(ctx context.Context, from, to ResolverInfoIndexKey, opts ...ormlist.Option) (ResolverInfoIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return ResolverInfoIterator{it}, err
}

func (this resolverInfoStore) DeleteBy(ctx context.Context, prefixKey ResolverInfoIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this resolverInfoStore) DeleteRange(ctx context.Context, from, to ResolverInfoIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this resolverInfoStore) doNotImplement() {}

var _ ResolverInfoStore = resolverInfoStore{}

func NewResolverInfoStore(db ormtable.Schema) (ResolverInfoStore, error) {
	table := db.GetTable(&ResolverInfo{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&ResolverInfo{}).ProtoReflect().Descriptor().FullName()))
	}
	return resolverInfoStore{table.(ormtable.AutoIncrementTable)}, nil
}

type DataResolverStore interface {
	Insert(ctx context.Context, dataResolver *DataResolver) error
	Update(ctx context.Context, dataResolver *DataResolver) error
	Save(ctx context.Context, dataResolver *DataResolver) error
	Delete(ctx context.Context, dataResolver *DataResolver) error
	Has(ctx context.Context, id []byte, resolver_id uint64) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, id []byte, resolver_id uint64) (*DataResolver, error)
	List(ctx context.Context, prefixKey DataResolverIndexKey, opts ...ormlist.Option) (DataResolverIterator, error)
	ListRange(ctx context.Context, from, to DataResolverIndexKey, opts ...ormlist.Option) (DataResolverIterator, error)
	DeleteBy(ctx context.Context, prefixKey DataResolverIndexKey) error
	DeleteRange(ctx context.Context, from, to DataResolverIndexKey) error

	doNotImplement()
}

type DataResolverIterator struct {
	ormtable.Iterator
}

func (i DataResolverIterator) Value() (*DataResolver, error) {
	var dataResolver DataResolver
	err := i.UnmarshalMessage(&dataResolver)
	return &dataResolver, err
}

type DataResolverIndexKey interface {
	id() uint32
	values() []interface{}
	dataResolverIndexKey()
}

// primary key starting index..
type DataResolverPrimaryKey = DataResolverIdResolverIdIndexKey

type DataResolverIdResolverIdIndexKey struct {
	vs []interface{}
}

func (x DataResolverIdResolverIdIndexKey) id() uint32            { return 0 }
func (x DataResolverIdResolverIdIndexKey) values() []interface{} { return x.vs }
func (x DataResolverIdResolverIdIndexKey) dataResolverIndexKey() {}

func (this DataResolverIdResolverIdIndexKey) WithId(id []byte) DataResolverIdResolverIdIndexKey {
	this.vs = []interface{}{id}
	return this
}

func (this DataResolverIdResolverIdIndexKey) WithIdResolverId(id []byte, resolver_id uint64) DataResolverIdResolverIdIndexKey {
	this.vs = []interface{}{id, resolver_id}
	return this
}

type dataResolverStore struct {
	table ormtable.Table
}

func (this dataResolverStore) Insert(ctx context.Context, dataResolver *DataResolver) error {
	return this.table.Insert(ctx, dataResolver)
}

func (this dataResolverStore) Update(ctx context.Context, dataResolver *DataResolver) error {
	return this.table.Update(ctx, dataResolver)
}

func (this dataResolverStore) Save(ctx context.Context, dataResolver *DataResolver) error {
	return this.table.Save(ctx, dataResolver)
}

func (this dataResolverStore) Delete(ctx context.Context, dataResolver *DataResolver) error {
	return this.table.Delete(ctx, dataResolver)
}

func (this dataResolverStore) Has(ctx context.Context, id []byte, resolver_id uint64) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, id, resolver_id)
}

func (this dataResolverStore) Get(ctx context.Context, id []byte, resolver_id uint64) (*DataResolver, error) {
	var dataResolver DataResolver
	found, err := this.table.PrimaryKey().Get(ctx, &dataResolver, id, resolver_id)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &dataResolver, nil
}

func (this dataResolverStore) List(ctx context.Context, prefixKey DataResolverIndexKey, opts ...ormlist.Option) (DataResolverIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return DataResolverIterator{it}, err
}

func (this dataResolverStore) ListRange(ctx context.Context, from, to DataResolverIndexKey, opts ...ormlist.Option) (DataResolverIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return DataResolverIterator{it}, err
}

func (this dataResolverStore) DeleteBy(ctx context.Context, prefixKey DataResolverIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this dataResolverStore) DeleteRange(ctx context.Context, from, to DataResolverIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this dataResolverStore) doNotImplement() {}

var _ DataResolverStore = dataResolverStore{}

func NewDataResolverStore(db ormtable.Schema) (DataResolverStore, error) {
	table := db.GetTable(&DataResolver{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&DataResolver{}).ProtoReflect().Descriptor().FullName()))
	}
	return dataResolverStore{table}, nil
}

type StateStore interface {
	DataIDStore() DataIDStore
	DataAnchorStore() DataAnchorStore
	DataSignerStore() DataSignerStore
	ResolverInfoStore() ResolverInfoStore
	DataResolverStore() DataResolverStore

	doNotImplement()
}

type stateStore struct {
	dataID       DataIDStore
	dataAnchor   DataAnchorStore
	dataSigner   DataSignerStore
	resolverInfo ResolverInfoStore
	dataResolver DataResolverStore
}

func (x stateStore) DataIDStore() DataIDStore {
	return x.dataID
}

func (x stateStore) DataAnchorStore() DataAnchorStore {
	return x.dataAnchor
}

func (x stateStore) DataSignerStore() DataSignerStore {
	return x.dataSigner
}

func (x stateStore) ResolverInfoStore() ResolverInfoStore {
	return x.resolverInfo
}

func (x stateStore) DataResolverStore() DataResolverStore {
	return x.dataResolver
}

func (stateStore) doNotImplement() {}

var _ StateStore = stateStore{}

func NewStateStore(db ormtable.Schema) (StateStore, error) {
	dataIDStore, err := NewDataIDStore(db)
	if err != nil {
		return nil, err
	}

	dataAnchorStore, err := NewDataAnchorStore(db)
	if err != nil {
		return nil, err
	}

	dataSignerStore, err := NewDataSignerStore(db)
	if err != nil {
		return nil, err
	}

	resolverInfoStore, err := NewResolverInfoStore(db)
	if err != nil {
		return nil, err
	}

	dataResolverStore, err := NewDataResolverStore(db)
	if err != nil {
		return nil, err
	}

	return stateStore{
		dataIDStore,
		dataAnchorStore,
		dataSignerStore,
		resolverInfoStore,
		dataResolverStore,
	}, nil
}
