// Code generated by protoc-gen-go-cosmos-orm. DO NOT EDIT.

package datav1alpha2

import (
	context "context"
	ormdb "github.com/cosmos/cosmos-sdk/orm/model/ormdb"
	ormlist "github.com/cosmos/cosmos-sdk/orm/model/ormlist"
	ormtable "github.com/cosmos/cosmos-sdk/orm/model/ormtable"
	ormerrors "github.com/cosmos/cosmos-sdk/orm/types/ormerrors"
)

type DataIDStore interface {
	Insert(ctx context.Context, dataID *DataID) error
	Update(ctx context.Context, dataID *DataID) error
	Save(ctx context.Context, dataID *DataID) error
	Delete(ctx context.Context, dataID *DataID) error
	Has(ctx context.Context, id []byte) (found bool, err error)
	Get(ctx context.Context, id []byte) (*DataID, error)
	HasByIri(ctx context.Context, iri string) (found bool, err error)
	GetByIri(ctx context.Context, iri string) (*DataID, error)
	List(ctx context.Context, prefixKey DataIDIndexKey, opts ...ormlist.Option) (DataIDIterator, error)
	ListRange(ctx context.Context, from, to DataIDIndexKey, opts ...ormlist.Option) (DataIDIterator, error)

	doNotImplement()
}

type DataIDIterator struct {
	ormtable.Iterator
}

func (i DataIDIterator) Value() (*DataID, error) {
	var dataID DataID
	err := i.UnmarshalMessage(&dataID)
	return &dataID, err
}

type DataIDIndexKey interface {
	id() uint32
	values() []interface{}
	dataIDIndexKey()
}

// primary key starting index..
type DataIDPrimaryKey = DataIDIdIndexKey

type DataIDIdIndexKey struct {
	vs []interface{}
}

func (x DataIDIdIndexKey) id() uint32            { return 0 }
func (x DataIDIdIndexKey) values() []interface{} { return x.vs }
func (x DataIDIdIndexKey) dataIDIndexKey()       {}

func (this DataIDIdIndexKey) WithId(id []byte) DataIDIdIndexKey {
	this.vs = []interface{}{id}
	return this
}

type DataIDIriIndexKey struct {
	vs []interface{}
}

func (x DataIDIriIndexKey) id() uint32            { return 1 }
func (x DataIDIriIndexKey) values() []interface{} { return x.vs }
func (x DataIDIriIndexKey) dataIDIndexKey()       {}

func (this DataIDIriIndexKey) WithIri(iri string) DataIDIriIndexKey {
	this.vs = []interface{}{iri}
	return this
}

type dataIDStore struct {
	table ormtable.Table
}

func (this dataIDStore) Insert(ctx context.Context, dataID *DataID) error {
	return this.table.Insert(ctx, dataID)
}

func (this dataIDStore) Update(ctx context.Context, dataID *DataID) error {
	return this.table.Update(ctx, dataID)
}

func (this dataIDStore) Save(ctx context.Context, dataID *DataID) error {
	return this.table.Save(ctx, dataID)
}

func (this dataIDStore) Delete(ctx context.Context, dataID *DataID) error {
	return this.table.Delete(ctx, dataID)
}

func (this dataIDStore) Has(ctx context.Context, id []byte) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, id)
}

func (this dataIDStore) Get(ctx context.Context, id []byte) (*DataID, error) {
	var dataID DataID
	found, err := this.table.PrimaryKey().Get(ctx, &dataID, id)
	if !found {
		return nil, err
	}
	return &dataID, err
}

func (this dataIDStore) HasByIri(ctx context.Context, iri string) (found bool, err error) {
	return this.table.GetIndexByID(1).(ormtable.UniqueIndex).Has(ctx,
		iri,
	)
}

func (this dataIDStore) GetByIri(ctx context.Context, iri string) (*DataID, error) {
	var dataID DataID
	found, err := this.table.GetIndexByID(1).(ormtable.UniqueIndex).Get(ctx, &dataID,
		iri,
	)
	if !found {
		return nil, err
	}
	return &dataID, nil
}

func (this dataIDStore) List(ctx context.Context, prefixKey DataIDIndexKey, opts ...ormlist.Option) (DataIDIterator, error) {
	opts = append(opts, ormlist.Prefix(prefixKey.values()...))
	it, err := this.table.GetIndexByID(prefixKey.id()).Iterator(ctx, opts...)
	return DataIDIterator{it}, err
}

func (this dataIDStore) ListRange(ctx context.Context, from, to DataIDIndexKey, opts ...ormlist.Option) (DataIDIterator, error) {
	opts = append(opts, ormlist.Start(from.values()...), ormlist.End(to.values()...))
	it, err := this.table.GetIndexByID(from.id()).Iterator(ctx, opts...)
	return DataIDIterator{it}, err
}

func (this dataIDStore) doNotImplement() {}

var _ DataIDStore = dataIDStore{}

func NewDataIDStore(db ormdb.ModuleDB) (DataIDStore, error) {
	table := db.GetTable(&DataID{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&DataID{}).ProtoReflect().Descriptor().FullName()))
	}
	return dataIDStore{table}, nil
}

type DataAnchorStore interface {
	Insert(ctx context.Context, dataAnchor *DataAnchor) error
	Update(ctx context.Context, dataAnchor *DataAnchor) error
	Save(ctx context.Context, dataAnchor *DataAnchor) error
	Delete(ctx context.Context, dataAnchor *DataAnchor) error
	Has(ctx context.Context, id []byte) (found bool, err error)
	Get(ctx context.Context, id []byte) (*DataAnchor, error)
	List(ctx context.Context, prefixKey DataAnchorIndexKey, opts ...ormlist.Option) (DataAnchorIterator, error)
	ListRange(ctx context.Context, from, to DataAnchorIndexKey, opts ...ormlist.Option) (DataAnchorIterator, error)

	doNotImplement()
}

type DataAnchorIterator struct {
	ormtable.Iterator
}

func (i DataAnchorIterator) Value() (*DataAnchor, error) {
	var dataAnchor DataAnchor
	err := i.UnmarshalMessage(&dataAnchor)
	return &dataAnchor, err
}

type DataAnchorIndexKey interface {
	id() uint32
	values() []interface{}
	dataAnchorIndexKey()
}

// primary key starting index..
type DataAnchorPrimaryKey = DataAnchorIdIndexKey

type DataAnchorIdIndexKey struct {
	vs []interface{}
}

func (x DataAnchorIdIndexKey) id() uint32            { return 0 }
func (x DataAnchorIdIndexKey) values() []interface{} { return x.vs }
func (x DataAnchorIdIndexKey) dataAnchorIndexKey()   {}

func (this DataAnchorIdIndexKey) WithId(id []byte) DataAnchorIdIndexKey {
	this.vs = []interface{}{id}
	return this
}

type dataAnchorStore struct {
	table ormtable.Table
}

func (this dataAnchorStore) Insert(ctx context.Context, dataAnchor *DataAnchor) error {
	return this.table.Insert(ctx, dataAnchor)
}

func (this dataAnchorStore) Update(ctx context.Context, dataAnchor *DataAnchor) error {
	return this.table.Update(ctx, dataAnchor)
}

func (this dataAnchorStore) Save(ctx context.Context, dataAnchor *DataAnchor) error {
	return this.table.Save(ctx, dataAnchor)
}

func (this dataAnchorStore) Delete(ctx context.Context, dataAnchor *DataAnchor) error {
	return this.table.Delete(ctx, dataAnchor)
}

func (this dataAnchorStore) Has(ctx context.Context, id []byte) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, id)
}

func (this dataAnchorStore) Get(ctx context.Context, id []byte) (*DataAnchor, error) {
	var dataAnchor DataAnchor
	found, err := this.table.PrimaryKey().Get(ctx, &dataAnchor, id)
	if !found {
		return nil, err
	}
	return &dataAnchor, err
}

func (this dataAnchorStore) List(ctx context.Context, prefixKey DataAnchorIndexKey, opts ...ormlist.Option) (DataAnchorIterator, error) {
	opts = append(opts, ormlist.Prefix(prefixKey.values()...))
	it, err := this.table.GetIndexByID(prefixKey.id()).Iterator(ctx, opts...)
	return DataAnchorIterator{it}, err
}

func (this dataAnchorStore) ListRange(ctx context.Context, from, to DataAnchorIndexKey, opts ...ormlist.Option) (DataAnchorIterator, error) {
	opts = append(opts, ormlist.Start(from.values()...), ormlist.End(to.values()...))
	it, err := this.table.GetIndexByID(from.id()).Iterator(ctx, opts...)
	return DataAnchorIterator{it}, err
}

func (this dataAnchorStore) doNotImplement() {}

var _ DataAnchorStore = dataAnchorStore{}

func NewDataAnchorStore(db ormdb.ModuleDB) (DataAnchorStore, error) {
	table := db.GetTable(&DataAnchor{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&DataAnchor{}).ProtoReflect().Descriptor().FullName()))
	}
	return dataAnchorStore{table}, nil
}

type DataSignerStore interface {
	Insert(ctx context.Context, dataSigner *DataSigner) error
	Update(ctx context.Context, dataSigner *DataSigner) error
	Save(ctx context.Context, dataSigner *DataSigner) error
	Delete(ctx context.Context, dataSigner *DataSigner) error
	Has(ctx context.Context, id []byte) (found bool, err error)
	Get(ctx context.Context, id []byte) (*DataSigner, error)
	List(ctx context.Context, prefixKey DataSignerIndexKey, opts ...ormlist.Option) (DataSignerIterator, error)
	ListRange(ctx context.Context, from, to DataSignerIndexKey, opts ...ormlist.Option) (DataSignerIterator, error)

	doNotImplement()
}

type DataSignerIterator struct {
	ormtable.Iterator
}

func (i DataSignerIterator) Value() (*DataSigner, error) {
	var dataSigner DataSigner
	err := i.UnmarshalMessage(&dataSigner)
	return &dataSigner, err
}

type DataSignerIndexKey interface {
	id() uint32
	values() []interface{}
	dataSignerIndexKey()
}

// primary key starting index..
type DataSignerPrimaryKey = DataSignerIdIndexKey

type DataSignerIdIndexKey struct {
	vs []interface{}
}

func (x DataSignerIdIndexKey) id() uint32            { return 0 }
func (x DataSignerIdIndexKey) values() []interface{} { return x.vs }
func (x DataSignerIdIndexKey) dataSignerIndexKey()   {}

func (this DataSignerIdIndexKey) WithId(id []byte) DataSignerIdIndexKey {
	this.vs = []interface{}{id}
	return this
}

type dataSignerStore struct {
	table ormtable.Table
}

func (this dataSignerStore) Insert(ctx context.Context, dataSigner *DataSigner) error {
	return this.table.Insert(ctx, dataSigner)
}

func (this dataSignerStore) Update(ctx context.Context, dataSigner *DataSigner) error {
	return this.table.Update(ctx, dataSigner)
}

func (this dataSignerStore) Save(ctx context.Context, dataSigner *DataSigner) error {
	return this.table.Save(ctx, dataSigner)
}

func (this dataSignerStore) Delete(ctx context.Context, dataSigner *DataSigner) error {
	return this.table.Delete(ctx, dataSigner)
}

func (this dataSignerStore) Has(ctx context.Context, id []byte) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, id)
}

func (this dataSignerStore) Get(ctx context.Context, id []byte) (*DataSigner, error) {
	var dataSigner DataSigner
	found, err := this.table.PrimaryKey().Get(ctx, &dataSigner, id)
	if !found {
		return nil, err
	}
	return &dataSigner, err
}

func (this dataSignerStore) List(ctx context.Context, prefixKey DataSignerIndexKey, opts ...ormlist.Option) (DataSignerIterator, error) {
	opts = append(opts, ormlist.Prefix(prefixKey.values()...))
	it, err := this.table.GetIndexByID(prefixKey.id()).Iterator(ctx, opts...)
	return DataSignerIterator{it}, err
}

func (this dataSignerStore) ListRange(ctx context.Context, from, to DataSignerIndexKey, opts ...ormlist.Option) (DataSignerIterator, error) {
	opts = append(opts, ormlist.Start(from.values()...), ormlist.End(to.values()...))
	it, err := this.table.GetIndexByID(from.id()).Iterator(ctx, opts...)
	return DataSignerIterator{it}, err
}

func (this dataSignerStore) doNotImplement() {}

var _ DataSignerStore = dataSignerStore{}

func NewDataSignerStore(db ormdb.ModuleDB) (DataSignerStore, error) {
	table := db.GetTable(&DataSigner{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&DataSigner{}).ProtoReflect().Descriptor().FullName()))
	}
	return dataSignerStore{table}, nil
}

type ResolverURLStore interface {
	Insert(ctx context.Context, resolverURL *ResolverURL) error
	Update(ctx context.Context, resolverURL *ResolverURL) error
	Save(ctx context.Context, resolverURL *ResolverURL) error
	Delete(ctx context.Context, resolverURL *ResolverURL) error
	Has(ctx context.Context, id uint64) (found bool, err error)
	Get(ctx context.Context, id uint64) (*ResolverURL, error)
	HasByUrl(ctx context.Context, url string) (found bool, err error)
	GetByUrl(ctx context.Context, url string) (*ResolverURL, error)
	List(ctx context.Context, prefixKey ResolverURLIndexKey, opts ...ormlist.Option) (ResolverURLIterator, error)
	ListRange(ctx context.Context, from, to ResolverURLIndexKey, opts ...ormlist.Option) (ResolverURLIterator, error)

	doNotImplement()
}

type ResolverURLIterator struct {
	ormtable.Iterator
}

func (i ResolverURLIterator) Value() (*ResolverURL, error) {
	var resolverURL ResolverURL
	err := i.UnmarshalMessage(&resolverURL)
	return &resolverURL, err
}

type ResolverURLIndexKey interface {
	id() uint32
	values() []interface{}
	resolverURLIndexKey()
}

// primary key starting index..
type ResolverURLPrimaryKey = ResolverURLIdIndexKey

type ResolverURLIdIndexKey struct {
	vs []interface{}
}

func (x ResolverURLIdIndexKey) id() uint32            { return 0 }
func (x ResolverURLIdIndexKey) values() []interface{} { return x.vs }
func (x ResolverURLIdIndexKey) resolverURLIndexKey()  {}

func (this ResolverURLIdIndexKey) WithId(id uint64) ResolverURLIdIndexKey {
	this.vs = []interface{}{id}
	return this
}

type ResolverURLUrlIndexKey struct {
	vs []interface{}
}

func (x ResolverURLUrlIndexKey) id() uint32            { return 1 }
func (x ResolverURLUrlIndexKey) values() []interface{} { return x.vs }
func (x ResolverURLUrlIndexKey) resolverURLIndexKey()  {}

func (this ResolverURLUrlIndexKey) WithUrl(url string) ResolverURLUrlIndexKey {
	this.vs = []interface{}{url}
	return this
}

type resolverURLStore struct {
	table ormtable.Table
}

func (this resolverURLStore) Insert(ctx context.Context, resolverURL *ResolverURL) error {
	return this.table.Insert(ctx, resolverURL)
}

func (this resolverURLStore) Update(ctx context.Context, resolverURL *ResolverURL) error {
	return this.table.Update(ctx, resolverURL)
}

func (this resolverURLStore) Save(ctx context.Context, resolverURL *ResolverURL) error {
	return this.table.Save(ctx, resolverURL)
}

func (this resolverURLStore) Delete(ctx context.Context, resolverURL *ResolverURL) error {
	return this.table.Delete(ctx, resolverURL)
}

func (this resolverURLStore) Has(ctx context.Context, id uint64) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, id)
}

func (this resolverURLStore) Get(ctx context.Context, id uint64) (*ResolverURL, error) {
	var resolverURL ResolverURL
	found, err := this.table.PrimaryKey().Get(ctx, &resolverURL, id)
	if !found {
		return nil, err
	}
	return &resolverURL, err
}

func (this resolverURLStore) HasByUrl(ctx context.Context, url string) (found bool, err error) {
	return this.table.GetIndexByID(1).(ormtable.UniqueIndex).Has(ctx,
		url,
	)
}

func (this resolverURLStore) GetByUrl(ctx context.Context, url string) (*ResolverURL, error) {
	var resolverURL ResolverURL
	found, err := this.table.GetIndexByID(1).(ormtable.UniqueIndex).Get(ctx, &resolverURL,
		url,
	)
	if !found {
		return nil, err
	}
	return &resolverURL, nil
}

func (this resolverURLStore) List(ctx context.Context, prefixKey ResolverURLIndexKey, opts ...ormlist.Option) (ResolverURLIterator, error) {
	opts = append(opts, ormlist.Prefix(prefixKey.values()...))
	it, err := this.table.GetIndexByID(prefixKey.id()).Iterator(ctx, opts...)
	return ResolverURLIterator{it}, err
}

func (this resolverURLStore) ListRange(ctx context.Context, from, to ResolverURLIndexKey, opts ...ormlist.Option) (ResolverURLIterator, error) {
	opts = append(opts, ormlist.Start(from.values()...), ormlist.End(to.values()...))
	it, err := this.table.GetIndexByID(from.id()).Iterator(ctx, opts...)
	return ResolverURLIterator{it}, err
}

func (this resolverURLStore) doNotImplement() {}

var _ ResolverURLStore = resolverURLStore{}

func NewResolverURLStore(db ormdb.ModuleDB) (ResolverURLStore, error) {
	table := db.GetTable(&ResolverURL{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&ResolverURL{}).ProtoReflect().Descriptor().FullName()))
	}
	return resolverURLStore{table}, nil
}

type DataResolverStore interface {
	Insert(ctx context.Context, dataResolver *DataResolver) error
	Update(ctx context.Context, dataResolver *DataResolver) error
	Save(ctx context.Context, dataResolver *DataResolver) error
	Delete(ctx context.Context, dataResolver *DataResolver) error
	Has(ctx context.Context, data_id []byte, resolver_id uint64) (found bool, err error)
	Get(ctx context.Context, data_id []byte, resolver_id uint64) (*DataResolver, error)
	List(ctx context.Context, prefixKey DataResolverIndexKey, opts ...ormlist.Option) (DataResolverIterator, error)
	ListRange(ctx context.Context, from, to DataResolverIndexKey, opts ...ormlist.Option) (DataResolverIterator, error)

	doNotImplement()
}

type DataResolverIterator struct {
	ormtable.Iterator
}

func (i DataResolverIterator) Value() (*DataResolver, error) {
	var dataResolver DataResolver
	err := i.UnmarshalMessage(&dataResolver)
	return &dataResolver, err
}

type DataResolverIndexKey interface {
	id() uint32
	values() []interface{}
	dataResolverIndexKey()
}

// primary key starting index..
type DataResolverPrimaryKey = DataResolverDataIdResolverIdIndexKey

type DataResolverDataIdResolverIdIndexKey struct {
	vs []interface{}
}

func (x DataResolverDataIdResolverIdIndexKey) id() uint32            { return 0 }
func (x DataResolverDataIdResolverIdIndexKey) values() []interface{} { return x.vs }
func (x DataResolverDataIdResolverIdIndexKey) dataResolverIndexKey() {}

func (this DataResolverDataIdResolverIdIndexKey) WithDataId(data_id []byte) DataResolverDataIdResolverIdIndexKey {
	this.vs = []interface{}{data_id}
	return this
}

func (this DataResolverDataIdResolverIdIndexKey) WithDataIdResolverId(data_id []byte, resolver_id uint64) DataResolverDataIdResolverIdIndexKey {
	this.vs = []interface{}{data_id, resolver_id}
	return this
}

type dataResolverStore struct {
	table ormtable.Table
}

func (this dataResolverStore) Insert(ctx context.Context, dataResolver *DataResolver) error {
	return this.table.Insert(ctx, dataResolver)
}

func (this dataResolverStore) Update(ctx context.Context, dataResolver *DataResolver) error {
	return this.table.Update(ctx, dataResolver)
}

func (this dataResolverStore) Save(ctx context.Context, dataResolver *DataResolver) error {
	return this.table.Save(ctx, dataResolver)
}

func (this dataResolverStore) Delete(ctx context.Context, dataResolver *DataResolver) error {
	return this.table.Delete(ctx, dataResolver)
}

func (this dataResolverStore) Has(ctx context.Context, data_id []byte, resolver_id uint64) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, data_id, resolver_id)
}

func (this dataResolverStore) Get(ctx context.Context, data_id []byte, resolver_id uint64) (*DataResolver, error) {
	var dataResolver DataResolver
	found, err := this.table.PrimaryKey().Get(ctx, &dataResolver, data_id, resolver_id)
	if !found {
		return nil, err
	}
	return &dataResolver, err
}

func (this dataResolverStore) List(ctx context.Context, prefixKey DataResolverIndexKey, opts ...ormlist.Option) (DataResolverIterator, error) {
	opts = append(opts, ormlist.Prefix(prefixKey.values()...))
	it, err := this.table.GetIndexByID(prefixKey.id()).Iterator(ctx, opts...)
	return DataResolverIterator{it}, err
}

func (this dataResolverStore) ListRange(ctx context.Context, from, to DataResolverIndexKey, opts ...ormlist.Option) (DataResolverIterator, error) {
	opts = append(opts, ormlist.Start(from.values()...), ormlist.End(to.values()...))
	it, err := this.table.GetIndexByID(from.id()).Iterator(ctx, opts...)
	return DataResolverIterator{it}, err
}

func (this dataResolverStore) doNotImplement() {}

var _ DataResolverStore = dataResolverStore{}

func NewDataResolverStore(db ormdb.ModuleDB) (DataResolverStore, error) {
	table := db.GetTable(&DataResolver{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&DataResolver{}).ProtoReflect().Descriptor().FullName()))
	}
	return dataResolverStore{table}, nil
}

type StateStore interface {
	DataIDStore() DataIDStore
	DataAnchorStore() DataAnchorStore
	DataSignerStore() DataSignerStore
	ResolverURLStore() ResolverURLStore
	DataResolverStore() DataResolverStore

	doNotImplement()
}

type stateStore struct {
	dataID       DataIDStore
	dataAnchor   DataAnchorStore
	dataSigner   DataSignerStore
	resolverURL  ResolverURLStore
	dataResolver DataResolverStore
}

func (x stateStore) DataIDStore() DataIDStore {
	return x.dataID
}

func (x stateStore) DataAnchorStore() DataAnchorStore {
	return x.dataAnchor
}

func (x stateStore) DataSignerStore() DataSignerStore {
	return x.dataSigner
}

func (x stateStore) ResolverURLStore() ResolverURLStore {
	return x.resolverURL
}

func (x stateStore) DataResolverStore() DataResolverStore {
	return x.dataResolver
}

func (stateStore) doNotImplement() {}

var _ StateStore = stateStore{}

func NewStateStore(db ormdb.ModuleDB) (StateStore, error) {
	dataIDStore, err := NewDataIDStore(db)
	if err != nil {
		return nil, err
	}

	dataAnchorStore, err := NewDataAnchorStore(db)
	if err != nil {
		return nil, err
	}

	dataSignerStore, err := NewDataSignerStore(db)
	if err != nil {
		return nil, err
	}

	resolverURLStore, err := NewResolverURLStore(db)
	if err != nil {
		return nil, err
	}

	dataResolverStore, err := NewDataResolverStore(db)
	if err != nil {
		return nil, err
	}

	return stateStore{
		dataIDStore,
		dataAnchorStore,
		dataSignerStore,
		resolverURLStore,
		dataResolverStore,
	}, nil
}
