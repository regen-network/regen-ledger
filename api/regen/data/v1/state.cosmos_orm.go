// Code generated by protoc-gen-go-cosmos-orm. DO NOT EDIT.

package datav1

import (
	context "context"
	ormlist "github.com/cosmos/cosmos-sdk/orm/model/ormlist"
	ormtable "github.com/cosmos/cosmos-sdk/orm/model/ormtable"
	ormerrors "github.com/cosmos/cosmos-sdk/orm/types/ormerrors"
)

type DataIDTable interface {
	Insert(ctx context.Context, dataID *DataID) error
	Update(ctx context.Context, dataID *DataID) error
	Save(ctx context.Context, dataID *DataID) error
	Delete(ctx context.Context, dataID *DataID) error
	Has(ctx context.Context, id []byte) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, id []byte) (*DataID, error)
	HasByIri(ctx context.Context, iri string) (found bool, err error)
	// GetByIri returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	GetByIri(ctx context.Context, iri string) (*DataID, error)
	List(ctx context.Context, prefixKey DataIDIndexKey, opts ...ormlist.Option) (DataIDIterator, error)
	ListRange(ctx context.Context, from, to DataIDIndexKey, opts ...ormlist.Option) (DataIDIterator, error)
	DeleteBy(ctx context.Context, prefixKey DataIDIndexKey) error
	DeleteRange(ctx context.Context, from, to DataIDIndexKey) error

	doNotImplement()
}

type DataIDIterator struct {
	ormtable.Iterator
}

func (i DataIDIterator) Value() (*DataID, error) {
	var dataID DataID
	err := i.UnmarshalMessage(&dataID)
	return &dataID, err
}

type DataIDIndexKey interface {
	id() uint32
	values() []interface{}
	dataIDIndexKey()
}

// primary key starting index..
type DataIDPrimaryKey = DataIDIdIndexKey

type DataIDIdIndexKey struct {
	vs []interface{}
}

func (x DataIDIdIndexKey) id() uint32            { return 0 }
func (x DataIDIdIndexKey) values() []interface{} { return x.vs }
func (x DataIDIdIndexKey) dataIDIndexKey()       {}

func (this DataIDIdIndexKey) WithId(id []byte) DataIDIdIndexKey {
	this.vs = []interface{}{id}
	return this
}

type DataIDIriIndexKey struct {
	vs []interface{}
}

func (x DataIDIriIndexKey) id() uint32            { return 1 }
func (x DataIDIriIndexKey) values() []interface{} { return x.vs }
func (x DataIDIriIndexKey) dataIDIndexKey()       {}

func (this DataIDIriIndexKey) WithIri(iri string) DataIDIriIndexKey {
	this.vs = []interface{}{iri}
	return this
}

type dataIDTable struct {
	table ormtable.Table
}

func (this dataIDTable) Insert(ctx context.Context, dataID *DataID) error {
	return this.table.Insert(ctx, dataID)
}

func (this dataIDTable) Update(ctx context.Context, dataID *DataID) error {
	return this.table.Update(ctx, dataID)
}

func (this dataIDTable) Save(ctx context.Context, dataID *DataID) error {
	return this.table.Save(ctx, dataID)
}

func (this dataIDTable) Delete(ctx context.Context, dataID *DataID) error {
	return this.table.Delete(ctx, dataID)
}

func (this dataIDTable) Has(ctx context.Context, id []byte) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, id)
}

func (this dataIDTable) Get(ctx context.Context, id []byte) (*DataID, error) {
	var dataID DataID
	found, err := this.table.PrimaryKey().Get(ctx, &dataID, id)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &dataID, nil
}

func (this dataIDTable) HasByIri(ctx context.Context, iri string) (found bool, err error) {
	return this.table.GetIndexByID(1).(ormtable.UniqueIndex).Has(ctx,
		iri,
	)
}

func (this dataIDTable) GetByIri(ctx context.Context, iri string) (*DataID, error) {
	var dataID DataID
	found, err := this.table.GetIndexByID(1).(ormtable.UniqueIndex).Get(ctx, &dataID,
		iri,
	)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &dataID, nil
}

func (this dataIDTable) List(ctx context.Context, prefixKey DataIDIndexKey, opts ...ormlist.Option) (DataIDIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return DataIDIterator{it}, err
}

func (this dataIDTable) ListRange(ctx context.Context, from, to DataIDIndexKey, opts ...ormlist.Option) (DataIDIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return DataIDIterator{it}, err
}

func (this dataIDTable) DeleteBy(ctx context.Context, prefixKey DataIDIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this dataIDTable) DeleteRange(ctx context.Context, from, to DataIDIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this dataIDTable) doNotImplement() {}

var _ DataIDTable = dataIDTable{}

func NewDataIDTable(db ormtable.Schema) (DataIDTable, error) {
	table := db.GetTable(&DataID{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&DataID{}).ProtoReflect().Descriptor().FullName()))
	}
	return dataIDTable{table}, nil
}

type DataAnchorTable interface {
	Insert(ctx context.Context, dataAnchor *DataAnchor) error
	Update(ctx context.Context, dataAnchor *DataAnchor) error
	Save(ctx context.Context, dataAnchor *DataAnchor) error
	Delete(ctx context.Context, dataAnchor *DataAnchor) error
	Has(ctx context.Context, id []byte) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, id []byte) (*DataAnchor, error)
	List(ctx context.Context, prefixKey DataAnchorIndexKey, opts ...ormlist.Option) (DataAnchorIterator, error)
	ListRange(ctx context.Context, from, to DataAnchorIndexKey, opts ...ormlist.Option) (DataAnchorIterator, error)
	DeleteBy(ctx context.Context, prefixKey DataAnchorIndexKey) error
	DeleteRange(ctx context.Context, from, to DataAnchorIndexKey) error

	doNotImplement()
}

type DataAnchorIterator struct {
	ormtable.Iterator
}

func (i DataAnchorIterator) Value() (*DataAnchor, error) {
	var dataAnchor DataAnchor
	err := i.UnmarshalMessage(&dataAnchor)
	return &dataAnchor, err
}

type DataAnchorIndexKey interface {
	id() uint32
	values() []interface{}
	dataAnchorIndexKey()
}

// primary key starting index..
type DataAnchorPrimaryKey = DataAnchorIdIndexKey

type DataAnchorIdIndexKey struct {
	vs []interface{}
}

func (x DataAnchorIdIndexKey) id() uint32            { return 0 }
func (x DataAnchorIdIndexKey) values() []interface{} { return x.vs }
func (x DataAnchorIdIndexKey) dataAnchorIndexKey()   {}

func (this DataAnchorIdIndexKey) WithId(id []byte) DataAnchorIdIndexKey {
	this.vs = []interface{}{id}
	return this
}

type dataAnchorTable struct {
	table ormtable.Table
}

func (this dataAnchorTable) Insert(ctx context.Context, dataAnchor *DataAnchor) error {
	return this.table.Insert(ctx, dataAnchor)
}

func (this dataAnchorTable) Update(ctx context.Context, dataAnchor *DataAnchor) error {
	return this.table.Update(ctx, dataAnchor)
}

func (this dataAnchorTable) Save(ctx context.Context, dataAnchor *DataAnchor) error {
	return this.table.Save(ctx, dataAnchor)
}

func (this dataAnchorTable) Delete(ctx context.Context, dataAnchor *DataAnchor) error {
	return this.table.Delete(ctx, dataAnchor)
}

func (this dataAnchorTable) Has(ctx context.Context, id []byte) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, id)
}

func (this dataAnchorTable) Get(ctx context.Context, id []byte) (*DataAnchor, error) {
	var dataAnchor DataAnchor
	found, err := this.table.PrimaryKey().Get(ctx, &dataAnchor, id)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &dataAnchor, nil
}

func (this dataAnchorTable) List(ctx context.Context, prefixKey DataAnchorIndexKey, opts ...ormlist.Option) (DataAnchorIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return DataAnchorIterator{it}, err
}

func (this dataAnchorTable) ListRange(ctx context.Context, from, to DataAnchorIndexKey, opts ...ormlist.Option) (DataAnchorIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return DataAnchorIterator{it}, err
}

func (this dataAnchorTable) DeleteBy(ctx context.Context, prefixKey DataAnchorIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this dataAnchorTable) DeleteRange(ctx context.Context, from, to DataAnchorIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this dataAnchorTable) doNotImplement() {}

var _ DataAnchorTable = dataAnchorTable{}

func NewDataAnchorTable(db ormtable.Schema) (DataAnchorTable, error) {
	table := db.GetTable(&DataAnchor{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&DataAnchor{}).ProtoReflect().Descriptor().FullName()))
	}
	return dataAnchorTable{table}, nil
}

type DataSignerTable interface {
	Insert(ctx context.Context, dataSigner *DataSigner) error
	Update(ctx context.Context, dataSigner *DataSigner) error
	Save(ctx context.Context, dataSigner *DataSigner) error
	Delete(ctx context.Context, dataSigner *DataSigner) error
	Has(ctx context.Context, id []byte, signer []byte) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, id []byte, signer []byte) (*DataSigner, error)
	List(ctx context.Context, prefixKey DataSignerIndexKey, opts ...ormlist.Option) (DataSignerIterator, error)
	ListRange(ctx context.Context, from, to DataSignerIndexKey, opts ...ormlist.Option) (DataSignerIterator, error)
	DeleteBy(ctx context.Context, prefixKey DataSignerIndexKey) error
	DeleteRange(ctx context.Context, from, to DataSignerIndexKey) error

	doNotImplement()
}

type DataSignerIterator struct {
	ormtable.Iterator
}

func (i DataSignerIterator) Value() (*DataSigner, error) {
	var dataSigner DataSigner
	err := i.UnmarshalMessage(&dataSigner)
	return &dataSigner, err
}

type DataSignerIndexKey interface {
	id() uint32
	values() []interface{}
	dataSignerIndexKey()
}

// primary key starting index..
type DataSignerPrimaryKey = DataSignerIdSignerIndexKey

type DataSignerIdSignerIndexKey struct {
	vs []interface{}
}

func (x DataSignerIdSignerIndexKey) id() uint32            { return 0 }
func (x DataSignerIdSignerIndexKey) values() []interface{} { return x.vs }
func (x DataSignerIdSignerIndexKey) dataSignerIndexKey()   {}

func (this DataSignerIdSignerIndexKey) WithId(id []byte) DataSignerIdSignerIndexKey {
	this.vs = []interface{}{id}
	return this
}

func (this DataSignerIdSignerIndexKey) WithIdSigner(id []byte, signer []byte) DataSignerIdSignerIndexKey {
	this.vs = []interface{}{id, signer}
	return this
}

type dataSignerTable struct {
	table ormtable.Table
}

func (this dataSignerTable) Insert(ctx context.Context, dataSigner *DataSigner) error {
	return this.table.Insert(ctx, dataSigner)
}

func (this dataSignerTable) Update(ctx context.Context, dataSigner *DataSigner) error {
	return this.table.Update(ctx, dataSigner)
}

func (this dataSignerTable) Save(ctx context.Context, dataSigner *DataSigner) error {
	return this.table.Save(ctx, dataSigner)
}

func (this dataSignerTable) Delete(ctx context.Context, dataSigner *DataSigner) error {
	return this.table.Delete(ctx, dataSigner)
}

func (this dataSignerTable) Has(ctx context.Context, id []byte, signer []byte) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, id, signer)
}

func (this dataSignerTable) Get(ctx context.Context, id []byte, signer []byte) (*DataSigner, error) {
	var dataSigner DataSigner
	found, err := this.table.PrimaryKey().Get(ctx, &dataSigner, id, signer)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &dataSigner, nil
}

func (this dataSignerTable) List(ctx context.Context, prefixKey DataSignerIndexKey, opts ...ormlist.Option) (DataSignerIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return DataSignerIterator{it}, err
}

func (this dataSignerTable) ListRange(ctx context.Context, from, to DataSignerIndexKey, opts ...ormlist.Option) (DataSignerIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return DataSignerIterator{it}, err
}

func (this dataSignerTable) DeleteBy(ctx context.Context, prefixKey DataSignerIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this dataSignerTable) DeleteRange(ctx context.Context, from, to DataSignerIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this dataSignerTable) doNotImplement() {}

var _ DataSignerTable = dataSignerTable{}

func NewDataSignerTable(db ormtable.Schema) (DataSignerTable, error) {
	table := db.GetTable(&DataSigner{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&DataSigner{}).ProtoReflect().Descriptor().FullName()))
	}
	return dataSignerTable{table}, nil
}

type ResolverInfoTable interface {
	Insert(ctx context.Context, resolverInfo *ResolverInfo) error
	InsertReturningID(ctx context.Context, resolverInfo *ResolverInfo) (uint64, error)
	Update(ctx context.Context, resolverInfo *ResolverInfo) error
	Save(ctx context.Context, resolverInfo *ResolverInfo) error
	Delete(ctx context.Context, resolverInfo *ResolverInfo) error
	Has(ctx context.Context, id uint64) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, id uint64) (*ResolverInfo, error)
	HasByUrl(ctx context.Context, url string) (found bool, err error)
	// GetByUrl returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	GetByUrl(ctx context.Context, url string) (*ResolverInfo, error)
	List(ctx context.Context, prefixKey ResolverInfoIndexKey, opts ...ormlist.Option) (ResolverInfoIterator, error)
	ListRange(ctx context.Context, from, to ResolverInfoIndexKey, opts ...ormlist.Option) (ResolverInfoIterator, error)
	DeleteBy(ctx context.Context, prefixKey ResolverInfoIndexKey) error
	DeleteRange(ctx context.Context, from, to ResolverInfoIndexKey) error

	doNotImplement()
}

type ResolverInfoIterator struct {
	ormtable.Iterator
}

func (i ResolverInfoIterator) Value() (*ResolverInfo, error) {
	var resolverInfo ResolverInfo
	err := i.UnmarshalMessage(&resolverInfo)
	return &resolverInfo, err
}

type ResolverInfoIndexKey interface {
	id() uint32
	values() []interface{}
	resolverInfoIndexKey()
}

// primary key starting index..
type ResolverInfoPrimaryKey = ResolverInfoIdIndexKey

type ResolverInfoIdIndexKey struct {
	vs []interface{}
}

func (x ResolverInfoIdIndexKey) id() uint32            { return 0 }
func (x ResolverInfoIdIndexKey) values() []interface{} { return x.vs }
func (x ResolverInfoIdIndexKey) resolverInfoIndexKey() {}

func (this ResolverInfoIdIndexKey) WithId(id uint64) ResolverInfoIdIndexKey {
	this.vs = []interface{}{id}
	return this
}

type ResolverInfoUrlIndexKey struct {
	vs []interface{}
}

func (x ResolverInfoUrlIndexKey) id() uint32            { return 1 }
func (x ResolverInfoUrlIndexKey) values() []interface{} { return x.vs }
func (x ResolverInfoUrlIndexKey) resolverInfoIndexKey() {}

func (this ResolverInfoUrlIndexKey) WithUrl(url string) ResolverInfoUrlIndexKey {
	this.vs = []interface{}{url}
	return this
}

type ResolverInfoManagerIndexKey struct {
	vs []interface{}
}

func (x ResolverInfoManagerIndexKey) id() uint32            { return 2 }
func (x ResolverInfoManagerIndexKey) values() []interface{} { return x.vs }
func (x ResolverInfoManagerIndexKey) resolverInfoIndexKey() {}

func (this ResolverInfoManagerIndexKey) WithManager(manager []byte) ResolverInfoManagerIndexKey {
	this.vs = []interface{}{manager}
	return this
}

type resolverInfoTable struct {
	table ormtable.AutoIncrementTable
}

func (this resolverInfoTable) Insert(ctx context.Context, resolverInfo *ResolverInfo) error {
	return this.table.Insert(ctx, resolverInfo)
}

func (this resolverInfoTable) Update(ctx context.Context, resolverInfo *ResolverInfo) error {
	return this.table.Update(ctx, resolverInfo)
}

func (this resolverInfoTable) Save(ctx context.Context, resolverInfo *ResolverInfo) error {
	return this.table.Save(ctx, resolverInfo)
}

func (this resolverInfoTable) Delete(ctx context.Context, resolverInfo *ResolverInfo) error {
	return this.table.Delete(ctx, resolverInfo)
}

func (this resolverInfoTable) InsertReturningID(ctx context.Context, resolverInfo *ResolverInfo) (uint64, error) {
	return this.table.InsertReturningID(ctx, resolverInfo)
}

func (this resolverInfoTable) Has(ctx context.Context, id uint64) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, id)
}

func (this resolverInfoTable) Get(ctx context.Context, id uint64) (*ResolverInfo, error) {
	var resolverInfo ResolverInfo
	found, err := this.table.PrimaryKey().Get(ctx, &resolverInfo, id)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &resolverInfo, nil
}

func (this resolverInfoTable) HasByUrl(ctx context.Context, url string) (found bool, err error) {
	return this.table.GetIndexByID(1).(ormtable.UniqueIndex).Has(ctx,
		url,
	)
}

func (this resolverInfoTable) GetByUrl(ctx context.Context, url string) (*ResolverInfo, error) {
	var resolverInfo ResolverInfo
	found, err := this.table.GetIndexByID(1).(ormtable.UniqueIndex).Get(ctx, &resolverInfo,
		url,
	)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &resolverInfo, nil
}

func (this resolverInfoTable) List(ctx context.Context, prefixKey ResolverInfoIndexKey, opts ...ormlist.Option) (ResolverInfoIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return ResolverInfoIterator{it}, err
}

func (this resolverInfoTable) ListRange(ctx context.Context, from, to ResolverInfoIndexKey, opts ...ormlist.Option) (ResolverInfoIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return ResolverInfoIterator{it}, err
}

func (this resolverInfoTable) DeleteBy(ctx context.Context, prefixKey ResolverInfoIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this resolverInfoTable) DeleteRange(ctx context.Context, from, to ResolverInfoIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this resolverInfoTable) doNotImplement() {}

var _ ResolverInfoTable = resolverInfoTable{}

func NewResolverInfoTable(db ormtable.Schema) (ResolverInfoTable, error) {
	table := db.GetTable(&ResolverInfo{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&ResolverInfo{}).ProtoReflect().Descriptor().FullName()))
	}
	return resolverInfoTable{table.(ormtable.AutoIncrementTable)}, nil
}

type DataResolverTable interface {
	Insert(ctx context.Context, dataResolver *DataResolver) error
	Update(ctx context.Context, dataResolver *DataResolver) error
	Save(ctx context.Context, dataResolver *DataResolver) error
	Delete(ctx context.Context, dataResolver *DataResolver) error
	Has(ctx context.Context, id []byte, resolver_id uint64) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, id []byte, resolver_id uint64) (*DataResolver, error)
	List(ctx context.Context, prefixKey DataResolverIndexKey, opts ...ormlist.Option) (DataResolverIterator, error)
	ListRange(ctx context.Context, from, to DataResolverIndexKey, opts ...ormlist.Option) (DataResolverIterator, error)
	DeleteBy(ctx context.Context, prefixKey DataResolverIndexKey) error
	DeleteRange(ctx context.Context, from, to DataResolverIndexKey) error

	doNotImplement()
}

type DataResolverIterator struct {
	ormtable.Iterator
}

func (i DataResolverIterator) Value() (*DataResolver, error) {
	var dataResolver DataResolver
	err := i.UnmarshalMessage(&dataResolver)
	return &dataResolver, err
}

type DataResolverIndexKey interface {
	id() uint32
	values() []interface{}
	dataResolverIndexKey()
}

// primary key starting index..
type DataResolverPrimaryKey = DataResolverIdResolverIdIndexKey

type DataResolverIdResolverIdIndexKey struct {
	vs []interface{}
}

func (x DataResolverIdResolverIdIndexKey) id() uint32            { return 0 }
func (x DataResolverIdResolverIdIndexKey) values() []interface{} { return x.vs }
func (x DataResolverIdResolverIdIndexKey) dataResolverIndexKey() {}

func (this DataResolverIdResolverIdIndexKey) WithId(id []byte) DataResolverIdResolverIdIndexKey {
	this.vs = []interface{}{id}
	return this
}

func (this DataResolverIdResolverIdIndexKey) WithIdResolverId(id []byte, resolver_id uint64) DataResolverIdResolverIdIndexKey {
	this.vs = []interface{}{id, resolver_id}
	return this
}

type dataResolverTable struct {
	table ormtable.Table
}

func (this dataResolverTable) Insert(ctx context.Context, dataResolver *DataResolver) error {
	return this.table.Insert(ctx, dataResolver)
}

func (this dataResolverTable) Update(ctx context.Context, dataResolver *DataResolver) error {
	return this.table.Update(ctx, dataResolver)
}

func (this dataResolverTable) Save(ctx context.Context, dataResolver *DataResolver) error {
	return this.table.Save(ctx, dataResolver)
}

func (this dataResolverTable) Delete(ctx context.Context, dataResolver *DataResolver) error {
	return this.table.Delete(ctx, dataResolver)
}

func (this dataResolverTable) Has(ctx context.Context, id []byte, resolver_id uint64) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, id, resolver_id)
}

func (this dataResolverTable) Get(ctx context.Context, id []byte, resolver_id uint64) (*DataResolver, error) {
	var dataResolver DataResolver
	found, err := this.table.PrimaryKey().Get(ctx, &dataResolver, id, resolver_id)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &dataResolver, nil
}

func (this dataResolverTable) List(ctx context.Context, prefixKey DataResolverIndexKey, opts ...ormlist.Option) (DataResolverIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return DataResolverIterator{it}, err
}

func (this dataResolverTable) ListRange(ctx context.Context, from, to DataResolverIndexKey, opts ...ormlist.Option) (DataResolverIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return DataResolverIterator{it}, err
}

func (this dataResolverTable) DeleteBy(ctx context.Context, prefixKey DataResolverIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this dataResolverTable) DeleteRange(ctx context.Context, from, to DataResolverIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this dataResolverTable) doNotImplement() {}

var _ DataResolverTable = dataResolverTable{}

func NewDataResolverTable(db ormtable.Schema) (DataResolverTable, error) {
	table := db.GetTable(&DataResolver{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&DataResolver{}).ProtoReflect().Descriptor().FullName()))
	}
	return dataResolverTable{table}, nil
}

type StateStore interface {
	DataIDTable() DataIDTable
	DataAnchorTable() DataAnchorTable
	DataSignerTable() DataSignerTable
	ResolverInfoTable() ResolverInfoTable
	DataResolverTable() DataResolverTable

	doNotImplement()
}

type stateStore struct {
	dataID       DataIDTable
	dataAnchor   DataAnchorTable
	dataSigner   DataSignerTable
	resolverInfo ResolverInfoTable
	dataResolver DataResolverTable
}

func (x stateStore) DataIDTable() DataIDTable {
	return x.dataID
}

func (x stateStore) DataAnchorTable() DataAnchorTable {
	return x.dataAnchor
}

func (x stateStore) DataSignerTable() DataSignerTable {
	return x.dataSigner
}

func (x stateStore) ResolverInfoTable() ResolverInfoTable {
	return x.resolverInfo
}

func (x stateStore) DataResolverTable() DataResolverTable {
	return x.dataResolver
}

func (stateStore) doNotImplement() {}

var _ StateStore = stateStore{}

func NewStateStore(db ormtable.Schema) (StateStore, error) {
	dataIDTable, err := NewDataIDTable(db)
	if err != nil {
		return nil, err
	}

	dataAnchorTable, err := NewDataAnchorTable(db)
	if err != nil {
		return nil, err
	}

	dataSignerTable, err := NewDataSignerTable(db)
	if err != nil {
		return nil, err
	}

	resolverInfoTable, err := NewResolverInfoTable(db)
	if err != nil {
		return nil, err
	}

	dataResolverTable, err := NewDataResolverTable(db)
	if err != nil {
		return nil, err
	}

	return stateStore{
		dataIDTable,
		dataAnchorTable,
		dataSignerTable,
		resolverInfoTable,
		dataResolverTable,
	}, nil
}
