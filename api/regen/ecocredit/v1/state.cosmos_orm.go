// Code generated by protoc-gen-go-cosmos-orm. DO NOT EDIT.

package ecocreditv1

import (
	context "context"
	ormlist "github.com/cosmos/cosmos-sdk/orm/model/ormlist"
	ormtable "github.com/cosmos/cosmos-sdk/orm/model/ormtable"
	ormerrors "github.com/cosmos/cosmos-sdk/orm/types/ormerrors"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

type CreditTypeTable interface {
	Insert(ctx context.Context, creditType *CreditType) error
	Update(ctx context.Context, creditType *CreditType) error
	Save(ctx context.Context, creditType *CreditType) error
	Delete(ctx context.Context, creditType *CreditType) error
	Has(ctx context.Context, abbreviation string) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, abbreviation string) (*CreditType, error)
	HasByName(ctx context.Context, name string) (found bool, err error)
	// GetByName returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	GetByName(ctx context.Context, name string) (*CreditType, error)
	List(ctx context.Context, prefixKey CreditTypeIndexKey, opts ...ormlist.Option) (CreditTypeIterator, error)
	ListRange(ctx context.Context, from, to CreditTypeIndexKey, opts ...ormlist.Option) (CreditTypeIterator, error)
	DeleteBy(ctx context.Context, prefixKey CreditTypeIndexKey) error
	DeleteRange(ctx context.Context, from, to CreditTypeIndexKey) error

	doNotImplement()
}

type CreditTypeIterator struct {
	ormtable.Iterator
}

func (i CreditTypeIterator) Value() (*CreditType, error) {
	var creditType CreditType
	err := i.UnmarshalMessage(&creditType)
	return &creditType, err
}

type CreditTypeIndexKey interface {
	id() uint32
	values() []interface{}
	creditTypeIndexKey()
}

// primary key starting index..
type CreditTypePrimaryKey = CreditTypeAbbreviationIndexKey

type CreditTypeAbbreviationIndexKey struct {
	vs []interface{}
}

func (x CreditTypeAbbreviationIndexKey) id() uint32            { return 0 }
func (x CreditTypeAbbreviationIndexKey) values() []interface{} { return x.vs }
func (x CreditTypeAbbreviationIndexKey) creditTypeIndexKey()   {}

func (this CreditTypeAbbreviationIndexKey) WithAbbreviation(abbreviation string) CreditTypeAbbreviationIndexKey {
	this.vs = []interface{}{abbreviation}
	return this
}

type CreditTypeNameIndexKey struct {
	vs []interface{}
}

func (x CreditTypeNameIndexKey) id() uint32            { return 1 }
func (x CreditTypeNameIndexKey) values() []interface{} { return x.vs }
func (x CreditTypeNameIndexKey) creditTypeIndexKey()   {}

func (this CreditTypeNameIndexKey) WithName(name string) CreditTypeNameIndexKey {
	this.vs = []interface{}{name}
	return this
}

type creditTypeTable struct {
	table ormtable.Table
}

func (this creditTypeTable) Insert(ctx context.Context, creditType *CreditType) error {
	return this.table.Insert(ctx, creditType)
}

func (this creditTypeTable) Update(ctx context.Context, creditType *CreditType) error {
	return this.table.Update(ctx, creditType)
}

func (this creditTypeTable) Save(ctx context.Context, creditType *CreditType) error {
	return this.table.Save(ctx, creditType)
}

func (this creditTypeTable) Delete(ctx context.Context, creditType *CreditType) error {
	return this.table.Delete(ctx, creditType)
}

func (this creditTypeTable) Has(ctx context.Context, abbreviation string) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, abbreviation)
}

func (this creditTypeTable) Get(ctx context.Context, abbreviation string) (*CreditType, error) {
	var creditType CreditType
	found, err := this.table.PrimaryKey().Get(ctx, &creditType, abbreviation)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &creditType, nil
}

func (this creditTypeTable) HasByName(ctx context.Context, name string) (found bool, err error) {
	return this.table.GetIndexByID(1).(ormtable.UniqueIndex).Has(ctx,
		name,
	)
}

func (this creditTypeTable) GetByName(ctx context.Context, name string) (*CreditType, error) {
	var creditType CreditType
	found, err := this.table.GetIndexByID(1).(ormtable.UniqueIndex).Get(ctx, &creditType,
		name,
	)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &creditType, nil
}

func (this creditTypeTable) List(ctx context.Context, prefixKey CreditTypeIndexKey, opts ...ormlist.Option) (CreditTypeIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return CreditTypeIterator{it}, err
}

func (this creditTypeTable) ListRange(ctx context.Context, from, to CreditTypeIndexKey, opts ...ormlist.Option) (CreditTypeIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return CreditTypeIterator{it}, err
}

func (this creditTypeTable) DeleteBy(ctx context.Context, prefixKey CreditTypeIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this creditTypeTable) DeleteRange(ctx context.Context, from, to CreditTypeIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this creditTypeTable) doNotImplement() {}

var _ CreditTypeTable = creditTypeTable{}

func NewCreditTypeTable(db ormtable.Schema) (CreditTypeTable, error) {
	table := db.GetTable(&CreditType{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&CreditType{}).ProtoReflect().Descriptor().FullName()))
	}
	return creditTypeTable{table}, nil
}

type ClassInfoTable interface {
	Insert(ctx context.Context, classInfo *ClassInfo) error
	InsertReturningID(ctx context.Context, classInfo *ClassInfo) (uint64, error)
	Update(ctx context.Context, classInfo *ClassInfo) error
	Save(ctx context.Context, classInfo *ClassInfo) error
	Delete(ctx context.Context, classInfo *ClassInfo) error
	Has(ctx context.Context, key uint64) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, key uint64) (*ClassInfo, error)
	HasById(ctx context.Context, id string) (found bool, err error)
	// GetById returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	GetById(ctx context.Context, id string) (*ClassInfo, error)
	List(ctx context.Context, prefixKey ClassInfoIndexKey, opts ...ormlist.Option) (ClassInfoIterator, error)
	ListRange(ctx context.Context, from, to ClassInfoIndexKey, opts ...ormlist.Option) (ClassInfoIterator, error)
	DeleteBy(ctx context.Context, prefixKey ClassInfoIndexKey) error
	DeleteRange(ctx context.Context, from, to ClassInfoIndexKey) error

	doNotImplement()
}

type ClassInfoIterator struct {
	ormtable.Iterator
}

func (i ClassInfoIterator) Value() (*ClassInfo, error) {
	var classInfo ClassInfo
	err := i.UnmarshalMessage(&classInfo)
	return &classInfo, err
}

type ClassInfoIndexKey interface {
	id() uint32
	values() []interface{}
	classInfoIndexKey()
}

// primary key starting index..
type ClassInfoPrimaryKey = ClassInfoKeyIndexKey

type ClassInfoKeyIndexKey struct {
	vs []interface{}
}

func (x ClassInfoKeyIndexKey) id() uint32            { return 0 }
func (x ClassInfoKeyIndexKey) values() []interface{} { return x.vs }
func (x ClassInfoKeyIndexKey) classInfoIndexKey()    {}

func (this ClassInfoKeyIndexKey) WithKey(key uint64) ClassInfoKeyIndexKey {
	this.vs = []interface{}{key}
	return this
}

type ClassInfoIdIndexKey struct {
	vs []interface{}
}

func (x ClassInfoIdIndexKey) id() uint32            { return 1 }
func (x ClassInfoIdIndexKey) values() []interface{} { return x.vs }
func (x ClassInfoIdIndexKey) classInfoIndexKey()    {}

func (this ClassInfoIdIndexKey) WithId(id string) ClassInfoIdIndexKey {
	this.vs = []interface{}{id}
	return this
}

type ClassInfoAdminIndexKey struct {
	vs []interface{}
}

func (x ClassInfoAdminIndexKey) id() uint32            { return 2 }
func (x ClassInfoAdminIndexKey) values() []interface{} { return x.vs }
func (x ClassInfoAdminIndexKey) classInfoIndexKey()    {}

func (this ClassInfoAdminIndexKey) WithAdmin(admin []byte) ClassInfoAdminIndexKey {
	this.vs = []interface{}{admin}
	return this
}

type ClassInfoCreditTypeAbbrevIndexKey struct {
	vs []interface{}
}

func (x ClassInfoCreditTypeAbbrevIndexKey) id() uint32            { return 3 }
func (x ClassInfoCreditTypeAbbrevIndexKey) values() []interface{} { return x.vs }
func (x ClassInfoCreditTypeAbbrevIndexKey) classInfoIndexKey()    {}

func (this ClassInfoCreditTypeAbbrevIndexKey) WithCreditTypeAbbrev(credit_type_abbrev string) ClassInfoCreditTypeAbbrevIndexKey {
	this.vs = []interface{}{credit_type_abbrev}
	return this
}

type classInfoTable struct {
	table ormtable.AutoIncrementTable
}

func (this classInfoTable) Insert(ctx context.Context, classInfo *ClassInfo) error {
	return this.table.Insert(ctx, classInfo)
}

func (this classInfoTable) Update(ctx context.Context, classInfo *ClassInfo) error {
	return this.table.Update(ctx, classInfo)
}

func (this classInfoTable) Save(ctx context.Context, classInfo *ClassInfo) error {
	return this.table.Save(ctx, classInfo)
}

func (this classInfoTable) Delete(ctx context.Context, classInfo *ClassInfo) error {
	return this.table.Delete(ctx, classInfo)
}

func (this classInfoTable) InsertReturningID(ctx context.Context, classInfo *ClassInfo) (uint64, error) {
	return this.table.InsertReturningID(ctx, classInfo)
}

func (this classInfoTable) Has(ctx context.Context, key uint64) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, key)
}

func (this classInfoTable) Get(ctx context.Context, key uint64) (*ClassInfo, error) {
	var classInfo ClassInfo
	found, err := this.table.PrimaryKey().Get(ctx, &classInfo, key)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &classInfo, nil
}

func (this classInfoTable) HasById(ctx context.Context, id string) (found bool, err error) {
	return this.table.GetIndexByID(1).(ormtable.UniqueIndex).Has(ctx,
		id,
	)
}

func (this classInfoTable) GetById(ctx context.Context, id string) (*ClassInfo, error) {
	var classInfo ClassInfo
	found, err := this.table.GetIndexByID(1).(ormtable.UniqueIndex).Get(ctx, &classInfo,
		id,
	)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &classInfo, nil
}

func (this classInfoTable) List(ctx context.Context, prefixKey ClassInfoIndexKey, opts ...ormlist.Option) (ClassInfoIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return ClassInfoIterator{it}, err
}

func (this classInfoTable) ListRange(ctx context.Context, from, to ClassInfoIndexKey, opts ...ormlist.Option) (ClassInfoIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return ClassInfoIterator{it}, err
}

func (this classInfoTable) DeleteBy(ctx context.Context, prefixKey ClassInfoIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this classInfoTable) DeleteRange(ctx context.Context, from, to ClassInfoIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this classInfoTable) doNotImplement() {}

var _ ClassInfoTable = classInfoTable{}

func NewClassInfoTable(db ormtable.Schema) (ClassInfoTable, error) {
	table := db.GetTable(&ClassInfo{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&ClassInfo{}).ProtoReflect().Descriptor().FullName()))
	}
	return classInfoTable{table.(ormtable.AutoIncrementTable)}, nil
}

type ClassIssuerTable interface {
	Insert(ctx context.Context, classIssuer *ClassIssuer) error
	Update(ctx context.Context, classIssuer *ClassIssuer) error
	Save(ctx context.Context, classIssuer *ClassIssuer) error
	Delete(ctx context.Context, classIssuer *ClassIssuer) error
	Has(ctx context.Context, class_key uint64, issuer []byte) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, class_key uint64, issuer []byte) (*ClassIssuer, error)
	List(ctx context.Context, prefixKey ClassIssuerIndexKey, opts ...ormlist.Option) (ClassIssuerIterator, error)
	ListRange(ctx context.Context, from, to ClassIssuerIndexKey, opts ...ormlist.Option) (ClassIssuerIterator, error)
	DeleteBy(ctx context.Context, prefixKey ClassIssuerIndexKey) error
	DeleteRange(ctx context.Context, from, to ClassIssuerIndexKey) error

	doNotImplement()
}

type ClassIssuerIterator struct {
	ormtable.Iterator
}

func (i ClassIssuerIterator) Value() (*ClassIssuer, error) {
	var classIssuer ClassIssuer
	err := i.UnmarshalMessage(&classIssuer)
	return &classIssuer, err
}

type ClassIssuerIndexKey interface {
	id() uint32
	values() []interface{}
	classIssuerIndexKey()
}

// primary key starting index..
type ClassIssuerPrimaryKey = ClassIssuerClassKeyIssuerIndexKey

type ClassIssuerClassKeyIssuerIndexKey struct {
	vs []interface{}
}

func (x ClassIssuerClassKeyIssuerIndexKey) id() uint32            { return 0 }
func (x ClassIssuerClassKeyIssuerIndexKey) values() []interface{} { return x.vs }
func (x ClassIssuerClassKeyIssuerIndexKey) classIssuerIndexKey()  {}

func (this ClassIssuerClassKeyIssuerIndexKey) WithClassKey(class_key uint64) ClassIssuerClassKeyIssuerIndexKey {
	this.vs = []interface{}{class_key}
	return this
}

func (this ClassIssuerClassKeyIssuerIndexKey) WithClassKeyIssuer(class_key uint64, issuer []byte) ClassIssuerClassKeyIssuerIndexKey {
	this.vs = []interface{}{class_key, issuer}
	return this
}

type classIssuerTable struct {
	table ormtable.Table
}

func (this classIssuerTable) Insert(ctx context.Context, classIssuer *ClassIssuer) error {
	return this.table.Insert(ctx, classIssuer)
}

func (this classIssuerTable) Update(ctx context.Context, classIssuer *ClassIssuer) error {
	return this.table.Update(ctx, classIssuer)
}

func (this classIssuerTable) Save(ctx context.Context, classIssuer *ClassIssuer) error {
	return this.table.Save(ctx, classIssuer)
}

func (this classIssuerTable) Delete(ctx context.Context, classIssuer *ClassIssuer) error {
	return this.table.Delete(ctx, classIssuer)
}

func (this classIssuerTable) Has(ctx context.Context, class_key uint64, issuer []byte) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, class_key, issuer)
}

func (this classIssuerTable) Get(ctx context.Context, class_key uint64, issuer []byte) (*ClassIssuer, error) {
	var classIssuer ClassIssuer
	found, err := this.table.PrimaryKey().Get(ctx, &classIssuer, class_key, issuer)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &classIssuer, nil
}

func (this classIssuerTable) List(ctx context.Context, prefixKey ClassIssuerIndexKey, opts ...ormlist.Option) (ClassIssuerIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return ClassIssuerIterator{it}, err
}

func (this classIssuerTable) ListRange(ctx context.Context, from, to ClassIssuerIndexKey, opts ...ormlist.Option) (ClassIssuerIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return ClassIssuerIterator{it}, err
}

func (this classIssuerTable) DeleteBy(ctx context.Context, prefixKey ClassIssuerIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this classIssuerTable) DeleteRange(ctx context.Context, from, to ClassIssuerIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this classIssuerTable) doNotImplement() {}

var _ ClassIssuerTable = classIssuerTable{}

func NewClassIssuerTable(db ormtable.Schema) (ClassIssuerTable, error) {
	table := db.GetTable(&ClassIssuer{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&ClassIssuer{}).ProtoReflect().Descriptor().FullName()))
	}
	return classIssuerTable{table}, nil
}

type ProjectInfoTable interface {
	Insert(ctx context.Context, projectInfo *ProjectInfo) error
	InsertReturningID(ctx context.Context, projectInfo *ProjectInfo) (uint64, error)
	Update(ctx context.Context, projectInfo *ProjectInfo) error
	Save(ctx context.Context, projectInfo *ProjectInfo) error
	Delete(ctx context.Context, projectInfo *ProjectInfo) error
	Has(ctx context.Context, key uint64) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, key uint64) (*ProjectInfo, error)
	HasById(ctx context.Context, id string) (found bool, err error)
	// GetById returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	GetById(ctx context.Context, id string) (*ProjectInfo, error)
	HasByClassKeyId(ctx context.Context, class_key uint64, id string) (found bool, err error)
	// GetByClassKeyId returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	GetByClassKeyId(ctx context.Context, class_key uint64, id string) (*ProjectInfo, error)
	List(ctx context.Context, prefixKey ProjectInfoIndexKey, opts ...ormlist.Option) (ProjectInfoIterator, error)
	ListRange(ctx context.Context, from, to ProjectInfoIndexKey, opts ...ormlist.Option) (ProjectInfoIterator, error)
	DeleteBy(ctx context.Context, prefixKey ProjectInfoIndexKey) error
	DeleteRange(ctx context.Context, from, to ProjectInfoIndexKey) error

	doNotImplement()
}

type ProjectInfoIterator struct {
	ormtable.Iterator
}

func (i ProjectInfoIterator) Value() (*ProjectInfo, error) {
	var projectInfo ProjectInfo
	err := i.UnmarshalMessage(&projectInfo)
	return &projectInfo, err
}

type ProjectInfoIndexKey interface {
	id() uint32
	values() []interface{}
	projectInfoIndexKey()
}

// primary key starting index..
type ProjectInfoPrimaryKey = ProjectInfoKeyIndexKey

type ProjectInfoKeyIndexKey struct {
	vs []interface{}
}

func (x ProjectInfoKeyIndexKey) id() uint32            { return 0 }
func (x ProjectInfoKeyIndexKey) values() []interface{} { return x.vs }
func (x ProjectInfoKeyIndexKey) projectInfoIndexKey()  {}

func (this ProjectInfoKeyIndexKey) WithKey(key uint64) ProjectInfoKeyIndexKey {
	this.vs = []interface{}{key}
	return this
}

type ProjectInfoIdIndexKey struct {
	vs []interface{}
}

func (x ProjectInfoIdIndexKey) id() uint32            { return 1 }
func (x ProjectInfoIdIndexKey) values() []interface{} { return x.vs }
func (x ProjectInfoIdIndexKey) projectInfoIndexKey()  {}

func (this ProjectInfoIdIndexKey) WithId(id string) ProjectInfoIdIndexKey {
	this.vs = []interface{}{id}
	return this
}

type ProjectInfoClassKeyIdIndexKey struct {
	vs []interface{}
}

func (x ProjectInfoClassKeyIdIndexKey) id() uint32            { return 2 }
func (x ProjectInfoClassKeyIdIndexKey) values() []interface{} { return x.vs }
func (x ProjectInfoClassKeyIdIndexKey) projectInfoIndexKey()  {}

func (this ProjectInfoClassKeyIdIndexKey) WithClassKey(class_key uint64) ProjectInfoClassKeyIdIndexKey {
	this.vs = []interface{}{class_key}
	return this
}

func (this ProjectInfoClassKeyIdIndexKey) WithClassKeyId(class_key uint64, id string) ProjectInfoClassKeyIdIndexKey {
	this.vs = []interface{}{class_key, id}
	return this
}

type ProjectInfoAdminIndexKey struct {
	vs []interface{}
}

func (x ProjectInfoAdminIndexKey) id() uint32            { return 3 }
func (x ProjectInfoAdminIndexKey) values() []interface{} { return x.vs }
func (x ProjectInfoAdminIndexKey) projectInfoIndexKey()  {}

func (this ProjectInfoAdminIndexKey) WithAdmin(admin []byte) ProjectInfoAdminIndexKey {
	this.vs = []interface{}{admin}
	return this
}

type projectInfoTable struct {
	table ormtable.AutoIncrementTable
}

func (this projectInfoTable) Insert(ctx context.Context, projectInfo *ProjectInfo) error {
	return this.table.Insert(ctx, projectInfo)
}

func (this projectInfoTable) Update(ctx context.Context, projectInfo *ProjectInfo) error {
	return this.table.Update(ctx, projectInfo)
}

func (this projectInfoTable) Save(ctx context.Context, projectInfo *ProjectInfo) error {
	return this.table.Save(ctx, projectInfo)
}

func (this projectInfoTable) Delete(ctx context.Context, projectInfo *ProjectInfo) error {
	return this.table.Delete(ctx, projectInfo)
}

func (this projectInfoTable) InsertReturningID(ctx context.Context, projectInfo *ProjectInfo) (uint64, error) {
	return this.table.InsertReturningID(ctx, projectInfo)
}

func (this projectInfoTable) Has(ctx context.Context, key uint64) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, key)
}

func (this projectInfoTable) Get(ctx context.Context, key uint64) (*ProjectInfo, error) {
	var projectInfo ProjectInfo
	found, err := this.table.PrimaryKey().Get(ctx, &projectInfo, key)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &projectInfo, nil
}

func (this projectInfoTable) HasById(ctx context.Context, id string) (found bool, err error) {
	return this.table.GetIndexByID(1).(ormtable.UniqueIndex).Has(ctx,
		id,
	)
}

func (this projectInfoTable) GetById(ctx context.Context, id string) (*ProjectInfo, error) {
	var projectInfo ProjectInfo
	found, err := this.table.GetIndexByID(1).(ormtable.UniqueIndex).Get(ctx, &projectInfo,
		id,
	)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &projectInfo, nil
}

func (this projectInfoTable) HasByClassKeyId(ctx context.Context, class_key uint64, id string) (found bool, err error) {
	return this.table.GetIndexByID(2).(ormtable.UniqueIndex).Has(ctx,
		class_key,
		id,
	)
}

func (this projectInfoTable) GetByClassKeyId(ctx context.Context, class_key uint64, id string) (*ProjectInfo, error) {
	var projectInfo ProjectInfo
	found, err := this.table.GetIndexByID(2).(ormtable.UniqueIndex).Get(ctx, &projectInfo,
		class_key,
		id,
	)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &projectInfo, nil
}

func (this projectInfoTable) List(ctx context.Context, prefixKey ProjectInfoIndexKey, opts ...ormlist.Option) (ProjectInfoIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return ProjectInfoIterator{it}, err
}

func (this projectInfoTable) ListRange(ctx context.Context, from, to ProjectInfoIndexKey, opts ...ormlist.Option) (ProjectInfoIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return ProjectInfoIterator{it}, err
}

func (this projectInfoTable) DeleteBy(ctx context.Context, prefixKey ProjectInfoIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this projectInfoTable) DeleteRange(ctx context.Context, from, to ProjectInfoIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this projectInfoTable) doNotImplement() {}

var _ ProjectInfoTable = projectInfoTable{}

func NewProjectInfoTable(db ormtable.Schema) (ProjectInfoTable, error) {
	table := db.GetTable(&ProjectInfo{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&ProjectInfo{}).ProtoReflect().Descriptor().FullName()))
	}
	return projectInfoTable{table.(ormtable.AutoIncrementTable)}, nil
}

type BatchInfoTable interface {
	Insert(ctx context.Context, batchInfo *BatchInfo) error
	InsertReturningID(ctx context.Context, batchInfo *BatchInfo) (uint64, error)
	Update(ctx context.Context, batchInfo *BatchInfo) error
	Save(ctx context.Context, batchInfo *BatchInfo) error
	Delete(ctx context.Context, batchInfo *BatchInfo) error
	Has(ctx context.Context, key uint64) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, key uint64) (*BatchInfo, error)
	HasByDenom(ctx context.Context, denom string) (found bool, err error)
	// GetByDenom returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	GetByDenom(ctx context.Context, denom string) (*BatchInfo, error)
	List(ctx context.Context, prefixKey BatchInfoIndexKey, opts ...ormlist.Option) (BatchInfoIterator, error)
	ListRange(ctx context.Context, from, to BatchInfoIndexKey, opts ...ormlist.Option) (BatchInfoIterator, error)
	DeleteBy(ctx context.Context, prefixKey BatchInfoIndexKey) error
	DeleteRange(ctx context.Context, from, to BatchInfoIndexKey) error

	doNotImplement()
}

type BatchInfoIterator struct {
	ormtable.Iterator
}

func (i BatchInfoIterator) Value() (*BatchInfo, error) {
	var batchInfo BatchInfo
	err := i.UnmarshalMessage(&batchInfo)
	return &batchInfo, err
}

type BatchInfoIndexKey interface {
	id() uint32
	values() []interface{}
	batchInfoIndexKey()
}

// primary key starting index..
type BatchInfoPrimaryKey = BatchInfoKeyIndexKey

type BatchInfoKeyIndexKey struct {
	vs []interface{}
}

func (x BatchInfoKeyIndexKey) id() uint32            { return 0 }
func (x BatchInfoKeyIndexKey) values() []interface{} { return x.vs }
func (x BatchInfoKeyIndexKey) batchInfoIndexKey()    {}

func (this BatchInfoKeyIndexKey) WithKey(key uint64) BatchInfoKeyIndexKey {
	this.vs = []interface{}{key}
	return this
}

type BatchInfoDenomIndexKey struct {
	vs []interface{}
}

func (x BatchInfoDenomIndexKey) id() uint32            { return 1 }
func (x BatchInfoDenomIndexKey) values() []interface{} { return x.vs }
func (x BatchInfoDenomIndexKey) batchInfoIndexKey()    {}

func (this BatchInfoDenomIndexKey) WithDenom(denom string) BatchInfoDenomIndexKey {
	this.vs = []interface{}{denom}
	return this
}

type BatchInfoProjectKeyIndexKey struct {
	vs []interface{}
}

func (x BatchInfoProjectKeyIndexKey) id() uint32            { return 2 }
func (x BatchInfoProjectKeyIndexKey) values() []interface{} { return x.vs }
func (x BatchInfoProjectKeyIndexKey) batchInfoIndexKey()    {}

func (this BatchInfoProjectKeyIndexKey) WithProjectKey(project_key uint64) BatchInfoProjectKeyIndexKey {
	this.vs = []interface{}{project_key}
	return this
}

type BatchInfoStartDateIndexKey struct {
	vs []interface{}
}

func (x BatchInfoStartDateIndexKey) id() uint32            { return 3 }
func (x BatchInfoStartDateIndexKey) values() []interface{} { return x.vs }
func (x BatchInfoStartDateIndexKey) batchInfoIndexKey()    {}

func (this BatchInfoStartDateIndexKey) WithStartDate(start_date *timestamppb.Timestamp) BatchInfoStartDateIndexKey {
	this.vs = []interface{}{start_date}
	return this
}

type BatchInfoIssuerIndexKey struct {
	vs []interface{}
}

func (x BatchInfoIssuerIndexKey) id() uint32            { return 4 }
func (x BatchInfoIssuerIndexKey) values() []interface{} { return x.vs }
func (x BatchInfoIssuerIndexKey) batchInfoIndexKey()    {}

func (this BatchInfoIssuerIndexKey) WithIssuer(issuer []byte) BatchInfoIssuerIndexKey {
	this.vs = []interface{}{issuer}
	return this
}

type batchInfoTable struct {
	table ormtable.AutoIncrementTable
}

func (this batchInfoTable) Insert(ctx context.Context, batchInfo *BatchInfo) error {
	return this.table.Insert(ctx, batchInfo)
}

func (this batchInfoTable) Update(ctx context.Context, batchInfo *BatchInfo) error {
	return this.table.Update(ctx, batchInfo)
}

func (this batchInfoTable) Save(ctx context.Context, batchInfo *BatchInfo) error {
	return this.table.Save(ctx, batchInfo)
}

func (this batchInfoTable) Delete(ctx context.Context, batchInfo *BatchInfo) error {
	return this.table.Delete(ctx, batchInfo)
}

func (this batchInfoTable) InsertReturningID(ctx context.Context, batchInfo *BatchInfo) (uint64, error) {
	return this.table.InsertReturningID(ctx, batchInfo)
}

func (this batchInfoTable) Has(ctx context.Context, key uint64) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, key)
}

func (this batchInfoTable) Get(ctx context.Context, key uint64) (*BatchInfo, error) {
	var batchInfo BatchInfo
	found, err := this.table.PrimaryKey().Get(ctx, &batchInfo, key)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &batchInfo, nil
}

func (this batchInfoTable) HasByDenom(ctx context.Context, denom string) (found bool, err error) {
	return this.table.GetIndexByID(1).(ormtable.UniqueIndex).Has(ctx,
		denom,
	)
}

func (this batchInfoTable) GetByDenom(ctx context.Context, denom string) (*BatchInfo, error) {
	var batchInfo BatchInfo
	found, err := this.table.GetIndexByID(1).(ormtable.UniqueIndex).Get(ctx, &batchInfo,
		denom,
	)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &batchInfo, nil
}

func (this batchInfoTable) List(ctx context.Context, prefixKey BatchInfoIndexKey, opts ...ormlist.Option) (BatchInfoIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return BatchInfoIterator{it}, err
}

func (this batchInfoTable) ListRange(ctx context.Context, from, to BatchInfoIndexKey, opts ...ormlist.Option) (BatchInfoIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return BatchInfoIterator{it}, err
}

func (this batchInfoTable) DeleteBy(ctx context.Context, prefixKey BatchInfoIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this batchInfoTable) DeleteRange(ctx context.Context, from, to BatchInfoIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this batchInfoTable) doNotImplement() {}

var _ BatchInfoTable = batchInfoTable{}

func NewBatchInfoTable(db ormtable.Schema) (BatchInfoTable, error) {
	table := db.GetTable(&BatchInfo{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&BatchInfo{}).ProtoReflect().Descriptor().FullName()))
	}
	return batchInfoTable{table.(ormtable.AutoIncrementTable)}, nil
}

type ClassSequenceTable interface {
	Insert(ctx context.Context, classSequence *ClassSequence) error
	Update(ctx context.Context, classSequence *ClassSequence) error
	Save(ctx context.Context, classSequence *ClassSequence) error
	Delete(ctx context.Context, classSequence *ClassSequence) error
	Has(ctx context.Context, credit_type_abbrev string) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, credit_type_abbrev string) (*ClassSequence, error)
	List(ctx context.Context, prefixKey ClassSequenceIndexKey, opts ...ormlist.Option) (ClassSequenceIterator, error)
	ListRange(ctx context.Context, from, to ClassSequenceIndexKey, opts ...ormlist.Option) (ClassSequenceIterator, error)
	DeleteBy(ctx context.Context, prefixKey ClassSequenceIndexKey) error
	DeleteRange(ctx context.Context, from, to ClassSequenceIndexKey) error

	doNotImplement()
}

type ClassSequenceIterator struct {
	ormtable.Iterator
}

func (i ClassSequenceIterator) Value() (*ClassSequence, error) {
	var classSequence ClassSequence
	err := i.UnmarshalMessage(&classSequence)
	return &classSequence, err
}

type ClassSequenceIndexKey interface {
	id() uint32
	values() []interface{}
	classSequenceIndexKey()
}

// primary key starting index..
type ClassSequencePrimaryKey = ClassSequenceCreditTypeAbbrevIndexKey

type ClassSequenceCreditTypeAbbrevIndexKey struct {
	vs []interface{}
}

func (x ClassSequenceCreditTypeAbbrevIndexKey) id() uint32             { return 0 }
func (x ClassSequenceCreditTypeAbbrevIndexKey) values() []interface{}  { return x.vs }
func (x ClassSequenceCreditTypeAbbrevIndexKey) classSequenceIndexKey() {}

func (this ClassSequenceCreditTypeAbbrevIndexKey) WithCreditTypeAbbrev(credit_type_abbrev string) ClassSequenceCreditTypeAbbrevIndexKey {
	this.vs = []interface{}{credit_type_abbrev}
	return this
}

type classSequenceTable struct {
	table ormtable.Table
}

func (this classSequenceTable) Insert(ctx context.Context, classSequence *ClassSequence) error {
	return this.table.Insert(ctx, classSequence)
}

func (this classSequenceTable) Update(ctx context.Context, classSequence *ClassSequence) error {
	return this.table.Update(ctx, classSequence)
}

func (this classSequenceTable) Save(ctx context.Context, classSequence *ClassSequence) error {
	return this.table.Save(ctx, classSequence)
}

func (this classSequenceTable) Delete(ctx context.Context, classSequence *ClassSequence) error {
	return this.table.Delete(ctx, classSequence)
}

func (this classSequenceTable) Has(ctx context.Context, credit_type_abbrev string) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, credit_type_abbrev)
}

func (this classSequenceTable) Get(ctx context.Context, credit_type_abbrev string) (*ClassSequence, error) {
	var classSequence ClassSequence
	found, err := this.table.PrimaryKey().Get(ctx, &classSequence, credit_type_abbrev)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &classSequence, nil
}

func (this classSequenceTable) List(ctx context.Context, prefixKey ClassSequenceIndexKey, opts ...ormlist.Option) (ClassSequenceIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return ClassSequenceIterator{it}, err
}

func (this classSequenceTable) ListRange(ctx context.Context, from, to ClassSequenceIndexKey, opts ...ormlist.Option) (ClassSequenceIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return ClassSequenceIterator{it}, err
}

func (this classSequenceTable) DeleteBy(ctx context.Context, prefixKey ClassSequenceIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this classSequenceTable) DeleteRange(ctx context.Context, from, to ClassSequenceIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this classSequenceTable) doNotImplement() {}

var _ ClassSequenceTable = classSequenceTable{}

func NewClassSequenceTable(db ormtable.Schema) (ClassSequenceTable, error) {
	table := db.GetTable(&ClassSequence{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&ClassSequence{}).ProtoReflect().Descriptor().FullName()))
	}
	return classSequenceTable{table}, nil
}

type ProjectSequenceTable interface {
	Insert(ctx context.Context, projectSequence *ProjectSequence) error
	Update(ctx context.Context, projectSequence *ProjectSequence) error
	Save(ctx context.Context, projectSequence *ProjectSequence) error
	Delete(ctx context.Context, projectSequence *ProjectSequence) error
	Has(ctx context.Context, class_key uint64) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, class_key uint64) (*ProjectSequence, error)
	List(ctx context.Context, prefixKey ProjectSequenceIndexKey, opts ...ormlist.Option) (ProjectSequenceIterator, error)
	ListRange(ctx context.Context, from, to ProjectSequenceIndexKey, opts ...ormlist.Option) (ProjectSequenceIterator, error)
	DeleteBy(ctx context.Context, prefixKey ProjectSequenceIndexKey) error
	DeleteRange(ctx context.Context, from, to ProjectSequenceIndexKey) error

	doNotImplement()
}

type ProjectSequenceIterator struct {
	ormtable.Iterator
}

func (i ProjectSequenceIterator) Value() (*ProjectSequence, error) {
	var projectSequence ProjectSequence
	err := i.UnmarshalMessage(&projectSequence)
	return &projectSequence, err
}

type ProjectSequenceIndexKey interface {
	id() uint32
	values() []interface{}
	projectSequenceIndexKey()
}

// primary key starting index..
type ProjectSequencePrimaryKey = ProjectSequenceClassKeyIndexKey

type ProjectSequenceClassKeyIndexKey struct {
	vs []interface{}
}

func (x ProjectSequenceClassKeyIndexKey) id() uint32               { return 0 }
func (x ProjectSequenceClassKeyIndexKey) values() []interface{}    { return x.vs }
func (x ProjectSequenceClassKeyIndexKey) projectSequenceIndexKey() {}

func (this ProjectSequenceClassKeyIndexKey) WithClassKey(class_key uint64) ProjectSequenceClassKeyIndexKey {
	this.vs = []interface{}{class_key}
	return this
}

type projectSequenceTable struct {
	table ormtable.Table
}

func (this projectSequenceTable) Insert(ctx context.Context, projectSequence *ProjectSequence) error {
	return this.table.Insert(ctx, projectSequence)
}

func (this projectSequenceTable) Update(ctx context.Context, projectSequence *ProjectSequence) error {
	return this.table.Update(ctx, projectSequence)
}

func (this projectSequenceTable) Save(ctx context.Context, projectSequence *ProjectSequence) error {
	return this.table.Save(ctx, projectSequence)
}

func (this projectSequenceTable) Delete(ctx context.Context, projectSequence *ProjectSequence) error {
	return this.table.Delete(ctx, projectSequence)
}

func (this projectSequenceTable) Has(ctx context.Context, class_key uint64) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, class_key)
}

func (this projectSequenceTable) Get(ctx context.Context, class_key uint64) (*ProjectSequence, error) {
	var projectSequence ProjectSequence
	found, err := this.table.PrimaryKey().Get(ctx, &projectSequence, class_key)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &projectSequence, nil
}

func (this projectSequenceTable) List(ctx context.Context, prefixKey ProjectSequenceIndexKey, opts ...ormlist.Option) (ProjectSequenceIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return ProjectSequenceIterator{it}, err
}

func (this projectSequenceTable) ListRange(ctx context.Context, from, to ProjectSequenceIndexKey, opts ...ormlist.Option) (ProjectSequenceIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return ProjectSequenceIterator{it}, err
}

func (this projectSequenceTable) DeleteBy(ctx context.Context, prefixKey ProjectSequenceIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this projectSequenceTable) DeleteRange(ctx context.Context, from, to ProjectSequenceIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this projectSequenceTable) doNotImplement() {}

var _ ProjectSequenceTable = projectSequenceTable{}

func NewProjectSequenceTable(db ormtable.Schema) (ProjectSequenceTable, error) {
	table := db.GetTable(&ProjectSequence{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&ProjectSequence{}).ProtoReflect().Descriptor().FullName()))
	}
	return projectSequenceTable{table}, nil
}

type BatchSequenceTable interface {
	Insert(ctx context.Context, batchSequence *BatchSequence) error
	Update(ctx context.Context, batchSequence *BatchSequence) error
	Save(ctx context.Context, batchSequence *BatchSequence) error
	Delete(ctx context.Context, batchSequence *BatchSequence) error
	Has(ctx context.Context, project_key uint64) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, project_key uint64) (*BatchSequence, error)
	List(ctx context.Context, prefixKey BatchSequenceIndexKey, opts ...ormlist.Option) (BatchSequenceIterator, error)
	ListRange(ctx context.Context, from, to BatchSequenceIndexKey, opts ...ormlist.Option) (BatchSequenceIterator, error)
	DeleteBy(ctx context.Context, prefixKey BatchSequenceIndexKey) error
	DeleteRange(ctx context.Context, from, to BatchSequenceIndexKey) error

	doNotImplement()
}

type BatchSequenceIterator struct {
	ormtable.Iterator
}

func (i BatchSequenceIterator) Value() (*BatchSequence, error) {
	var batchSequence BatchSequence
	err := i.UnmarshalMessage(&batchSequence)
	return &batchSequence, err
}

type BatchSequenceIndexKey interface {
	id() uint32
	values() []interface{}
	batchSequenceIndexKey()
}

// primary key starting index..
type BatchSequencePrimaryKey = BatchSequenceProjectKeyIndexKey

type BatchSequenceProjectKeyIndexKey struct {
	vs []interface{}
}

func (x BatchSequenceProjectKeyIndexKey) id() uint32             { return 0 }
func (x BatchSequenceProjectKeyIndexKey) values() []interface{}  { return x.vs }
func (x BatchSequenceProjectKeyIndexKey) batchSequenceIndexKey() {}

func (this BatchSequenceProjectKeyIndexKey) WithProjectKey(project_key uint64) BatchSequenceProjectKeyIndexKey {
	this.vs = []interface{}{project_key}
	return this
}

type batchSequenceTable struct {
	table ormtable.Table
}

func (this batchSequenceTable) Insert(ctx context.Context, batchSequence *BatchSequence) error {
	return this.table.Insert(ctx, batchSequence)
}

func (this batchSequenceTable) Update(ctx context.Context, batchSequence *BatchSequence) error {
	return this.table.Update(ctx, batchSequence)
}

func (this batchSequenceTable) Save(ctx context.Context, batchSequence *BatchSequence) error {
	return this.table.Save(ctx, batchSequence)
}

func (this batchSequenceTable) Delete(ctx context.Context, batchSequence *BatchSequence) error {
	return this.table.Delete(ctx, batchSequence)
}

func (this batchSequenceTable) Has(ctx context.Context, project_key uint64) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, project_key)
}

func (this batchSequenceTable) Get(ctx context.Context, project_key uint64) (*BatchSequence, error) {
	var batchSequence BatchSequence
	found, err := this.table.PrimaryKey().Get(ctx, &batchSequence, project_key)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &batchSequence, nil
}

func (this batchSequenceTable) List(ctx context.Context, prefixKey BatchSequenceIndexKey, opts ...ormlist.Option) (BatchSequenceIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return BatchSequenceIterator{it}, err
}

func (this batchSequenceTable) ListRange(ctx context.Context, from, to BatchSequenceIndexKey, opts ...ormlist.Option) (BatchSequenceIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return BatchSequenceIterator{it}, err
}

func (this batchSequenceTable) DeleteBy(ctx context.Context, prefixKey BatchSequenceIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this batchSequenceTable) DeleteRange(ctx context.Context, from, to BatchSequenceIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this batchSequenceTable) doNotImplement() {}

var _ BatchSequenceTable = batchSequenceTable{}

func NewBatchSequenceTable(db ormtable.Schema) (BatchSequenceTable, error) {
	table := db.GetTable(&BatchSequence{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&BatchSequence{}).ProtoReflect().Descriptor().FullName()))
	}
	return batchSequenceTable{table}, nil
}

type BatchBalanceTable interface {
	Insert(ctx context.Context, batchBalance *BatchBalance) error
	Update(ctx context.Context, batchBalance *BatchBalance) error
	Save(ctx context.Context, batchBalance *BatchBalance) error
	Delete(ctx context.Context, batchBalance *BatchBalance) error
	Has(ctx context.Context, address []byte, batch_key uint64) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, address []byte, batch_key uint64) (*BatchBalance, error)
	List(ctx context.Context, prefixKey BatchBalanceIndexKey, opts ...ormlist.Option) (BatchBalanceIterator, error)
	ListRange(ctx context.Context, from, to BatchBalanceIndexKey, opts ...ormlist.Option) (BatchBalanceIterator, error)
	DeleteBy(ctx context.Context, prefixKey BatchBalanceIndexKey) error
	DeleteRange(ctx context.Context, from, to BatchBalanceIndexKey) error

	doNotImplement()
}

type BatchBalanceIterator struct {
	ormtable.Iterator
}

func (i BatchBalanceIterator) Value() (*BatchBalance, error) {
	var batchBalance BatchBalance
	err := i.UnmarshalMessage(&batchBalance)
	return &batchBalance, err
}

type BatchBalanceIndexKey interface {
	id() uint32
	values() []interface{}
	batchBalanceIndexKey()
}

// primary key starting index..
type BatchBalancePrimaryKey = BatchBalanceAddressBatchKeyIndexKey

type BatchBalanceAddressBatchKeyIndexKey struct {
	vs []interface{}
}

func (x BatchBalanceAddressBatchKeyIndexKey) id() uint32            { return 0 }
func (x BatchBalanceAddressBatchKeyIndexKey) values() []interface{} { return x.vs }
func (x BatchBalanceAddressBatchKeyIndexKey) batchBalanceIndexKey() {}

func (this BatchBalanceAddressBatchKeyIndexKey) WithAddress(address []byte) BatchBalanceAddressBatchKeyIndexKey {
	this.vs = []interface{}{address}
	return this
}

func (this BatchBalanceAddressBatchKeyIndexKey) WithAddressBatchKey(address []byte, batch_key uint64) BatchBalanceAddressBatchKeyIndexKey {
	this.vs = []interface{}{address, batch_key}
	return this
}

type BatchBalanceBatchKeyAddressIndexKey struct {
	vs []interface{}
}

func (x BatchBalanceBatchKeyAddressIndexKey) id() uint32            { return 1 }
func (x BatchBalanceBatchKeyAddressIndexKey) values() []interface{} { return x.vs }
func (x BatchBalanceBatchKeyAddressIndexKey) batchBalanceIndexKey() {}

func (this BatchBalanceBatchKeyAddressIndexKey) WithBatchKey(batch_key uint64) BatchBalanceBatchKeyAddressIndexKey {
	this.vs = []interface{}{batch_key}
	return this
}

func (this BatchBalanceBatchKeyAddressIndexKey) WithBatchKeyAddress(batch_key uint64, address []byte) BatchBalanceBatchKeyAddressIndexKey {
	this.vs = []interface{}{batch_key, address}
	return this
}

type batchBalanceTable struct {
	table ormtable.Table
}

func (this batchBalanceTable) Insert(ctx context.Context, batchBalance *BatchBalance) error {
	return this.table.Insert(ctx, batchBalance)
}

func (this batchBalanceTable) Update(ctx context.Context, batchBalance *BatchBalance) error {
	return this.table.Update(ctx, batchBalance)
}

func (this batchBalanceTable) Save(ctx context.Context, batchBalance *BatchBalance) error {
	return this.table.Save(ctx, batchBalance)
}

func (this batchBalanceTable) Delete(ctx context.Context, batchBalance *BatchBalance) error {
	return this.table.Delete(ctx, batchBalance)
}

func (this batchBalanceTable) Has(ctx context.Context, address []byte, batch_key uint64) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, address, batch_key)
}

func (this batchBalanceTable) Get(ctx context.Context, address []byte, batch_key uint64) (*BatchBalance, error) {
	var batchBalance BatchBalance
	found, err := this.table.PrimaryKey().Get(ctx, &batchBalance, address, batch_key)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &batchBalance, nil
}

func (this batchBalanceTable) List(ctx context.Context, prefixKey BatchBalanceIndexKey, opts ...ormlist.Option) (BatchBalanceIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return BatchBalanceIterator{it}, err
}

func (this batchBalanceTable) ListRange(ctx context.Context, from, to BatchBalanceIndexKey, opts ...ormlist.Option) (BatchBalanceIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return BatchBalanceIterator{it}, err
}

func (this batchBalanceTable) DeleteBy(ctx context.Context, prefixKey BatchBalanceIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this batchBalanceTable) DeleteRange(ctx context.Context, from, to BatchBalanceIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this batchBalanceTable) doNotImplement() {}

var _ BatchBalanceTable = batchBalanceTable{}

func NewBatchBalanceTable(db ormtable.Schema) (BatchBalanceTable, error) {
	table := db.GetTable(&BatchBalance{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&BatchBalance{}).ProtoReflect().Descriptor().FullName()))
	}
	return batchBalanceTable{table}, nil
}

type BatchSupplyTable interface {
	Insert(ctx context.Context, batchSupply *BatchSupply) error
	Update(ctx context.Context, batchSupply *BatchSupply) error
	Save(ctx context.Context, batchSupply *BatchSupply) error
	Delete(ctx context.Context, batchSupply *BatchSupply) error
	Has(ctx context.Context, batch_key uint64) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, batch_key uint64) (*BatchSupply, error)
	List(ctx context.Context, prefixKey BatchSupplyIndexKey, opts ...ormlist.Option) (BatchSupplyIterator, error)
	ListRange(ctx context.Context, from, to BatchSupplyIndexKey, opts ...ormlist.Option) (BatchSupplyIterator, error)
	DeleteBy(ctx context.Context, prefixKey BatchSupplyIndexKey) error
	DeleteRange(ctx context.Context, from, to BatchSupplyIndexKey) error

	doNotImplement()
}

type BatchSupplyIterator struct {
	ormtable.Iterator
}

func (i BatchSupplyIterator) Value() (*BatchSupply, error) {
	var batchSupply BatchSupply
	err := i.UnmarshalMessage(&batchSupply)
	return &batchSupply, err
}

type BatchSupplyIndexKey interface {
	id() uint32
	values() []interface{}
	batchSupplyIndexKey()
}

// primary key starting index..
type BatchSupplyPrimaryKey = BatchSupplyBatchKeyIndexKey

type BatchSupplyBatchKeyIndexKey struct {
	vs []interface{}
}

func (x BatchSupplyBatchKeyIndexKey) id() uint32            { return 0 }
func (x BatchSupplyBatchKeyIndexKey) values() []interface{} { return x.vs }
func (x BatchSupplyBatchKeyIndexKey) batchSupplyIndexKey()  {}

func (this BatchSupplyBatchKeyIndexKey) WithBatchKey(batch_key uint64) BatchSupplyBatchKeyIndexKey {
	this.vs = []interface{}{batch_key}
	return this
}

type batchSupplyTable struct {
	table ormtable.Table
}

func (this batchSupplyTable) Insert(ctx context.Context, batchSupply *BatchSupply) error {
	return this.table.Insert(ctx, batchSupply)
}

func (this batchSupplyTable) Update(ctx context.Context, batchSupply *BatchSupply) error {
	return this.table.Update(ctx, batchSupply)
}

func (this batchSupplyTable) Save(ctx context.Context, batchSupply *BatchSupply) error {
	return this.table.Save(ctx, batchSupply)
}

func (this batchSupplyTable) Delete(ctx context.Context, batchSupply *BatchSupply) error {
	return this.table.Delete(ctx, batchSupply)
}

func (this batchSupplyTable) Has(ctx context.Context, batch_key uint64) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, batch_key)
}

func (this batchSupplyTable) Get(ctx context.Context, batch_key uint64) (*BatchSupply, error) {
	var batchSupply BatchSupply
	found, err := this.table.PrimaryKey().Get(ctx, &batchSupply, batch_key)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &batchSupply, nil
}

func (this batchSupplyTable) List(ctx context.Context, prefixKey BatchSupplyIndexKey, opts ...ormlist.Option) (BatchSupplyIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return BatchSupplyIterator{it}, err
}

func (this batchSupplyTable) ListRange(ctx context.Context, from, to BatchSupplyIndexKey, opts ...ormlist.Option) (BatchSupplyIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return BatchSupplyIterator{it}, err
}

func (this batchSupplyTable) DeleteBy(ctx context.Context, prefixKey BatchSupplyIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this batchSupplyTable) DeleteRange(ctx context.Context, from, to BatchSupplyIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this batchSupplyTable) doNotImplement() {}

var _ BatchSupplyTable = batchSupplyTable{}

func NewBatchSupplyTable(db ormtable.Schema) (BatchSupplyTable, error) {
	table := db.GetTable(&BatchSupply{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&BatchSupply{}).ProtoReflect().Descriptor().FullName()))
	}
	return batchSupplyTable{table}, nil
}

type BatchOrigTxTable interface {
	Insert(ctx context.Context, batchOrigTx *BatchOrigTx) error
	Update(ctx context.Context, batchOrigTx *BatchOrigTx) error
	Save(ctx context.Context, batchOrigTx *BatchOrigTx) error
	Delete(ctx context.Context, batchOrigTx *BatchOrigTx) error
	Has(ctx context.Context, tx_id string) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, tx_id string) (*BatchOrigTx, error)
	List(ctx context.Context, prefixKey BatchOrigTxIndexKey, opts ...ormlist.Option) (BatchOrigTxIterator, error)
	ListRange(ctx context.Context, from, to BatchOrigTxIndexKey, opts ...ormlist.Option) (BatchOrigTxIterator, error)
	DeleteBy(ctx context.Context, prefixKey BatchOrigTxIndexKey) error
	DeleteRange(ctx context.Context, from, to BatchOrigTxIndexKey) error

	doNotImplement()
}

type BatchOrigTxIterator struct {
	ormtable.Iterator
}

func (i BatchOrigTxIterator) Value() (*BatchOrigTx, error) {
	var batchOrigTx BatchOrigTx
	err := i.UnmarshalMessage(&batchOrigTx)
	return &batchOrigTx, err
}

type BatchOrigTxIndexKey interface {
	id() uint32
	values() []interface{}
	batchOrigTxIndexKey()
}

// primary key starting index..
type BatchOrigTxPrimaryKey = BatchOrigTxTxIdIndexKey

type BatchOrigTxTxIdIndexKey struct {
	vs []interface{}
}

func (x BatchOrigTxTxIdIndexKey) id() uint32            { return 0 }
func (x BatchOrigTxTxIdIndexKey) values() []interface{} { return x.vs }
func (x BatchOrigTxTxIdIndexKey) batchOrigTxIndexKey()  {}

func (this BatchOrigTxTxIdIndexKey) WithTxId(tx_id string) BatchOrigTxTxIdIndexKey {
	this.vs = []interface{}{tx_id}
	return this
}

type batchOrigTxTable struct {
	table ormtable.Table
}

func (this batchOrigTxTable) Insert(ctx context.Context, batchOrigTx *BatchOrigTx) error {
	return this.table.Insert(ctx, batchOrigTx)
}

func (this batchOrigTxTable) Update(ctx context.Context, batchOrigTx *BatchOrigTx) error {
	return this.table.Update(ctx, batchOrigTx)
}

func (this batchOrigTxTable) Save(ctx context.Context, batchOrigTx *BatchOrigTx) error {
	return this.table.Save(ctx, batchOrigTx)
}

func (this batchOrigTxTable) Delete(ctx context.Context, batchOrigTx *BatchOrigTx) error {
	return this.table.Delete(ctx, batchOrigTx)
}

func (this batchOrigTxTable) Has(ctx context.Context, tx_id string) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, tx_id)
}

func (this batchOrigTxTable) Get(ctx context.Context, tx_id string) (*BatchOrigTx, error) {
	var batchOrigTx BatchOrigTx
	found, err := this.table.PrimaryKey().Get(ctx, &batchOrigTx, tx_id)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &batchOrigTx, nil
}

func (this batchOrigTxTable) List(ctx context.Context, prefixKey BatchOrigTxIndexKey, opts ...ormlist.Option) (BatchOrigTxIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return BatchOrigTxIterator{it}, err
}

func (this batchOrigTxTable) ListRange(ctx context.Context, from, to BatchOrigTxIndexKey, opts ...ormlist.Option) (BatchOrigTxIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return BatchOrigTxIterator{it}, err
}

func (this batchOrigTxTable) DeleteBy(ctx context.Context, prefixKey BatchOrigTxIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this batchOrigTxTable) DeleteRange(ctx context.Context, from, to BatchOrigTxIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this batchOrigTxTable) doNotImplement() {}

var _ BatchOrigTxTable = batchOrigTxTable{}

func NewBatchOrigTxTable(db ormtable.Schema) (BatchOrigTxTable, error) {
	table := db.GetTable(&BatchOrigTx{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&BatchOrigTx{}).ProtoReflect().Descriptor().FullName()))
	}
	return batchOrigTxTable{table}, nil
}

type StateStore interface {
	CreditTypeTable() CreditTypeTable
	ClassInfoTable() ClassInfoTable
	ClassIssuerTable() ClassIssuerTable
	ProjectInfoTable() ProjectInfoTable
	BatchInfoTable() BatchInfoTable
	ClassSequenceTable() ClassSequenceTable
	ProjectSequenceTable() ProjectSequenceTable
	BatchSequenceTable() BatchSequenceTable
	BatchBalanceTable() BatchBalanceTable
	BatchSupplyTable() BatchSupplyTable
	BatchOrigTxTable() BatchOrigTxTable

	doNotImplement()
}

type stateStore struct {
	creditType      CreditTypeTable
	classInfo       ClassInfoTable
	classIssuer     ClassIssuerTable
	projectInfo     ProjectInfoTable
	batchInfo       BatchInfoTable
	classSequence   ClassSequenceTable
	projectSequence ProjectSequenceTable
	batchSequence   BatchSequenceTable
	batchBalance    BatchBalanceTable
	batchSupply     BatchSupplyTable
	batchOrigTx     BatchOrigTxTable
}

func (x stateStore) CreditTypeTable() CreditTypeTable {
	return x.creditType
}

func (x stateStore) ClassInfoTable() ClassInfoTable {
	return x.classInfo
}

func (x stateStore) ClassIssuerTable() ClassIssuerTable {
	return x.classIssuer
}

func (x stateStore) ProjectInfoTable() ProjectInfoTable {
	return x.projectInfo
}

func (x stateStore) BatchInfoTable() BatchInfoTable {
	return x.batchInfo
}

func (x stateStore) ClassSequenceTable() ClassSequenceTable {
	return x.classSequence
}

func (x stateStore) ProjectSequenceTable() ProjectSequenceTable {
	return x.projectSequence
}

func (x stateStore) BatchSequenceTable() BatchSequenceTable {
	return x.batchSequence
}

func (x stateStore) BatchBalanceTable() BatchBalanceTable {
	return x.batchBalance
}

func (x stateStore) BatchSupplyTable() BatchSupplyTable {
	return x.batchSupply
}

func (x stateStore) BatchOrigTxTable() BatchOrigTxTable {
	return x.batchOrigTx
}

func (stateStore) doNotImplement() {}

var _ StateStore = stateStore{}

func NewStateStore(db ormtable.Schema) (StateStore, error) {
	creditTypeTable, err := NewCreditTypeTable(db)
	if err != nil {
		return nil, err
	}

	classInfoTable, err := NewClassInfoTable(db)
	if err != nil {
		return nil, err
	}

	classIssuerTable, err := NewClassIssuerTable(db)
	if err != nil {
		return nil, err
	}

	projectInfoTable, err := NewProjectInfoTable(db)
	if err != nil {
		return nil, err
	}

	batchInfoTable, err := NewBatchInfoTable(db)
	if err != nil {
		return nil, err
	}

	classSequenceTable, err := NewClassSequenceTable(db)
	if err != nil {
		return nil, err
	}

	projectSequenceTable, err := NewProjectSequenceTable(db)
	if err != nil {
		return nil, err
	}

	batchSequenceTable, err := NewBatchSequenceTable(db)
	if err != nil {
		return nil, err
	}

	batchBalanceTable, err := NewBatchBalanceTable(db)
	if err != nil {
		return nil, err
	}

	batchSupplyTable, err := NewBatchSupplyTable(db)
	if err != nil {
		return nil, err
	}

	batchOrigTxTable, err := NewBatchOrigTxTable(db)
	if err != nil {
		return nil, err
	}

	return stateStore{
		creditTypeTable,
		classInfoTable,
		classIssuerTable,
		projectInfoTable,
		batchInfoTable,
		classSequenceTable,
		projectSequenceTable,
		batchSequenceTable,
		batchBalanceTable,
		batchSupplyTable,
		batchOrigTxTable,
	}, nil
}
