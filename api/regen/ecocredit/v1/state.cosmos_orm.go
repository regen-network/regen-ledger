// Code generated by protoc-gen-go-cosmos-orm. DO NOT EDIT.

package ecocreditv1

import (
	context "context"
	ormlist "github.com/cosmos/cosmos-sdk/orm/model/ormlist"
	ormtable "github.com/cosmos/cosmos-sdk/orm/model/ormtable"
	ormerrors "github.com/cosmos/cosmos-sdk/orm/types/ormerrors"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

type CreditTypeTable interface {
	Insert(ctx context.Context, creditType *CreditType) error
	Update(ctx context.Context, creditType *CreditType) error
	Save(ctx context.Context, creditType *CreditType) error
	Delete(ctx context.Context, creditType *CreditType) error
	Has(ctx context.Context, abbreviation string) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, abbreviation string) (*CreditType, error)
	HasByName(ctx context.Context, name string) (found bool, err error)
	// GetByName returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	GetByName(ctx context.Context, name string) (*CreditType, error)
	List(ctx context.Context, prefixKey CreditTypeIndexKey, opts ...ormlist.Option) (CreditTypeIterator, error)
	ListRange(ctx context.Context, from, to CreditTypeIndexKey, opts ...ormlist.Option) (CreditTypeIterator, error)
	DeleteBy(ctx context.Context, prefixKey CreditTypeIndexKey) error
	DeleteRange(ctx context.Context, from, to CreditTypeIndexKey) error

	doNotImplement()
}

type CreditTypeIterator struct {
	ormtable.Iterator
}

func (i CreditTypeIterator) Value() (*CreditType, error) {
	var creditType CreditType
	err := i.UnmarshalMessage(&creditType)
	return &creditType, err
}

type CreditTypeIndexKey interface {
	id() uint32
	values() []interface{}
	creditTypeIndexKey()
}

// primary key starting index..
type CreditTypePrimaryKey = CreditTypeAbbreviationIndexKey

type CreditTypeAbbreviationIndexKey struct {
	vs []interface{}
}

func (x CreditTypeAbbreviationIndexKey) id() uint32            { return 0 }
func (x CreditTypeAbbreviationIndexKey) values() []interface{} { return x.vs }
func (x CreditTypeAbbreviationIndexKey) creditTypeIndexKey()   {}

func (this CreditTypeAbbreviationIndexKey) WithAbbreviation(abbreviation string) CreditTypeAbbreviationIndexKey {
	this.vs = []interface{}{abbreviation}
	return this
}

type CreditTypeNameIndexKey struct {
	vs []interface{}
}

func (x CreditTypeNameIndexKey) id() uint32            { return 1 }
func (x CreditTypeNameIndexKey) values() []interface{} { return x.vs }
func (x CreditTypeNameIndexKey) creditTypeIndexKey()   {}

func (this CreditTypeNameIndexKey) WithName(name string) CreditTypeNameIndexKey {
	this.vs = []interface{}{name}
	return this
}

type creditTypeTable struct {
	table ormtable.Table
}

func (this creditTypeTable) Insert(ctx context.Context, creditType *CreditType) error {
	return this.table.Insert(ctx, creditType)
}

func (this creditTypeTable) Update(ctx context.Context, creditType *CreditType) error {
	return this.table.Update(ctx, creditType)
}

func (this creditTypeTable) Save(ctx context.Context, creditType *CreditType) error {
	return this.table.Save(ctx, creditType)
}

func (this creditTypeTable) Delete(ctx context.Context, creditType *CreditType) error {
	return this.table.Delete(ctx, creditType)
}

func (this creditTypeTable) Has(ctx context.Context, abbreviation string) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, abbreviation)
}

func (this creditTypeTable) Get(ctx context.Context, abbreviation string) (*CreditType, error) {
	var creditType CreditType
	found, err := this.table.PrimaryKey().Get(ctx, &creditType, abbreviation)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &creditType, nil
}

func (this creditTypeTable) HasByName(ctx context.Context, name string) (found bool, err error) {
	return this.table.GetIndexByID(1).(ormtable.UniqueIndex).Has(ctx,
		name,
	)
}

func (this creditTypeTable) GetByName(ctx context.Context, name string) (*CreditType, error) {
	var creditType CreditType
	found, err := this.table.GetIndexByID(1).(ormtable.UniqueIndex).Get(ctx, &creditType,
		name,
	)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &creditType, nil
}

func (this creditTypeTable) List(ctx context.Context, prefixKey CreditTypeIndexKey, opts ...ormlist.Option) (CreditTypeIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return CreditTypeIterator{it}, err
}

func (this creditTypeTable) ListRange(ctx context.Context, from, to CreditTypeIndexKey, opts ...ormlist.Option) (CreditTypeIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return CreditTypeIterator{it}, err
}

func (this creditTypeTable) DeleteBy(ctx context.Context, prefixKey CreditTypeIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this creditTypeTable) DeleteRange(ctx context.Context, from, to CreditTypeIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this creditTypeTable) doNotImplement() {}

var _ CreditTypeTable = creditTypeTable{}

func NewCreditTypeTable(db ormtable.Schema) (CreditTypeTable, error) {
	table := db.GetTable(&CreditType{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&CreditType{}).ProtoReflect().Descriptor().FullName()))
	}
	return creditTypeTable{table}, nil
}

type ClassTable interface {
	Insert(ctx context.Context, class *Class) error
	InsertReturningID(ctx context.Context, class *Class) (uint64, error)
	Update(ctx context.Context, class *Class) error
	Save(ctx context.Context, class *Class) error
	Delete(ctx context.Context, class *Class) error
	Has(ctx context.Context, key uint64) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, key uint64) (*Class, error)
	HasById(ctx context.Context, id string) (found bool, err error)
	// GetById returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	GetById(ctx context.Context, id string) (*Class, error)
	List(ctx context.Context, prefixKey ClassIndexKey, opts ...ormlist.Option) (ClassIterator, error)
	ListRange(ctx context.Context, from, to ClassIndexKey, opts ...ormlist.Option) (ClassIterator, error)
	DeleteBy(ctx context.Context, prefixKey ClassIndexKey) error
	DeleteRange(ctx context.Context, from, to ClassIndexKey) error

	doNotImplement()
}

type ClassIterator struct {
	ormtable.Iterator
}

func (i ClassIterator) Value() (*Class, error) {
	var class Class
	err := i.UnmarshalMessage(&class)
	return &class, err
}

type ClassIndexKey interface {
	id() uint32
	values() []interface{}
	classIndexKey()
}

// primary key starting index..
type ClassPrimaryKey = ClassKeyIndexKey

type ClassKeyIndexKey struct {
	vs []interface{}
}

func (x ClassKeyIndexKey) id() uint32            { return 0 }
func (x ClassKeyIndexKey) values() []interface{} { return x.vs }
func (x ClassKeyIndexKey) classIndexKey()        {}

func (this ClassKeyIndexKey) WithKey(key uint64) ClassKeyIndexKey {
	this.vs = []interface{}{key}
	return this
}

type ClassIdIndexKey struct {
	vs []interface{}
}

func (x ClassIdIndexKey) id() uint32            { return 1 }
func (x ClassIdIndexKey) values() []interface{} { return x.vs }
func (x ClassIdIndexKey) classIndexKey()        {}

func (this ClassIdIndexKey) WithId(id string) ClassIdIndexKey {
	this.vs = []interface{}{id}
	return this
}

type ClassAdminIndexKey struct {
	vs []interface{}
}

func (x ClassAdminIndexKey) id() uint32            { return 2 }
func (x ClassAdminIndexKey) values() []interface{} { return x.vs }
func (x ClassAdminIndexKey) classIndexKey()        {}

func (this ClassAdminIndexKey) WithAdmin(admin []byte) ClassAdminIndexKey {
	this.vs = []interface{}{admin}
	return this
}

type ClassCreditTypeAbbrevIndexKey struct {
	vs []interface{}
}

func (x ClassCreditTypeAbbrevIndexKey) id() uint32            { return 3 }
func (x ClassCreditTypeAbbrevIndexKey) values() []interface{} { return x.vs }
func (x ClassCreditTypeAbbrevIndexKey) classIndexKey()        {}

func (this ClassCreditTypeAbbrevIndexKey) WithCreditTypeAbbrev(credit_type_abbrev string) ClassCreditTypeAbbrevIndexKey {
	this.vs = []interface{}{credit_type_abbrev}
	return this
}

type classTable struct {
	table ormtable.AutoIncrementTable
}

func (this classTable) Insert(ctx context.Context, class *Class) error {
	return this.table.Insert(ctx, class)
}

func (this classTable) Update(ctx context.Context, class *Class) error {
	return this.table.Update(ctx, class)
}

func (this classTable) Save(ctx context.Context, class *Class) error {
	return this.table.Save(ctx, class)
}

func (this classTable) Delete(ctx context.Context, class *Class) error {
	return this.table.Delete(ctx, class)
}

func (this classTable) InsertReturningID(ctx context.Context, class *Class) (uint64, error) {
	return this.table.InsertReturningID(ctx, class)
}

func (this classTable) Has(ctx context.Context, key uint64) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, key)
}

func (this classTable) Get(ctx context.Context, key uint64) (*Class, error) {
	var class Class
	found, err := this.table.PrimaryKey().Get(ctx, &class, key)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &class, nil
}

func (this classTable) HasById(ctx context.Context, id string) (found bool, err error) {
	return this.table.GetIndexByID(1).(ormtable.UniqueIndex).Has(ctx,
		id,
	)
}

func (this classTable) GetById(ctx context.Context, id string) (*Class, error) {
	var class Class
	found, err := this.table.GetIndexByID(1).(ormtable.UniqueIndex).Get(ctx, &class,
		id,
	)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &class, nil
}

func (this classTable) List(ctx context.Context, prefixKey ClassIndexKey, opts ...ormlist.Option) (ClassIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return ClassIterator{it}, err
}

func (this classTable) ListRange(ctx context.Context, from, to ClassIndexKey, opts ...ormlist.Option) (ClassIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return ClassIterator{it}, err
}

func (this classTable) DeleteBy(ctx context.Context, prefixKey ClassIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this classTable) DeleteRange(ctx context.Context, from, to ClassIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this classTable) doNotImplement() {}

var _ ClassTable = classTable{}

func NewClassTable(db ormtable.Schema) (ClassTable, error) {
	table := db.GetTable(&Class{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&Class{}).ProtoReflect().Descriptor().FullName()))
	}
	return classTable{table.(ormtable.AutoIncrementTable)}, nil
}

type ClassIssuerTable interface {
	Insert(ctx context.Context, classIssuer *ClassIssuer) error
	Update(ctx context.Context, classIssuer *ClassIssuer) error
	Save(ctx context.Context, classIssuer *ClassIssuer) error
	Delete(ctx context.Context, classIssuer *ClassIssuer) error
	Has(ctx context.Context, class_key uint64, issuer []byte) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, class_key uint64, issuer []byte) (*ClassIssuer, error)
	List(ctx context.Context, prefixKey ClassIssuerIndexKey, opts ...ormlist.Option) (ClassIssuerIterator, error)
	ListRange(ctx context.Context, from, to ClassIssuerIndexKey, opts ...ormlist.Option) (ClassIssuerIterator, error)
	DeleteBy(ctx context.Context, prefixKey ClassIssuerIndexKey) error
	DeleteRange(ctx context.Context, from, to ClassIssuerIndexKey) error

	doNotImplement()
}

type ClassIssuerIterator struct {
	ormtable.Iterator
}

func (i ClassIssuerIterator) Value() (*ClassIssuer, error) {
	var classIssuer ClassIssuer
	err := i.UnmarshalMessage(&classIssuer)
	return &classIssuer, err
}

type ClassIssuerIndexKey interface {
	id() uint32
	values() []interface{}
	classIssuerIndexKey()
}

// primary key starting index..
type ClassIssuerPrimaryKey = ClassIssuerClassKeyIssuerIndexKey

type ClassIssuerClassKeyIssuerIndexKey struct {
	vs []interface{}
}

func (x ClassIssuerClassKeyIssuerIndexKey) id() uint32            { return 0 }
func (x ClassIssuerClassKeyIssuerIndexKey) values() []interface{} { return x.vs }
func (x ClassIssuerClassKeyIssuerIndexKey) classIssuerIndexKey()  {}

func (this ClassIssuerClassKeyIssuerIndexKey) WithClassKey(class_key uint64) ClassIssuerClassKeyIssuerIndexKey {
	this.vs = []interface{}{class_key}
	return this
}

func (this ClassIssuerClassKeyIssuerIndexKey) WithClassKeyIssuer(class_key uint64, issuer []byte) ClassIssuerClassKeyIssuerIndexKey {
	this.vs = []interface{}{class_key, issuer}
	return this
}

type classIssuerTable struct {
	table ormtable.Table
}

func (this classIssuerTable) Insert(ctx context.Context, classIssuer *ClassIssuer) error {
	return this.table.Insert(ctx, classIssuer)
}

func (this classIssuerTable) Update(ctx context.Context, classIssuer *ClassIssuer) error {
	return this.table.Update(ctx, classIssuer)
}

func (this classIssuerTable) Save(ctx context.Context, classIssuer *ClassIssuer) error {
	return this.table.Save(ctx, classIssuer)
}

func (this classIssuerTable) Delete(ctx context.Context, classIssuer *ClassIssuer) error {
	return this.table.Delete(ctx, classIssuer)
}

func (this classIssuerTable) Has(ctx context.Context, class_key uint64, issuer []byte) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, class_key, issuer)
}

func (this classIssuerTable) Get(ctx context.Context, class_key uint64, issuer []byte) (*ClassIssuer, error) {
	var classIssuer ClassIssuer
	found, err := this.table.PrimaryKey().Get(ctx, &classIssuer, class_key, issuer)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &classIssuer, nil
}

func (this classIssuerTable) List(ctx context.Context, prefixKey ClassIssuerIndexKey, opts ...ormlist.Option) (ClassIssuerIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return ClassIssuerIterator{it}, err
}

func (this classIssuerTable) ListRange(ctx context.Context, from, to ClassIssuerIndexKey, opts ...ormlist.Option) (ClassIssuerIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return ClassIssuerIterator{it}, err
}

func (this classIssuerTable) DeleteBy(ctx context.Context, prefixKey ClassIssuerIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this classIssuerTable) DeleteRange(ctx context.Context, from, to ClassIssuerIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this classIssuerTable) doNotImplement() {}

var _ ClassIssuerTable = classIssuerTable{}

func NewClassIssuerTable(db ormtable.Schema) (ClassIssuerTable, error) {
	table := db.GetTable(&ClassIssuer{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&ClassIssuer{}).ProtoReflect().Descriptor().FullName()))
	}
	return classIssuerTable{table}, nil
}

type ProjectTable interface {
	Insert(ctx context.Context, project *Project) error
	InsertReturningID(ctx context.Context, project *Project) (uint64, error)
	Update(ctx context.Context, project *Project) error
	Save(ctx context.Context, project *Project) error
	Delete(ctx context.Context, project *Project) error
	Has(ctx context.Context, key uint64) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, key uint64) (*Project, error)
	HasById(ctx context.Context, id string) (found bool, err error)
	// GetById returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	GetById(ctx context.Context, id string) (*Project, error)
	HasByClassKeyId(ctx context.Context, class_key uint64, id string) (found bool, err error)
	// GetByClassKeyId returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	GetByClassKeyId(ctx context.Context, class_key uint64, id string) (*Project, error)
	List(ctx context.Context, prefixKey ProjectIndexKey, opts ...ormlist.Option) (ProjectIterator, error)
	ListRange(ctx context.Context, from, to ProjectIndexKey, opts ...ormlist.Option) (ProjectIterator, error)
	DeleteBy(ctx context.Context, prefixKey ProjectIndexKey) error
	DeleteRange(ctx context.Context, from, to ProjectIndexKey) error

	doNotImplement()
}

type ProjectIterator struct {
	ormtable.Iterator
}

func (i ProjectIterator) Value() (*Project, error) {
	var project Project
	err := i.UnmarshalMessage(&project)
	return &project, err
}

type ProjectIndexKey interface {
	id() uint32
	values() []interface{}
	projectIndexKey()
}

// primary key starting index..
type ProjectPrimaryKey = ProjectKeyIndexKey

type ProjectKeyIndexKey struct {
	vs []interface{}
}

func (x ProjectKeyIndexKey) id() uint32            { return 0 }
func (x ProjectKeyIndexKey) values() []interface{} { return x.vs }
func (x ProjectKeyIndexKey) projectIndexKey()      {}

func (this ProjectKeyIndexKey) WithKey(key uint64) ProjectKeyIndexKey {
	this.vs = []interface{}{key}
	return this
}

type ProjectIdIndexKey struct {
	vs []interface{}
}

func (x ProjectIdIndexKey) id() uint32            { return 1 }
func (x ProjectIdIndexKey) values() []interface{} { return x.vs }
func (x ProjectIdIndexKey) projectIndexKey()      {}

func (this ProjectIdIndexKey) WithId(id string) ProjectIdIndexKey {
	this.vs = []interface{}{id}
	return this
}

type ProjectClassKeyIdIndexKey struct {
	vs []interface{}
}

func (x ProjectClassKeyIdIndexKey) id() uint32            { return 2 }
func (x ProjectClassKeyIdIndexKey) values() []interface{} { return x.vs }
func (x ProjectClassKeyIdIndexKey) projectIndexKey()      {}

func (this ProjectClassKeyIdIndexKey) WithClassKey(class_key uint64) ProjectClassKeyIdIndexKey {
	this.vs = []interface{}{class_key}
	return this
}

func (this ProjectClassKeyIdIndexKey) WithClassKeyId(class_key uint64, id string) ProjectClassKeyIdIndexKey {
	this.vs = []interface{}{class_key, id}
	return this
}

type ProjectAdminIndexKey struct {
	vs []interface{}
}

func (x ProjectAdminIndexKey) id() uint32            { return 3 }
func (x ProjectAdminIndexKey) values() []interface{} { return x.vs }
func (x ProjectAdminIndexKey) projectIndexKey()      {}

func (this ProjectAdminIndexKey) WithAdmin(admin []byte) ProjectAdminIndexKey {
	this.vs = []interface{}{admin}
	return this
}

type ProjectReferenceIdIndexKey struct {
	vs []interface{}
}

func (x ProjectReferenceIdIndexKey) id() uint32            { return 4 }
func (x ProjectReferenceIdIndexKey) values() []interface{} { return x.vs }
func (x ProjectReferenceIdIndexKey) projectIndexKey()      {}

func (this ProjectReferenceIdIndexKey) WithReferenceId(reference_id string) ProjectReferenceIdIndexKey {
	this.vs = []interface{}{reference_id}
	return this
}

type ProjectClassKeyReferenceIdIndexKey struct {
	vs []interface{}
}

func (x ProjectClassKeyReferenceIdIndexKey) id() uint32            { return 5 }
func (x ProjectClassKeyReferenceIdIndexKey) values() []interface{} { return x.vs }
func (x ProjectClassKeyReferenceIdIndexKey) projectIndexKey()      {}

func (this ProjectClassKeyReferenceIdIndexKey) WithClassKey(class_key uint64) ProjectClassKeyReferenceIdIndexKey {
	this.vs = []interface{}{class_key}
	return this
}

func (this ProjectClassKeyReferenceIdIndexKey) WithClassKeyReferenceId(class_key uint64, reference_id string) ProjectClassKeyReferenceIdIndexKey {
	this.vs = []interface{}{class_key, reference_id}
	return this
}

type projectTable struct {
	table ormtable.AutoIncrementTable
}

func (this projectTable) Insert(ctx context.Context, project *Project) error {
	return this.table.Insert(ctx, project)
}

func (this projectTable) Update(ctx context.Context, project *Project) error {
	return this.table.Update(ctx, project)
}

func (this projectTable) Save(ctx context.Context, project *Project) error {
	return this.table.Save(ctx, project)
}

func (this projectTable) Delete(ctx context.Context, project *Project) error {
	return this.table.Delete(ctx, project)
}

func (this projectTable) InsertReturningID(ctx context.Context, project *Project) (uint64, error) {
	return this.table.InsertReturningID(ctx, project)
}

func (this projectTable) Has(ctx context.Context, key uint64) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, key)
}

func (this projectTable) Get(ctx context.Context, key uint64) (*Project, error) {
	var project Project
	found, err := this.table.PrimaryKey().Get(ctx, &project, key)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &project, nil
}

func (this projectTable) HasById(ctx context.Context, id string) (found bool, err error) {
	return this.table.GetIndexByID(1).(ormtable.UniqueIndex).Has(ctx,
		id,
	)
}

func (this projectTable) GetById(ctx context.Context, id string) (*Project, error) {
	var project Project
	found, err := this.table.GetIndexByID(1).(ormtable.UniqueIndex).Get(ctx, &project,
		id,
	)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &project, nil
}

func (this projectTable) HasByClassKeyId(ctx context.Context, class_key uint64, id string) (found bool, err error) {
	return this.table.GetIndexByID(2).(ormtable.UniqueIndex).Has(ctx,
		class_key,
		id,
	)
}

func (this projectTable) GetByClassKeyId(ctx context.Context, class_key uint64, id string) (*Project, error) {
	var project Project
	found, err := this.table.GetIndexByID(2).(ormtable.UniqueIndex).Get(ctx, &project,
		class_key,
		id,
	)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &project, nil
}

func (this projectTable) List(ctx context.Context, prefixKey ProjectIndexKey, opts ...ormlist.Option) (ProjectIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return ProjectIterator{it}, err
}

func (this projectTable) ListRange(ctx context.Context, from, to ProjectIndexKey, opts ...ormlist.Option) (ProjectIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return ProjectIterator{it}, err
}

func (this projectTable) DeleteBy(ctx context.Context, prefixKey ProjectIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this projectTable) DeleteRange(ctx context.Context, from, to ProjectIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this projectTable) doNotImplement() {}

var _ ProjectTable = projectTable{}

func NewProjectTable(db ormtable.Schema) (ProjectTable, error) {
	table := db.GetTable(&Project{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&Project{}).ProtoReflect().Descriptor().FullName()))
	}
	return projectTable{table.(ormtable.AutoIncrementTable)}, nil
}

type BatchTable interface {
	Insert(ctx context.Context, batch *Batch) error
	InsertReturningID(ctx context.Context, batch *Batch) (uint64, error)
	Update(ctx context.Context, batch *Batch) error
	Save(ctx context.Context, batch *Batch) error
	Delete(ctx context.Context, batch *Batch) error
	Has(ctx context.Context, key uint64) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, key uint64) (*Batch, error)
	HasByDenom(ctx context.Context, denom string) (found bool, err error)
	// GetByDenom returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	GetByDenom(ctx context.Context, denom string) (*Batch, error)
	List(ctx context.Context, prefixKey BatchIndexKey, opts ...ormlist.Option) (BatchIterator, error)
	ListRange(ctx context.Context, from, to BatchIndexKey, opts ...ormlist.Option) (BatchIterator, error)
	DeleteBy(ctx context.Context, prefixKey BatchIndexKey) error
	DeleteRange(ctx context.Context, from, to BatchIndexKey) error

	doNotImplement()
}

type BatchIterator struct {
	ormtable.Iterator
}

func (i BatchIterator) Value() (*Batch, error) {
	var batch Batch
	err := i.UnmarshalMessage(&batch)
	return &batch, err
}

type BatchIndexKey interface {
	id() uint32
	values() []interface{}
	batchIndexKey()
}

// primary key starting index..
type BatchPrimaryKey = BatchKeyIndexKey

type BatchKeyIndexKey struct {
	vs []interface{}
}

func (x BatchKeyIndexKey) id() uint32            { return 0 }
func (x BatchKeyIndexKey) values() []interface{} { return x.vs }
func (x BatchKeyIndexKey) batchIndexKey()        {}

func (this BatchKeyIndexKey) WithKey(key uint64) BatchKeyIndexKey {
	this.vs = []interface{}{key}
	return this
}

type BatchDenomIndexKey struct {
	vs []interface{}
}

func (x BatchDenomIndexKey) id() uint32            { return 1 }
func (x BatchDenomIndexKey) values() []interface{} { return x.vs }
func (x BatchDenomIndexKey) batchIndexKey()        {}

func (this BatchDenomIndexKey) WithDenom(denom string) BatchDenomIndexKey {
	this.vs = []interface{}{denom}
	return this
}

type BatchProjectKeyIndexKey struct {
	vs []interface{}
}

func (x BatchProjectKeyIndexKey) id() uint32            { return 2 }
func (x BatchProjectKeyIndexKey) values() []interface{} { return x.vs }
func (x BatchProjectKeyIndexKey) batchIndexKey()        {}

func (this BatchProjectKeyIndexKey) WithProjectKey(project_key uint64) BatchProjectKeyIndexKey {
	this.vs = []interface{}{project_key}
	return this
}

type BatchStartDateIndexKey struct {
	vs []interface{}
}

func (x BatchStartDateIndexKey) id() uint32            { return 3 }
func (x BatchStartDateIndexKey) values() []interface{} { return x.vs }
func (x BatchStartDateIndexKey) batchIndexKey()        {}

func (this BatchStartDateIndexKey) WithStartDate(start_date *timestamppb.Timestamp) BatchStartDateIndexKey {
	this.vs = []interface{}{start_date}
	return this
}

type BatchIssuerIndexKey struct {
	vs []interface{}
}

func (x BatchIssuerIndexKey) id() uint32            { return 4 }
func (x BatchIssuerIndexKey) values() []interface{} { return x.vs }
func (x BatchIssuerIndexKey) batchIndexKey()        {}

func (this BatchIssuerIndexKey) WithIssuer(issuer []byte) BatchIssuerIndexKey {
	this.vs = []interface{}{issuer}
	return this
}

type batchTable struct {
	table ormtable.AutoIncrementTable
}

func (this batchTable) Insert(ctx context.Context, batch *Batch) error {
	return this.table.Insert(ctx, batch)
}

func (this batchTable) Update(ctx context.Context, batch *Batch) error {
	return this.table.Update(ctx, batch)
}

func (this batchTable) Save(ctx context.Context, batch *Batch) error {
	return this.table.Save(ctx, batch)
}

func (this batchTable) Delete(ctx context.Context, batch *Batch) error {
	return this.table.Delete(ctx, batch)
}

func (this batchTable) InsertReturningID(ctx context.Context, batch *Batch) (uint64, error) {
	return this.table.InsertReturningID(ctx, batch)
}

func (this batchTable) Has(ctx context.Context, key uint64) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, key)
}

func (this batchTable) Get(ctx context.Context, key uint64) (*Batch, error) {
	var batch Batch
	found, err := this.table.PrimaryKey().Get(ctx, &batch, key)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &batch, nil
}

func (this batchTable) HasByDenom(ctx context.Context, denom string) (found bool, err error) {
	return this.table.GetIndexByID(1).(ormtable.UniqueIndex).Has(ctx,
		denom,
	)
}

func (this batchTable) GetByDenom(ctx context.Context, denom string) (*Batch, error) {
	var batch Batch
	found, err := this.table.GetIndexByID(1).(ormtable.UniqueIndex).Get(ctx, &batch,
		denom,
	)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &batch, nil
}

func (this batchTable) List(ctx context.Context, prefixKey BatchIndexKey, opts ...ormlist.Option) (BatchIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return BatchIterator{it}, err
}

func (this batchTable) ListRange(ctx context.Context, from, to BatchIndexKey, opts ...ormlist.Option) (BatchIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return BatchIterator{it}, err
}

func (this batchTable) DeleteBy(ctx context.Context, prefixKey BatchIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this batchTable) DeleteRange(ctx context.Context, from, to BatchIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this batchTable) doNotImplement() {}

var _ BatchTable = batchTable{}

func NewBatchTable(db ormtable.Schema) (BatchTable, error) {
	table := db.GetTable(&Batch{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&Batch{}).ProtoReflect().Descriptor().FullName()))
	}
	return batchTable{table.(ormtable.AutoIncrementTable)}, nil
}

type ClassSequenceTable interface {
	Insert(ctx context.Context, classSequence *ClassSequence) error
	Update(ctx context.Context, classSequence *ClassSequence) error
	Save(ctx context.Context, classSequence *ClassSequence) error
	Delete(ctx context.Context, classSequence *ClassSequence) error
	Has(ctx context.Context, credit_type_abbrev string) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, credit_type_abbrev string) (*ClassSequence, error)
	List(ctx context.Context, prefixKey ClassSequenceIndexKey, opts ...ormlist.Option) (ClassSequenceIterator, error)
	ListRange(ctx context.Context, from, to ClassSequenceIndexKey, opts ...ormlist.Option) (ClassSequenceIterator, error)
	DeleteBy(ctx context.Context, prefixKey ClassSequenceIndexKey) error
	DeleteRange(ctx context.Context, from, to ClassSequenceIndexKey) error

	doNotImplement()
}

type ClassSequenceIterator struct {
	ormtable.Iterator
}

func (i ClassSequenceIterator) Value() (*ClassSequence, error) {
	var classSequence ClassSequence
	err := i.UnmarshalMessage(&classSequence)
	return &classSequence, err
}

type ClassSequenceIndexKey interface {
	id() uint32
	values() []interface{}
	classSequenceIndexKey()
}

// primary key starting index..
type ClassSequencePrimaryKey = ClassSequenceCreditTypeAbbrevIndexKey

type ClassSequenceCreditTypeAbbrevIndexKey struct {
	vs []interface{}
}

func (x ClassSequenceCreditTypeAbbrevIndexKey) id() uint32             { return 0 }
func (x ClassSequenceCreditTypeAbbrevIndexKey) values() []interface{}  { return x.vs }
func (x ClassSequenceCreditTypeAbbrevIndexKey) classSequenceIndexKey() {}

func (this ClassSequenceCreditTypeAbbrevIndexKey) WithCreditTypeAbbrev(credit_type_abbrev string) ClassSequenceCreditTypeAbbrevIndexKey {
	this.vs = []interface{}{credit_type_abbrev}
	return this
}

type classSequenceTable struct {
	table ormtable.Table
}

func (this classSequenceTable) Insert(ctx context.Context, classSequence *ClassSequence) error {
	return this.table.Insert(ctx, classSequence)
}

func (this classSequenceTable) Update(ctx context.Context, classSequence *ClassSequence) error {
	return this.table.Update(ctx, classSequence)
}

func (this classSequenceTable) Save(ctx context.Context, classSequence *ClassSequence) error {
	return this.table.Save(ctx, classSequence)
}

func (this classSequenceTable) Delete(ctx context.Context, classSequence *ClassSequence) error {
	return this.table.Delete(ctx, classSequence)
}

func (this classSequenceTable) Has(ctx context.Context, credit_type_abbrev string) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, credit_type_abbrev)
}

func (this classSequenceTable) Get(ctx context.Context, credit_type_abbrev string) (*ClassSequence, error) {
	var classSequence ClassSequence
	found, err := this.table.PrimaryKey().Get(ctx, &classSequence, credit_type_abbrev)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &classSequence, nil
}

func (this classSequenceTable) List(ctx context.Context, prefixKey ClassSequenceIndexKey, opts ...ormlist.Option) (ClassSequenceIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return ClassSequenceIterator{it}, err
}

func (this classSequenceTable) ListRange(ctx context.Context, from, to ClassSequenceIndexKey, opts ...ormlist.Option) (ClassSequenceIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return ClassSequenceIterator{it}, err
}

func (this classSequenceTable) DeleteBy(ctx context.Context, prefixKey ClassSequenceIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this classSequenceTable) DeleteRange(ctx context.Context, from, to ClassSequenceIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this classSequenceTable) doNotImplement() {}

var _ ClassSequenceTable = classSequenceTable{}

func NewClassSequenceTable(db ormtable.Schema) (ClassSequenceTable, error) {
	table := db.GetTable(&ClassSequence{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&ClassSequence{}).ProtoReflect().Descriptor().FullName()))
	}
	return classSequenceTable{table}, nil
}

type ProjectSequenceTable interface {
	Insert(ctx context.Context, projectSequence *ProjectSequence) error
	Update(ctx context.Context, projectSequence *ProjectSequence) error
	Save(ctx context.Context, projectSequence *ProjectSequence) error
	Delete(ctx context.Context, projectSequence *ProjectSequence) error
	Has(ctx context.Context, class_key uint64) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, class_key uint64) (*ProjectSequence, error)
	List(ctx context.Context, prefixKey ProjectSequenceIndexKey, opts ...ormlist.Option) (ProjectSequenceIterator, error)
	ListRange(ctx context.Context, from, to ProjectSequenceIndexKey, opts ...ormlist.Option) (ProjectSequenceIterator, error)
	DeleteBy(ctx context.Context, prefixKey ProjectSequenceIndexKey) error
	DeleteRange(ctx context.Context, from, to ProjectSequenceIndexKey) error

	doNotImplement()
}

type ProjectSequenceIterator struct {
	ormtable.Iterator
}

func (i ProjectSequenceIterator) Value() (*ProjectSequence, error) {
	var projectSequence ProjectSequence
	err := i.UnmarshalMessage(&projectSequence)
	return &projectSequence, err
}

type ProjectSequenceIndexKey interface {
	id() uint32
	values() []interface{}
	projectSequenceIndexKey()
}

// primary key starting index..
type ProjectSequencePrimaryKey = ProjectSequenceClassKeyIndexKey

type ProjectSequenceClassKeyIndexKey struct {
	vs []interface{}
}

func (x ProjectSequenceClassKeyIndexKey) id() uint32               { return 0 }
func (x ProjectSequenceClassKeyIndexKey) values() []interface{}    { return x.vs }
func (x ProjectSequenceClassKeyIndexKey) projectSequenceIndexKey() {}

func (this ProjectSequenceClassKeyIndexKey) WithClassKey(class_key uint64) ProjectSequenceClassKeyIndexKey {
	this.vs = []interface{}{class_key}
	return this
}

type projectSequenceTable struct {
	table ormtable.Table
}

func (this projectSequenceTable) Insert(ctx context.Context, projectSequence *ProjectSequence) error {
	return this.table.Insert(ctx, projectSequence)
}

func (this projectSequenceTable) Update(ctx context.Context, projectSequence *ProjectSequence) error {
	return this.table.Update(ctx, projectSequence)
}

func (this projectSequenceTable) Save(ctx context.Context, projectSequence *ProjectSequence) error {
	return this.table.Save(ctx, projectSequence)
}

func (this projectSequenceTable) Delete(ctx context.Context, projectSequence *ProjectSequence) error {
	return this.table.Delete(ctx, projectSequence)
}

func (this projectSequenceTable) Has(ctx context.Context, class_key uint64) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, class_key)
}

func (this projectSequenceTable) Get(ctx context.Context, class_key uint64) (*ProjectSequence, error) {
	var projectSequence ProjectSequence
	found, err := this.table.PrimaryKey().Get(ctx, &projectSequence, class_key)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &projectSequence, nil
}

func (this projectSequenceTable) List(ctx context.Context, prefixKey ProjectSequenceIndexKey, opts ...ormlist.Option) (ProjectSequenceIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return ProjectSequenceIterator{it}, err
}

func (this projectSequenceTable) ListRange(ctx context.Context, from, to ProjectSequenceIndexKey, opts ...ormlist.Option) (ProjectSequenceIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return ProjectSequenceIterator{it}, err
}

func (this projectSequenceTable) DeleteBy(ctx context.Context, prefixKey ProjectSequenceIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this projectSequenceTable) DeleteRange(ctx context.Context, from, to ProjectSequenceIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this projectSequenceTable) doNotImplement() {}

var _ ProjectSequenceTable = projectSequenceTable{}

func NewProjectSequenceTable(db ormtable.Schema) (ProjectSequenceTable, error) {
	table := db.GetTable(&ProjectSequence{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&ProjectSequence{}).ProtoReflect().Descriptor().FullName()))
	}
	return projectSequenceTable{table}, nil
}

type BatchSequenceTable interface {
	Insert(ctx context.Context, batchSequence *BatchSequence) error
	Update(ctx context.Context, batchSequence *BatchSequence) error
	Save(ctx context.Context, batchSequence *BatchSequence) error
	Delete(ctx context.Context, batchSequence *BatchSequence) error
	Has(ctx context.Context, project_key uint64) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, project_key uint64) (*BatchSequence, error)
	List(ctx context.Context, prefixKey BatchSequenceIndexKey, opts ...ormlist.Option) (BatchSequenceIterator, error)
	ListRange(ctx context.Context, from, to BatchSequenceIndexKey, opts ...ormlist.Option) (BatchSequenceIterator, error)
	DeleteBy(ctx context.Context, prefixKey BatchSequenceIndexKey) error
	DeleteRange(ctx context.Context, from, to BatchSequenceIndexKey) error

	doNotImplement()
}

type BatchSequenceIterator struct {
	ormtable.Iterator
}

func (i BatchSequenceIterator) Value() (*BatchSequence, error) {
	var batchSequence BatchSequence
	err := i.UnmarshalMessage(&batchSequence)
	return &batchSequence, err
}

type BatchSequenceIndexKey interface {
	id() uint32
	values() []interface{}
	batchSequenceIndexKey()
}

// primary key starting index..
type BatchSequencePrimaryKey = BatchSequenceProjectKeyIndexKey

type BatchSequenceProjectKeyIndexKey struct {
	vs []interface{}
}

func (x BatchSequenceProjectKeyIndexKey) id() uint32             { return 0 }
func (x BatchSequenceProjectKeyIndexKey) values() []interface{}  { return x.vs }
func (x BatchSequenceProjectKeyIndexKey) batchSequenceIndexKey() {}

func (this BatchSequenceProjectKeyIndexKey) WithProjectKey(project_key uint64) BatchSequenceProjectKeyIndexKey {
	this.vs = []interface{}{project_key}
	return this
}

type batchSequenceTable struct {
	table ormtable.Table
}

func (this batchSequenceTable) Insert(ctx context.Context, batchSequence *BatchSequence) error {
	return this.table.Insert(ctx, batchSequence)
}

func (this batchSequenceTable) Update(ctx context.Context, batchSequence *BatchSequence) error {
	return this.table.Update(ctx, batchSequence)
}

func (this batchSequenceTable) Save(ctx context.Context, batchSequence *BatchSequence) error {
	return this.table.Save(ctx, batchSequence)
}

func (this batchSequenceTable) Delete(ctx context.Context, batchSequence *BatchSequence) error {
	return this.table.Delete(ctx, batchSequence)
}

func (this batchSequenceTable) Has(ctx context.Context, project_key uint64) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, project_key)
}

func (this batchSequenceTable) Get(ctx context.Context, project_key uint64) (*BatchSequence, error) {
	var batchSequence BatchSequence
	found, err := this.table.PrimaryKey().Get(ctx, &batchSequence, project_key)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &batchSequence, nil
}

func (this batchSequenceTable) List(ctx context.Context, prefixKey BatchSequenceIndexKey, opts ...ormlist.Option) (BatchSequenceIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return BatchSequenceIterator{it}, err
}

func (this batchSequenceTable) ListRange(ctx context.Context, from, to BatchSequenceIndexKey, opts ...ormlist.Option) (BatchSequenceIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return BatchSequenceIterator{it}, err
}

func (this batchSequenceTable) DeleteBy(ctx context.Context, prefixKey BatchSequenceIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this batchSequenceTable) DeleteRange(ctx context.Context, from, to BatchSequenceIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this batchSequenceTable) doNotImplement() {}

var _ BatchSequenceTable = batchSequenceTable{}

func NewBatchSequenceTable(db ormtable.Schema) (BatchSequenceTable, error) {
	table := db.GetTable(&BatchSequence{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&BatchSequence{}).ProtoReflect().Descriptor().FullName()))
	}
	return batchSequenceTable{table}, nil
}

type BatchBalanceTable interface {
	Insert(ctx context.Context, batchBalance *BatchBalance) error
	Update(ctx context.Context, batchBalance *BatchBalance) error
	Save(ctx context.Context, batchBalance *BatchBalance) error
	Delete(ctx context.Context, batchBalance *BatchBalance) error
	Has(ctx context.Context, address []byte, batch_key uint64) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, address []byte, batch_key uint64) (*BatchBalance, error)
	List(ctx context.Context, prefixKey BatchBalanceIndexKey, opts ...ormlist.Option) (BatchBalanceIterator, error)
	ListRange(ctx context.Context, from, to BatchBalanceIndexKey, opts ...ormlist.Option) (BatchBalanceIterator, error)
	DeleteBy(ctx context.Context, prefixKey BatchBalanceIndexKey) error
	DeleteRange(ctx context.Context, from, to BatchBalanceIndexKey) error

	doNotImplement()
}

type BatchBalanceIterator struct {
	ormtable.Iterator
}

func (i BatchBalanceIterator) Value() (*BatchBalance, error) {
	var batchBalance BatchBalance
	err := i.UnmarshalMessage(&batchBalance)
	return &batchBalance, err
}

type BatchBalanceIndexKey interface {
	id() uint32
	values() []interface{}
	batchBalanceIndexKey()
}

// primary key starting index..
type BatchBalancePrimaryKey = BatchBalanceAddressBatchKeyIndexKey

type BatchBalanceAddressBatchKeyIndexKey struct {
	vs []interface{}
}

func (x BatchBalanceAddressBatchKeyIndexKey) id() uint32            { return 0 }
func (x BatchBalanceAddressBatchKeyIndexKey) values() []interface{} { return x.vs }
func (x BatchBalanceAddressBatchKeyIndexKey) batchBalanceIndexKey() {}

func (this BatchBalanceAddressBatchKeyIndexKey) WithAddress(address []byte) BatchBalanceAddressBatchKeyIndexKey {
	this.vs = []interface{}{address}
	return this
}

func (this BatchBalanceAddressBatchKeyIndexKey) WithAddressBatchKey(address []byte, batch_key uint64) BatchBalanceAddressBatchKeyIndexKey {
	this.vs = []interface{}{address, batch_key}
	return this
}

type BatchBalanceBatchKeyAddressIndexKey struct {
	vs []interface{}
}

func (x BatchBalanceBatchKeyAddressIndexKey) id() uint32            { return 1 }
func (x BatchBalanceBatchKeyAddressIndexKey) values() []interface{} { return x.vs }
func (x BatchBalanceBatchKeyAddressIndexKey) batchBalanceIndexKey() {}

func (this BatchBalanceBatchKeyAddressIndexKey) WithBatchKey(batch_key uint64) BatchBalanceBatchKeyAddressIndexKey {
	this.vs = []interface{}{batch_key}
	return this
}

func (this BatchBalanceBatchKeyAddressIndexKey) WithBatchKeyAddress(batch_key uint64, address []byte) BatchBalanceBatchKeyAddressIndexKey {
	this.vs = []interface{}{batch_key, address}
	return this
}

type batchBalanceTable struct {
	table ormtable.Table
}

func (this batchBalanceTable) Insert(ctx context.Context, batchBalance *BatchBalance) error {
	return this.table.Insert(ctx, batchBalance)
}

func (this batchBalanceTable) Update(ctx context.Context, batchBalance *BatchBalance) error {
	return this.table.Update(ctx, batchBalance)
}

func (this batchBalanceTable) Save(ctx context.Context, batchBalance *BatchBalance) error {
	return this.table.Save(ctx, batchBalance)
}

func (this batchBalanceTable) Delete(ctx context.Context, batchBalance *BatchBalance) error {
	return this.table.Delete(ctx, batchBalance)
}

func (this batchBalanceTable) Has(ctx context.Context, address []byte, batch_key uint64) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, address, batch_key)
}

func (this batchBalanceTable) Get(ctx context.Context, address []byte, batch_key uint64) (*BatchBalance, error) {
	var batchBalance BatchBalance
	found, err := this.table.PrimaryKey().Get(ctx, &batchBalance, address, batch_key)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &batchBalance, nil
}

func (this batchBalanceTable) List(ctx context.Context, prefixKey BatchBalanceIndexKey, opts ...ormlist.Option) (BatchBalanceIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return BatchBalanceIterator{it}, err
}

func (this batchBalanceTable) ListRange(ctx context.Context, from, to BatchBalanceIndexKey, opts ...ormlist.Option) (BatchBalanceIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return BatchBalanceIterator{it}, err
}

func (this batchBalanceTable) DeleteBy(ctx context.Context, prefixKey BatchBalanceIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this batchBalanceTable) DeleteRange(ctx context.Context, from, to BatchBalanceIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this batchBalanceTable) doNotImplement() {}

var _ BatchBalanceTable = batchBalanceTable{}

func NewBatchBalanceTable(db ormtable.Schema) (BatchBalanceTable, error) {
	table := db.GetTable(&BatchBalance{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&BatchBalance{}).ProtoReflect().Descriptor().FullName()))
	}
	return batchBalanceTable{table}, nil
}

type BatchSupplyTable interface {
	Insert(ctx context.Context, batchSupply *BatchSupply) error
	Update(ctx context.Context, batchSupply *BatchSupply) error
	Save(ctx context.Context, batchSupply *BatchSupply) error
	Delete(ctx context.Context, batchSupply *BatchSupply) error
	Has(ctx context.Context, batch_key uint64) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, batch_key uint64) (*BatchSupply, error)
	List(ctx context.Context, prefixKey BatchSupplyIndexKey, opts ...ormlist.Option) (BatchSupplyIterator, error)
	ListRange(ctx context.Context, from, to BatchSupplyIndexKey, opts ...ormlist.Option) (BatchSupplyIterator, error)
	DeleteBy(ctx context.Context, prefixKey BatchSupplyIndexKey) error
	DeleteRange(ctx context.Context, from, to BatchSupplyIndexKey) error

	doNotImplement()
}

type BatchSupplyIterator struct {
	ormtable.Iterator
}

func (i BatchSupplyIterator) Value() (*BatchSupply, error) {
	var batchSupply BatchSupply
	err := i.UnmarshalMessage(&batchSupply)
	return &batchSupply, err
}

type BatchSupplyIndexKey interface {
	id() uint32
	values() []interface{}
	batchSupplyIndexKey()
}

// primary key starting index..
type BatchSupplyPrimaryKey = BatchSupplyBatchKeyIndexKey

type BatchSupplyBatchKeyIndexKey struct {
	vs []interface{}
}

func (x BatchSupplyBatchKeyIndexKey) id() uint32            { return 0 }
func (x BatchSupplyBatchKeyIndexKey) values() []interface{} { return x.vs }
func (x BatchSupplyBatchKeyIndexKey) batchSupplyIndexKey()  {}

func (this BatchSupplyBatchKeyIndexKey) WithBatchKey(batch_key uint64) BatchSupplyBatchKeyIndexKey {
	this.vs = []interface{}{batch_key}
	return this
}

type batchSupplyTable struct {
	table ormtable.Table
}

func (this batchSupplyTable) Insert(ctx context.Context, batchSupply *BatchSupply) error {
	return this.table.Insert(ctx, batchSupply)
}

func (this batchSupplyTable) Update(ctx context.Context, batchSupply *BatchSupply) error {
	return this.table.Update(ctx, batchSupply)
}

func (this batchSupplyTable) Save(ctx context.Context, batchSupply *BatchSupply) error {
	return this.table.Save(ctx, batchSupply)
}

func (this batchSupplyTable) Delete(ctx context.Context, batchSupply *BatchSupply) error {
	return this.table.Delete(ctx, batchSupply)
}

func (this batchSupplyTable) Has(ctx context.Context, batch_key uint64) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, batch_key)
}

func (this batchSupplyTable) Get(ctx context.Context, batch_key uint64) (*BatchSupply, error) {
	var batchSupply BatchSupply
	found, err := this.table.PrimaryKey().Get(ctx, &batchSupply, batch_key)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &batchSupply, nil
}

func (this batchSupplyTable) List(ctx context.Context, prefixKey BatchSupplyIndexKey, opts ...ormlist.Option) (BatchSupplyIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return BatchSupplyIterator{it}, err
}

func (this batchSupplyTable) ListRange(ctx context.Context, from, to BatchSupplyIndexKey, opts ...ormlist.Option) (BatchSupplyIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return BatchSupplyIterator{it}, err
}

func (this batchSupplyTable) DeleteBy(ctx context.Context, prefixKey BatchSupplyIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this batchSupplyTable) DeleteRange(ctx context.Context, from, to BatchSupplyIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this batchSupplyTable) doNotImplement() {}

var _ BatchSupplyTable = batchSupplyTable{}

func NewBatchSupplyTable(db ormtable.Schema) (BatchSupplyTable, error) {
	table := db.GetTable(&BatchSupply{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&BatchSupply{}).ProtoReflect().Descriptor().FullName()))
	}
	return batchSupplyTable{table}, nil
}

type OriginTxIndexTable interface {
	Insert(ctx context.Context, originTxIndex *OriginTxIndex) error
	Update(ctx context.Context, originTxIndex *OriginTxIndex) error
	Save(ctx context.Context, originTxIndex *OriginTxIndex) error
	Delete(ctx context.Context, originTxIndex *OriginTxIndex) error
	Has(ctx context.Context, class_key uint64, id string, source string) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, class_key uint64, id string, source string) (*OriginTxIndex, error)
	List(ctx context.Context, prefixKey OriginTxIndexIndexKey, opts ...ormlist.Option) (OriginTxIndexIterator, error)
	ListRange(ctx context.Context, from, to OriginTxIndexIndexKey, opts ...ormlist.Option) (OriginTxIndexIterator, error)
	DeleteBy(ctx context.Context, prefixKey OriginTxIndexIndexKey) error
	DeleteRange(ctx context.Context, from, to OriginTxIndexIndexKey) error

	doNotImplement()
}

type OriginTxIndexIterator struct {
	ormtable.Iterator
}

func (i OriginTxIndexIterator) Value() (*OriginTxIndex, error) {
	var originTxIndex OriginTxIndex
	err := i.UnmarshalMessage(&originTxIndex)
	return &originTxIndex, err
}

type OriginTxIndexIndexKey interface {
	id() uint32
	values() []interface{}
	originTxIndexIndexKey()
}

// primary key starting index..
type OriginTxIndexPrimaryKey = OriginTxIndexClassKeyIdSourceIndexKey

type OriginTxIndexClassKeyIdSourceIndexKey struct {
	vs []interface{}
}

func (x OriginTxIndexClassKeyIdSourceIndexKey) id() uint32             { return 0 }
func (x OriginTxIndexClassKeyIdSourceIndexKey) values() []interface{}  { return x.vs }
func (x OriginTxIndexClassKeyIdSourceIndexKey) originTxIndexIndexKey() {}

func (this OriginTxIndexClassKeyIdSourceIndexKey) WithClassKey(class_key uint64) OriginTxIndexClassKeyIdSourceIndexKey {
	this.vs = []interface{}{class_key}
	return this
}

func (this OriginTxIndexClassKeyIdSourceIndexKey) WithClassKeyId(class_key uint64, id string) OriginTxIndexClassKeyIdSourceIndexKey {
	this.vs = []interface{}{class_key, id}
	return this
}

func (this OriginTxIndexClassKeyIdSourceIndexKey) WithClassKeyIdSource(class_key uint64, id string, source string) OriginTxIndexClassKeyIdSourceIndexKey {
	this.vs = []interface{}{class_key, id, source}
	return this
}

type originTxIndexTable struct {
	table ormtable.Table
}

func (this originTxIndexTable) Insert(ctx context.Context, originTxIndex *OriginTxIndex) error {
	return this.table.Insert(ctx, originTxIndex)
}

func (this originTxIndexTable) Update(ctx context.Context, originTxIndex *OriginTxIndex) error {
	return this.table.Update(ctx, originTxIndex)
}

func (this originTxIndexTable) Save(ctx context.Context, originTxIndex *OriginTxIndex) error {
	return this.table.Save(ctx, originTxIndex)
}

func (this originTxIndexTable) Delete(ctx context.Context, originTxIndex *OriginTxIndex) error {
	return this.table.Delete(ctx, originTxIndex)
}

func (this originTxIndexTable) Has(ctx context.Context, class_key uint64, id string, source string) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, class_key, id, source)
}

func (this originTxIndexTable) Get(ctx context.Context, class_key uint64, id string, source string) (*OriginTxIndex, error) {
	var originTxIndex OriginTxIndex
	found, err := this.table.PrimaryKey().Get(ctx, &originTxIndex, class_key, id, source)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &originTxIndex, nil
}

func (this originTxIndexTable) List(ctx context.Context, prefixKey OriginTxIndexIndexKey, opts ...ormlist.Option) (OriginTxIndexIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return OriginTxIndexIterator{it}, err
}

func (this originTxIndexTable) ListRange(ctx context.Context, from, to OriginTxIndexIndexKey, opts ...ormlist.Option) (OriginTxIndexIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return OriginTxIndexIterator{it}, err
}

func (this originTxIndexTable) DeleteBy(ctx context.Context, prefixKey OriginTxIndexIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this originTxIndexTable) DeleteRange(ctx context.Context, from, to OriginTxIndexIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this originTxIndexTable) doNotImplement() {}

var _ OriginTxIndexTable = originTxIndexTable{}

func NewOriginTxIndexTable(db ormtable.Schema) (OriginTxIndexTable, error) {
	table := db.GetTable(&OriginTxIndex{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&OriginTxIndex{}).ProtoReflect().Descriptor().FullName()))
	}
	return originTxIndexTable{table}, nil
}

type BatchContractTable interface {
	Insert(ctx context.Context, batchContract *BatchContract) error
	Update(ctx context.Context, batchContract *BatchContract) error
	Save(ctx context.Context, batchContract *BatchContract) error
	Delete(ctx context.Context, batchContract *BatchContract) error
	Has(ctx context.Context, batch_key uint64) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, batch_key uint64) (*BatchContract, error)
	HasByClassKeyContract(ctx context.Context, class_key uint64, contract string) (found bool, err error)
	// GetByClassKeyContract returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	GetByClassKeyContract(ctx context.Context, class_key uint64, contract string) (*BatchContract, error)
	List(ctx context.Context, prefixKey BatchContractIndexKey, opts ...ormlist.Option) (BatchContractIterator, error)
	ListRange(ctx context.Context, from, to BatchContractIndexKey, opts ...ormlist.Option) (BatchContractIterator, error)
	DeleteBy(ctx context.Context, prefixKey BatchContractIndexKey) error
	DeleteRange(ctx context.Context, from, to BatchContractIndexKey) error

	doNotImplement()
}

type BatchContractIterator struct {
	ormtable.Iterator
}

func (i BatchContractIterator) Value() (*BatchContract, error) {
	var batchContract BatchContract
	err := i.UnmarshalMessage(&batchContract)
	return &batchContract, err
}

type BatchContractIndexKey interface {
	id() uint32
	values() []interface{}
	batchContractIndexKey()
}

// primary key starting index..
type BatchContractPrimaryKey = BatchContractBatchKeyIndexKey

type BatchContractBatchKeyIndexKey struct {
	vs []interface{}
}

func (x BatchContractBatchKeyIndexKey) id() uint32             { return 0 }
func (x BatchContractBatchKeyIndexKey) values() []interface{}  { return x.vs }
func (x BatchContractBatchKeyIndexKey) batchContractIndexKey() {}

func (this BatchContractBatchKeyIndexKey) WithBatchKey(batch_key uint64) BatchContractBatchKeyIndexKey {
	this.vs = []interface{}{batch_key}
	return this
}

type BatchContractClassKeyContractIndexKey struct {
	vs []interface{}
}

func (x BatchContractClassKeyContractIndexKey) id() uint32             { return 1 }
func (x BatchContractClassKeyContractIndexKey) values() []interface{}  { return x.vs }
func (x BatchContractClassKeyContractIndexKey) batchContractIndexKey() {}

func (this BatchContractClassKeyContractIndexKey) WithClassKey(class_key uint64) BatchContractClassKeyContractIndexKey {
	this.vs = []interface{}{class_key}
	return this
}

func (this BatchContractClassKeyContractIndexKey) WithClassKeyContract(class_key uint64, contract string) BatchContractClassKeyContractIndexKey {
	this.vs = []interface{}{class_key, contract}
	return this
}

type batchContractTable struct {
	table ormtable.Table
}

func (this batchContractTable) Insert(ctx context.Context, batchContract *BatchContract) error {
	return this.table.Insert(ctx, batchContract)
}

func (this batchContractTable) Update(ctx context.Context, batchContract *BatchContract) error {
	return this.table.Update(ctx, batchContract)
}

func (this batchContractTable) Save(ctx context.Context, batchContract *BatchContract) error {
	return this.table.Save(ctx, batchContract)
}

func (this batchContractTable) Delete(ctx context.Context, batchContract *BatchContract) error {
	return this.table.Delete(ctx, batchContract)
}

func (this batchContractTable) Has(ctx context.Context, batch_key uint64) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, batch_key)
}

func (this batchContractTable) Get(ctx context.Context, batch_key uint64) (*BatchContract, error) {
	var batchContract BatchContract
	found, err := this.table.PrimaryKey().Get(ctx, &batchContract, batch_key)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &batchContract, nil
}

func (this batchContractTable) HasByClassKeyContract(ctx context.Context, class_key uint64, contract string) (found bool, err error) {
	return this.table.GetIndexByID(1).(ormtable.UniqueIndex).Has(ctx,
		class_key,
		contract,
	)
}

func (this batchContractTable) GetByClassKeyContract(ctx context.Context, class_key uint64, contract string) (*BatchContract, error) {
	var batchContract BatchContract
	found, err := this.table.GetIndexByID(1).(ormtable.UniqueIndex).Get(ctx, &batchContract,
		class_key,
		contract,
	)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &batchContract, nil
}

func (this batchContractTable) List(ctx context.Context, prefixKey BatchContractIndexKey, opts ...ormlist.Option) (BatchContractIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return BatchContractIterator{it}, err
}

func (this batchContractTable) ListRange(ctx context.Context, from, to BatchContractIndexKey, opts ...ormlist.Option) (BatchContractIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return BatchContractIterator{it}, err
}

func (this batchContractTable) DeleteBy(ctx context.Context, prefixKey BatchContractIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this batchContractTable) DeleteRange(ctx context.Context, from, to BatchContractIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this batchContractTable) doNotImplement() {}

var _ BatchContractTable = batchContractTable{}

func NewBatchContractTable(db ormtable.Schema) (BatchContractTable, error) {
	table := db.GetTable(&BatchContract{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&BatchContract{}).ProtoReflect().Descriptor().FullName()))
	}
	return batchContractTable{table}, nil
}

// singleton store
type ClassCreatorAllowlistTable interface {
	Get(ctx context.Context) (*ClassCreatorAllowlist, error)
	Save(ctx context.Context, classCreatorAllowlist *ClassCreatorAllowlist) error
}

type classCreatorAllowlistTable struct {
	table ormtable.Table
}

var _ ClassCreatorAllowlistTable = classCreatorAllowlistTable{}

func (x classCreatorAllowlistTable) Get(ctx context.Context) (*ClassCreatorAllowlist, error) {
	classCreatorAllowlist := &ClassCreatorAllowlist{}
	_, err := x.table.Get(ctx, classCreatorAllowlist)
	return classCreatorAllowlist, err
}

func (x classCreatorAllowlistTable) Save(ctx context.Context, classCreatorAllowlist *ClassCreatorAllowlist) error {
	return x.table.Save(ctx, classCreatorAllowlist)
}

func NewClassCreatorAllowlistTable(db ormtable.Schema) (ClassCreatorAllowlistTable, error) {
	table := db.GetTable(&ClassCreatorAllowlist{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&ClassCreatorAllowlist{}).ProtoReflect().Descriptor().FullName()))
	}
	return &classCreatorAllowlistTable{table}, nil
}

type AllowedClassCreatorTable interface {
	Insert(ctx context.Context, allowedClassCreator *AllowedClassCreator) error
	Update(ctx context.Context, allowedClassCreator *AllowedClassCreator) error
	Save(ctx context.Context, allowedClassCreator *AllowedClassCreator) error
	Delete(ctx context.Context, allowedClassCreator *AllowedClassCreator) error
	Has(ctx context.Context, address []byte) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, address []byte) (*AllowedClassCreator, error)
	List(ctx context.Context, prefixKey AllowedClassCreatorIndexKey, opts ...ormlist.Option) (AllowedClassCreatorIterator, error)
	ListRange(ctx context.Context, from, to AllowedClassCreatorIndexKey, opts ...ormlist.Option) (AllowedClassCreatorIterator, error)
	DeleteBy(ctx context.Context, prefixKey AllowedClassCreatorIndexKey) error
	DeleteRange(ctx context.Context, from, to AllowedClassCreatorIndexKey) error

	doNotImplement()
}

type AllowedClassCreatorIterator struct {
	ormtable.Iterator
}

func (i AllowedClassCreatorIterator) Value() (*AllowedClassCreator, error) {
	var allowedClassCreator AllowedClassCreator
	err := i.UnmarshalMessage(&allowedClassCreator)
	return &allowedClassCreator, err
}

type AllowedClassCreatorIndexKey interface {
	id() uint32
	values() []interface{}
	allowedClassCreatorIndexKey()
}

// primary key starting index..
type AllowedClassCreatorPrimaryKey = AllowedClassCreatorAddressIndexKey

type AllowedClassCreatorAddressIndexKey struct {
	vs []interface{}
}

func (x AllowedClassCreatorAddressIndexKey) id() uint32                   { return 0 }
func (x AllowedClassCreatorAddressIndexKey) values() []interface{}        { return x.vs }
func (x AllowedClassCreatorAddressIndexKey) allowedClassCreatorIndexKey() {}

func (this AllowedClassCreatorAddressIndexKey) WithAddress(address []byte) AllowedClassCreatorAddressIndexKey {
	this.vs = []interface{}{address}
	return this
}

type allowedClassCreatorTable struct {
	table ormtable.Table
}

func (this allowedClassCreatorTable) Insert(ctx context.Context, allowedClassCreator *AllowedClassCreator) error {
	return this.table.Insert(ctx, allowedClassCreator)
}

func (this allowedClassCreatorTable) Update(ctx context.Context, allowedClassCreator *AllowedClassCreator) error {
	return this.table.Update(ctx, allowedClassCreator)
}

func (this allowedClassCreatorTable) Save(ctx context.Context, allowedClassCreator *AllowedClassCreator) error {
	return this.table.Save(ctx, allowedClassCreator)
}

func (this allowedClassCreatorTable) Delete(ctx context.Context, allowedClassCreator *AllowedClassCreator) error {
	return this.table.Delete(ctx, allowedClassCreator)
}

func (this allowedClassCreatorTable) Has(ctx context.Context, address []byte) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, address)
}

func (this allowedClassCreatorTable) Get(ctx context.Context, address []byte) (*AllowedClassCreator, error) {
	var allowedClassCreator AllowedClassCreator
	found, err := this.table.PrimaryKey().Get(ctx, &allowedClassCreator, address)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &allowedClassCreator, nil
}

func (this allowedClassCreatorTable) List(ctx context.Context, prefixKey AllowedClassCreatorIndexKey, opts ...ormlist.Option) (AllowedClassCreatorIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return AllowedClassCreatorIterator{it}, err
}

func (this allowedClassCreatorTable) ListRange(ctx context.Context, from, to AllowedClassCreatorIndexKey, opts ...ormlist.Option) (AllowedClassCreatorIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return AllowedClassCreatorIterator{it}, err
}

func (this allowedClassCreatorTable) DeleteBy(ctx context.Context, prefixKey AllowedClassCreatorIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this allowedClassCreatorTable) DeleteRange(ctx context.Context, from, to AllowedClassCreatorIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this allowedClassCreatorTable) doNotImplement() {}

var _ AllowedClassCreatorTable = allowedClassCreatorTable{}

func NewAllowedClassCreatorTable(db ormtable.Schema) (AllowedClassCreatorTable, error) {
	table := db.GetTable(&AllowedClassCreator{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&AllowedClassCreator{}).ProtoReflect().Descriptor().FullName()))
	}
	return allowedClassCreatorTable{table}, nil
}

// singleton store
type ClassFeeTable interface {
	Get(ctx context.Context) (*ClassFee, error)
	Save(ctx context.Context, classFee *ClassFee) error
}

type classFeeTable struct {
	table ormtable.Table
}

var _ ClassFeeTable = classFeeTable{}

func (x classFeeTable) Get(ctx context.Context) (*ClassFee, error) {
	classFee := &ClassFee{}
	_, err := x.table.Get(ctx, classFee)
	return classFee, err
}

func (x classFeeTable) Save(ctx context.Context, classFee *ClassFee) error {
	return x.table.Save(ctx, classFee)
}

func NewClassFeeTable(db ormtable.Schema) (ClassFeeTable, error) {
	table := db.GetTable(&ClassFee{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&ClassFee{}).ProtoReflect().Descriptor().FullName()))
	}
	return &classFeeTable{table}, nil
}

type AllowedBridgeChainTable interface {
	Insert(ctx context.Context, allowedBridgeChain *AllowedBridgeChain) error
	Update(ctx context.Context, allowedBridgeChain *AllowedBridgeChain) error
	Save(ctx context.Context, allowedBridgeChain *AllowedBridgeChain) error
	Delete(ctx context.Context, allowedBridgeChain *AllowedBridgeChain) error
	Has(ctx context.Context, chain_name string) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, chain_name string) (*AllowedBridgeChain, error)
	List(ctx context.Context, prefixKey AllowedBridgeChainIndexKey, opts ...ormlist.Option) (AllowedBridgeChainIterator, error)
	ListRange(ctx context.Context, from, to AllowedBridgeChainIndexKey, opts ...ormlist.Option) (AllowedBridgeChainIterator, error)
	DeleteBy(ctx context.Context, prefixKey AllowedBridgeChainIndexKey) error
	DeleteRange(ctx context.Context, from, to AllowedBridgeChainIndexKey) error

	doNotImplement()
}

type AllowedBridgeChainIterator struct {
	ormtable.Iterator
}

func (i AllowedBridgeChainIterator) Value() (*AllowedBridgeChain, error) {
	var allowedBridgeChain AllowedBridgeChain
	err := i.UnmarshalMessage(&allowedBridgeChain)
	return &allowedBridgeChain, err
}

type AllowedBridgeChainIndexKey interface {
	id() uint32
	values() []interface{}
	allowedBridgeChainIndexKey()
}

// primary key starting index..
type AllowedBridgeChainPrimaryKey = AllowedBridgeChainChainNameIndexKey

type AllowedBridgeChainChainNameIndexKey struct {
	vs []interface{}
}

func (x AllowedBridgeChainChainNameIndexKey) id() uint32                  { return 0 }
func (x AllowedBridgeChainChainNameIndexKey) values() []interface{}       { return x.vs }
func (x AllowedBridgeChainChainNameIndexKey) allowedBridgeChainIndexKey() {}

func (this AllowedBridgeChainChainNameIndexKey) WithChainName(chain_name string) AllowedBridgeChainChainNameIndexKey {
	this.vs = []interface{}{chain_name}
	return this
}

type allowedBridgeChainTable struct {
	table ormtable.Table
}

func (this allowedBridgeChainTable) Insert(ctx context.Context, allowedBridgeChain *AllowedBridgeChain) error {
	return this.table.Insert(ctx, allowedBridgeChain)
}

func (this allowedBridgeChainTable) Update(ctx context.Context, allowedBridgeChain *AllowedBridgeChain) error {
	return this.table.Update(ctx, allowedBridgeChain)
}

func (this allowedBridgeChainTable) Save(ctx context.Context, allowedBridgeChain *AllowedBridgeChain) error {
	return this.table.Save(ctx, allowedBridgeChain)
}

func (this allowedBridgeChainTable) Delete(ctx context.Context, allowedBridgeChain *AllowedBridgeChain) error {
	return this.table.Delete(ctx, allowedBridgeChain)
}

func (this allowedBridgeChainTable) Has(ctx context.Context, chain_name string) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, chain_name)
}

func (this allowedBridgeChainTable) Get(ctx context.Context, chain_name string) (*AllowedBridgeChain, error) {
	var allowedBridgeChain AllowedBridgeChain
	found, err := this.table.PrimaryKey().Get(ctx, &allowedBridgeChain, chain_name)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &allowedBridgeChain, nil
}

func (this allowedBridgeChainTable) List(ctx context.Context, prefixKey AllowedBridgeChainIndexKey, opts ...ormlist.Option) (AllowedBridgeChainIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return AllowedBridgeChainIterator{it}, err
}

func (this allowedBridgeChainTable) ListRange(ctx context.Context, from, to AllowedBridgeChainIndexKey, opts ...ormlist.Option) (AllowedBridgeChainIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return AllowedBridgeChainIterator{it}, err
}

func (this allowedBridgeChainTable) DeleteBy(ctx context.Context, prefixKey AllowedBridgeChainIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this allowedBridgeChainTable) DeleteRange(ctx context.Context, from, to AllowedBridgeChainIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this allowedBridgeChainTable) doNotImplement() {}

var _ AllowedBridgeChainTable = allowedBridgeChainTable{}

func NewAllowedBridgeChainTable(db ormtable.Schema) (AllowedBridgeChainTable, error) {
	table := db.GetTable(&AllowedBridgeChain{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&AllowedBridgeChain{}).ProtoReflect().Descriptor().FullName()))
	}
	return allowedBridgeChainTable{table}, nil
}

type StateStore interface {
	CreditTypeTable() CreditTypeTable
	ClassTable() ClassTable
	ClassIssuerTable() ClassIssuerTable
	ProjectTable() ProjectTable
	BatchTable() BatchTable
	ClassSequenceTable() ClassSequenceTable
	ProjectSequenceTable() ProjectSequenceTable
	BatchSequenceTable() BatchSequenceTable
	BatchBalanceTable() BatchBalanceTable
	BatchSupplyTable() BatchSupplyTable
	OriginTxIndexTable() OriginTxIndexTable
	BatchContractTable() BatchContractTable
	ClassCreatorAllowlistTable() ClassCreatorAllowlistTable
	AllowedClassCreatorTable() AllowedClassCreatorTable
	ClassFeeTable() ClassFeeTable
	AllowedBridgeChainTable() AllowedBridgeChainTable

	doNotImplement()
}

type stateStore struct {
	creditType            CreditTypeTable
	class                 ClassTable
	classIssuer           ClassIssuerTable
	project               ProjectTable
	batch                 BatchTable
	classSequence         ClassSequenceTable
	projectSequence       ProjectSequenceTable
	batchSequence         BatchSequenceTable
	batchBalance          BatchBalanceTable
	batchSupply           BatchSupplyTable
	originTxIndex         OriginTxIndexTable
	batchContract         BatchContractTable
	classCreatorAllowlist ClassCreatorAllowlistTable
	allowedClassCreator   AllowedClassCreatorTable
	classFee              ClassFeeTable
	allowedBridgeChain    AllowedBridgeChainTable
}

func (x stateStore) CreditTypeTable() CreditTypeTable {
	return x.creditType
}

func (x stateStore) ClassTable() ClassTable {
	return x.class
}

func (x stateStore) ClassIssuerTable() ClassIssuerTable {
	return x.classIssuer
}

func (x stateStore) ProjectTable() ProjectTable {
	return x.project
}

func (x stateStore) BatchTable() BatchTable {
	return x.batch
}

func (x stateStore) ClassSequenceTable() ClassSequenceTable {
	return x.classSequence
}

func (x stateStore) ProjectSequenceTable() ProjectSequenceTable {
	return x.projectSequence
}

func (x stateStore) BatchSequenceTable() BatchSequenceTable {
	return x.batchSequence
}

func (x stateStore) BatchBalanceTable() BatchBalanceTable {
	return x.batchBalance
}

func (x stateStore) BatchSupplyTable() BatchSupplyTable {
	return x.batchSupply
}

func (x stateStore) OriginTxIndexTable() OriginTxIndexTable {
	return x.originTxIndex
}

func (x stateStore) BatchContractTable() BatchContractTable {
	return x.batchContract
}

func (x stateStore) ClassCreatorAllowlistTable() ClassCreatorAllowlistTable {
	return x.classCreatorAllowlist
}

func (x stateStore) AllowedClassCreatorTable() AllowedClassCreatorTable {
	return x.allowedClassCreator
}

func (x stateStore) ClassFeeTable() ClassFeeTable {
	return x.classFee
}

func (x stateStore) AllowedBridgeChainTable() AllowedBridgeChainTable {
	return x.allowedBridgeChain
}

func (stateStore) doNotImplement() {}

var _ StateStore = stateStore{}

func NewStateStore(db ormtable.Schema) (StateStore, error) {
	creditTypeTable, err := NewCreditTypeTable(db)
	if err != nil {
		return nil, err
	}

	classTable, err := NewClassTable(db)
	if err != nil {
		return nil, err
	}

	classIssuerTable, err := NewClassIssuerTable(db)
	if err != nil {
		return nil, err
	}

	projectTable, err := NewProjectTable(db)
	if err != nil {
		return nil, err
	}

	batchTable, err := NewBatchTable(db)
	if err != nil {
		return nil, err
	}

	classSequenceTable, err := NewClassSequenceTable(db)
	if err != nil {
		return nil, err
	}

	projectSequenceTable, err := NewProjectSequenceTable(db)
	if err != nil {
		return nil, err
	}

	batchSequenceTable, err := NewBatchSequenceTable(db)
	if err != nil {
		return nil, err
	}

	batchBalanceTable, err := NewBatchBalanceTable(db)
	if err != nil {
		return nil, err
	}

	batchSupplyTable, err := NewBatchSupplyTable(db)
	if err != nil {
		return nil, err
	}

	originTxIndexTable, err := NewOriginTxIndexTable(db)
	if err != nil {
		return nil, err
	}

	batchContractTable, err := NewBatchContractTable(db)
	if err != nil {
		return nil, err
	}

	classCreatorAllowlistTable, err := NewClassCreatorAllowlistTable(db)
	if err != nil {
		return nil, err
	}

	allowedClassCreatorTable, err := NewAllowedClassCreatorTable(db)
	if err != nil {
		return nil, err
	}

	classFeeTable, err := NewClassFeeTable(db)
	if err != nil {
		return nil, err
	}

	allowedBridgeChainTable, err := NewAllowedBridgeChainTable(db)
	if err != nil {
		return nil, err
	}

	return stateStore{
		creditTypeTable,
		classTable,
		classIssuerTable,
		projectTable,
		batchTable,
		classSequenceTable,
		projectSequenceTable,
		batchSequenceTable,
		batchBalanceTable,
		batchSupplyTable,
		originTxIndexTable,
		batchContractTable,
		classCreatorAllowlistTable,
		allowedClassCreatorTable,
		classFeeTable,
		allowedBridgeChainTable,
	}, nil
}
