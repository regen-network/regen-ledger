// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             (unknown)
// source: regen/ecocredit/v1/tx.proto

package ecocreditv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MsgClient interface {
	// CreateClass creates a new credit class under the given credit type with an
	// approved list of issuers and optional metadata. The fee denom must be one
	// of the denoms listed in Params.credit_class_fee and greater than or equal
	// to the fee amount but only the minimum amount is charged. The creator of
	// the credit class becomes the admin of the credit class upon creation.
	CreateClass(ctx context.Context, in *MsgCreateClass, opts ...grpc.CallOption) (*MsgCreateClassResponse, error)
	// CreateProject creates a new project under the given credit class with a
	// jurisdiction, optional metadata, and an optional reference ID. The creator
	// of the project must be an approved credit class issuer for the given credit
	// class and the creator becomes the admin of the project upon creation.
	CreateProject(ctx context.Context, in *MsgCreateProject, opts ...grpc.CallOption) (*MsgCreateProjectResponse, error)
	// CreateBatch creates a new batch of credits under the given project with a
	// start and end date representing the monitoring period, a list of credits to
	// be issued with each issuance specifying a recipient, the amount of tradable
	// and retired credits, and the retirement jurisdiction (if credits are to be
	// retired upon receipt), and optional metadata. The credit batch creator must
	// be listed as an approved issuer within the credit class of the project that
	// the credits are being issued under.
	//
	// The default behavior is for a new credit batch to be "sealed" as opposed to
	// being "open". When a credit batch is "open", new credits can be dynamically
	// minted to the credit batch following the creation of the credit batch. This
	// "open" option should only be set to true when bridging credits from another
	// chain or registry as a result of a bridge operation and is not intended for
	// native credit issuance.
	CreateBatch(ctx context.Context, in *MsgCreateBatch, opts ...grpc.CallOption) (*MsgCreateBatchResponse, error)
	// MintBatchCredits dynamically mints credits to an "open" credit batch. This
	// feature is only meant to be used when bridging credits from another chain
	// or registry and is not intended for native credit issuance. When bridging
	// credits from the same vintage (or monitoring period) as an existing credit
	// batch, the credits can be dynamically minted to the existing credit batch
	// if the credit batch is "open".
	MintBatchCredits(ctx context.Context, in *MsgMintBatchCredits, opts ...grpc.CallOption) (*MsgMintBatchCreditsResponse, error)
	// MsgSealBatch seals an "open" credit batch. Once a credit batch is sealed
	// (i.e. once "open" is set to false), credits can no longer be dynamically
	// minted to the credit batch. A sealed credit batch cannot be unsealed and
	// only the credit batch issuer can seal a credit batch.
	SealBatch(ctx context.Context, in *MsgSealBatch, opts ...grpc.CallOption) (*MsgSealBatchResponse, error)
	// Send sends a specified amount of tradable credits from the credit owner's
	// account to another account. Sent credits can either remain tradable or be
	// retired upon receipt.
	Send(ctx context.Context, in *MsgSend, opts ...grpc.CallOption) (*MsgSendResponse, error)
	// Retire retires a specified amount of tradable credits, removing the amount
	// from the credit owner's tradable balance and adding it to their retired
	// balance. Retiring credits is permanent and implies the credits are being
	// consumed as a offset.
	Retire(ctx context.Context, in *MsgRetire, opts ...grpc.CallOption) (*MsgRetireResponse, error)
	// Cancel cancels a specified amount of tradable credits, removing the amount
	// from the credit owner's tradable balance and removing the amount from the
	// credit batch's tradable supply. Cancelling credits is permanent and implies
	// the credits have been moved to another chain or registry.
	Cancel(ctx context.Context, in *MsgCancel, opts ...grpc.CallOption) (*MsgCancelResponse, error)
	// UpdateClassAdmin updates the credit class admin. Only the admin of the
	// credit class can update the credit class.
	UpdateClassAdmin(ctx context.Context, in *MsgUpdateClassAdmin, opts ...grpc.CallOption) (*MsgUpdateClassAdminResponse, error)
	// UpdateClassIssuers updates the credit class issuer list. Only the admin of
	// the credit class can update the credit class.
	UpdateClassIssuers(ctx context.Context, in *MsgUpdateClassIssuers, opts ...grpc.CallOption) (*MsgUpdateClassIssuersResponse, error)
	// UpdateClassMetadata updates the credit class metadata. Only the admin of
	// the credit class can update the credit class.
	UpdateClassMetadata(ctx context.Context, in *MsgUpdateClassMetadata, opts ...grpc.CallOption) (*MsgUpdateClassMetadataResponse, error)
	// UpdateProjectAdmin updates the project admin address. Only the admin of the
	// project can update the project.
	UpdateProjectAdmin(ctx context.Context, in *MsgUpdateProjectAdmin, opts ...grpc.CallOption) (*MsgUpdateProjectAdminResponse, error)
	// UpdateProjectMetadata updates the project metadata. Only the admin of the
	// project can update the project.
	UpdateProjectMetadata(ctx context.Context, in *MsgUpdateProjectMetadata, opts ...grpc.CallOption) (*MsgUpdateProjectMetadataResponse, error)
	// Bridge processes credits being sent back to the source chain. When credits
	// are sent back to the source chain, the credits are cancelled and an event
	// is emitted to be handled by an external bridge service.
	Bridge(ctx context.Context, in *MsgBridge, opts ...grpc.CallOption) (*MsgBridgeResponse, error)
	// BridgeReceive processes credits being sent from another chain. When the
	// credits are sent from the same vintage as an existing credit batch within
	// the scope of the provided credit class, the credits will be minted to the
	// existing credit batch, otherwise the credits will be issued in a new credit
	// batch. The new credit batch will be created under an existing project if a
	// project with a matching reference id already exists within the scope of the
	// credit class, otherwise a new project will be created.
	BridgeReceive(ctx context.Context, in *MsgBridgeReceive, opts ...grpc.CallOption) (*MsgBridgeReceiveResponse, error)
	// AddCreditType is a governance method that allows the addition of new
	// credit types to the network.
	//
	// Since Revision 1
	AddCreditType(ctx context.Context, in *MsgAddCreditType, opts ...grpc.CallOption) (*MsgAddCreditTypeResponse, error)
	// SetClassCreatorAllowlist is a governance method that updates the class
	// creator allowlist enabled setting. When enabled, only addresses listed in
	// the allowlist can create credit classes. When disabled, any address can
	// create credit classes.
	//
	// Since Revision 1
	SetClassCreatorAllowlist(ctx context.Context, in *MsgSetClassCreatorAllowlist, opts ...grpc.CallOption) (*MsgSetClassCreatorAllowlistResponse, error)
	// AddClassCreator is a governance method that allows the addition of new
	// address to the class creation allowlist.
	//
	// Since Revision 1
	AddClassCreator(ctx context.Context, in *MsgAddClassCreator, opts ...grpc.CallOption) (*MsgAddClassCreatorResponse, error)
	// RemoveClassCreator is a governance method that removes
	// address from the creation allowlist.
	//
	// Since Revision 1
	RemoveClassCreator(ctx context.Context, in *MsgRemoveClassCreator, opts ...grpc.CallOption) (*MsgRemoveClassCreatorResponse, error)
	// UpdateClassFees is a governance method that allows for the addition and
	// removal of fees to be used for the class creation fee.
	//
	// Since Revision 1
	UpdateClassFees(ctx context.Context, in *MsgUpdateClassFees, opts ...grpc.CallOption) (*MsgUpdateClassFeesResponse, error)
}

type msgClient struct {
	cc grpc.ClientConnInterface
}

func NewMsgClient(cc grpc.ClientConnInterface) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) CreateClass(ctx context.Context, in *MsgCreateClass, opts ...grpc.CallOption) (*MsgCreateClassResponse, error) {
	out := new(MsgCreateClassResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.v1.Msg/CreateClass", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateProject(ctx context.Context, in *MsgCreateProject, opts ...grpc.CallOption) (*MsgCreateProjectResponse, error) {
	out := new(MsgCreateProjectResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.v1.Msg/CreateProject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateBatch(ctx context.Context, in *MsgCreateBatch, opts ...grpc.CallOption) (*MsgCreateBatchResponse, error) {
	out := new(MsgCreateBatchResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.v1.Msg/CreateBatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) MintBatchCredits(ctx context.Context, in *MsgMintBatchCredits, opts ...grpc.CallOption) (*MsgMintBatchCreditsResponse, error) {
	out := new(MsgMintBatchCreditsResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.v1.Msg/MintBatchCredits", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SealBatch(ctx context.Context, in *MsgSealBatch, opts ...grpc.CallOption) (*MsgSealBatchResponse, error) {
	out := new(MsgSealBatchResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.v1.Msg/SealBatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Send(ctx context.Context, in *MsgSend, opts ...grpc.CallOption) (*MsgSendResponse, error) {
	out := new(MsgSendResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.v1.Msg/Send", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Retire(ctx context.Context, in *MsgRetire, opts ...grpc.CallOption) (*MsgRetireResponse, error) {
	out := new(MsgRetireResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.v1.Msg/Retire", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Cancel(ctx context.Context, in *MsgCancel, opts ...grpc.CallOption) (*MsgCancelResponse, error) {
	out := new(MsgCancelResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.v1.Msg/Cancel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateClassAdmin(ctx context.Context, in *MsgUpdateClassAdmin, opts ...grpc.CallOption) (*MsgUpdateClassAdminResponse, error) {
	out := new(MsgUpdateClassAdminResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.v1.Msg/UpdateClassAdmin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateClassIssuers(ctx context.Context, in *MsgUpdateClassIssuers, opts ...grpc.CallOption) (*MsgUpdateClassIssuersResponse, error) {
	out := new(MsgUpdateClassIssuersResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.v1.Msg/UpdateClassIssuers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateClassMetadata(ctx context.Context, in *MsgUpdateClassMetadata, opts ...grpc.CallOption) (*MsgUpdateClassMetadataResponse, error) {
	out := new(MsgUpdateClassMetadataResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.v1.Msg/UpdateClassMetadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateProjectAdmin(ctx context.Context, in *MsgUpdateProjectAdmin, opts ...grpc.CallOption) (*MsgUpdateProjectAdminResponse, error) {
	out := new(MsgUpdateProjectAdminResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.v1.Msg/UpdateProjectAdmin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateProjectMetadata(ctx context.Context, in *MsgUpdateProjectMetadata, opts ...grpc.CallOption) (*MsgUpdateProjectMetadataResponse, error) {
	out := new(MsgUpdateProjectMetadataResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.v1.Msg/UpdateProjectMetadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Bridge(ctx context.Context, in *MsgBridge, opts ...grpc.CallOption) (*MsgBridgeResponse, error) {
	out := new(MsgBridgeResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.v1.Msg/Bridge", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) BridgeReceive(ctx context.Context, in *MsgBridgeReceive, opts ...grpc.CallOption) (*MsgBridgeReceiveResponse, error) {
	out := new(MsgBridgeReceiveResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.v1.Msg/BridgeReceive", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) AddCreditType(ctx context.Context, in *MsgAddCreditType, opts ...grpc.CallOption) (*MsgAddCreditTypeResponse, error) {
	out := new(MsgAddCreditTypeResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.v1.Msg/AddCreditType", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetClassCreatorAllowlist(ctx context.Context, in *MsgSetClassCreatorAllowlist, opts ...grpc.CallOption) (*MsgSetClassCreatorAllowlistResponse, error) {
	out := new(MsgSetClassCreatorAllowlistResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.v1.Msg/SetClassCreatorAllowlist", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) AddClassCreator(ctx context.Context, in *MsgAddClassCreator, opts ...grpc.CallOption) (*MsgAddClassCreatorResponse, error) {
	out := new(MsgAddClassCreatorResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.v1.Msg/AddClassCreator", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RemoveClassCreator(ctx context.Context, in *MsgRemoveClassCreator, opts ...grpc.CallOption) (*MsgRemoveClassCreatorResponse, error) {
	out := new(MsgRemoveClassCreatorResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.v1.Msg/RemoveClassCreator", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateClassFees(ctx context.Context, in *MsgUpdateClassFees, opts ...grpc.CallOption) (*MsgUpdateClassFeesResponse, error) {
	out := new(MsgUpdateClassFeesResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.v1.Msg/UpdateClassFees", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
// All implementations must embed UnimplementedMsgServer
// for forward compatibility
type MsgServer interface {
	// CreateClass creates a new credit class under the given credit type with an
	// approved list of issuers and optional metadata. The fee denom must be one
	// of the denoms listed in Params.credit_class_fee and greater than or equal
	// to the fee amount but only the minimum amount is charged. The creator of
	// the credit class becomes the admin of the credit class upon creation.
	CreateClass(context.Context, *MsgCreateClass) (*MsgCreateClassResponse, error)
	// CreateProject creates a new project under the given credit class with a
	// jurisdiction, optional metadata, and an optional reference ID. The creator
	// of the project must be an approved credit class issuer for the given credit
	// class and the creator becomes the admin of the project upon creation.
	CreateProject(context.Context, *MsgCreateProject) (*MsgCreateProjectResponse, error)
	// CreateBatch creates a new batch of credits under the given project with a
	// start and end date representing the monitoring period, a list of credits to
	// be issued with each issuance specifying a recipient, the amount of tradable
	// and retired credits, and the retirement jurisdiction (if credits are to be
	// retired upon receipt), and optional metadata. The credit batch creator must
	// be listed as an approved issuer within the credit class of the project that
	// the credits are being issued under.
	//
	// The default behavior is for a new credit batch to be "sealed" as opposed to
	// being "open". When a credit batch is "open", new credits can be dynamically
	// minted to the credit batch following the creation of the credit batch. This
	// "open" option should only be set to true when bridging credits from another
	// chain or registry as a result of a bridge operation and is not intended for
	// native credit issuance.
	CreateBatch(context.Context, *MsgCreateBatch) (*MsgCreateBatchResponse, error)
	// MintBatchCredits dynamically mints credits to an "open" credit batch. This
	// feature is only meant to be used when bridging credits from another chain
	// or registry and is not intended for native credit issuance. When bridging
	// credits from the same vintage (or monitoring period) as an existing credit
	// batch, the credits can be dynamically minted to the existing credit batch
	// if the credit batch is "open".
	MintBatchCredits(context.Context, *MsgMintBatchCredits) (*MsgMintBatchCreditsResponse, error)
	// MsgSealBatch seals an "open" credit batch. Once a credit batch is sealed
	// (i.e. once "open" is set to false), credits can no longer be dynamically
	// minted to the credit batch. A sealed credit batch cannot be unsealed and
	// only the credit batch issuer can seal a credit batch.
	SealBatch(context.Context, *MsgSealBatch) (*MsgSealBatchResponse, error)
	// Send sends a specified amount of tradable credits from the credit owner's
	// account to another account. Sent credits can either remain tradable or be
	// retired upon receipt.
	Send(context.Context, *MsgSend) (*MsgSendResponse, error)
	// Retire retires a specified amount of tradable credits, removing the amount
	// from the credit owner's tradable balance and adding it to their retired
	// balance. Retiring credits is permanent and implies the credits are being
	// consumed as a offset.
	Retire(context.Context, *MsgRetire) (*MsgRetireResponse, error)
	// Cancel cancels a specified amount of tradable credits, removing the amount
	// from the credit owner's tradable balance and removing the amount from the
	// credit batch's tradable supply. Cancelling credits is permanent and implies
	// the credits have been moved to another chain or registry.
	Cancel(context.Context, *MsgCancel) (*MsgCancelResponse, error)
	// UpdateClassAdmin updates the credit class admin. Only the admin of the
	// credit class can update the credit class.
	UpdateClassAdmin(context.Context, *MsgUpdateClassAdmin) (*MsgUpdateClassAdminResponse, error)
	// UpdateClassIssuers updates the credit class issuer list. Only the admin of
	// the credit class can update the credit class.
	UpdateClassIssuers(context.Context, *MsgUpdateClassIssuers) (*MsgUpdateClassIssuersResponse, error)
	// UpdateClassMetadata updates the credit class metadata. Only the admin of
	// the credit class can update the credit class.
	UpdateClassMetadata(context.Context, *MsgUpdateClassMetadata) (*MsgUpdateClassMetadataResponse, error)
	// UpdateProjectAdmin updates the project admin address. Only the admin of the
	// project can update the project.
	UpdateProjectAdmin(context.Context, *MsgUpdateProjectAdmin) (*MsgUpdateProjectAdminResponse, error)
	// UpdateProjectMetadata updates the project metadata. Only the admin of the
	// project can update the project.
	UpdateProjectMetadata(context.Context, *MsgUpdateProjectMetadata) (*MsgUpdateProjectMetadataResponse, error)
	// Bridge processes credits being sent back to the source chain. When credits
	// are sent back to the source chain, the credits are cancelled and an event
	// is emitted to be handled by an external bridge service.
	Bridge(context.Context, *MsgBridge) (*MsgBridgeResponse, error)
	// BridgeReceive processes credits being sent from another chain. When the
	// credits are sent from the same vintage as an existing credit batch within
	// the scope of the provided credit class, the credits will be minted to the
	// existing credit batch, otherwise the credits will be issued in a new credit
	// batch. The new credit batch will be created under an existing project if a
	// project with a matching reference id already exists within the scope of the
	// credit class, otherwise a new project will be created.
	BridgeReceive(context.Context, *MsgBridgeReceive) (*MsgBridgeReceiveResponse, error)
	// AddCreditType is a governance method that allows the addition of new
	// credit types to the network.
	//
	// Since Revision 1
	AddCreditType(context.Context, *MsgAddCreditType) (*MsgAddCreditTypeResponse, error)
	// SetClassCreatorAllowlist is a governance method that updates the class
	// creator allowlist enabled setting. When enabled, only addresses listed in
	// the allowlist can create credit classes. When disabled, any address can
	// create credit classes.
	//
	// Since Revision 1
	SetClassCreatorAllowlist(context.Context, *MsgSetClassCreatorAllowlist) (*MsgSetClassCreatorAllowlistResponse, error)
	// AddClassCreator is a governance method that allows the addition of new
	// address to the class creation allowlist.
	//
	// Since Revision 1
	AddClassCreator(context.Context, *MsgAddClassCreator) (*MsgAddClassCreatorResponse, error)
	// RemoveClassCreator is a governance method that removes
	// address from the creation allowlist.
	//
	// Since Revision 1
	RemoveClassCreator(context.Context, *MsgRemoveClassCreator) (*MsgRemoveClassCreatorResponse, error)
	// UpdateClassFees is a governance method that allows for the addition and
	// removal of fees to be used for the class creation fee.
	//
	// Since Revision 1
	UpdateClassFees(context.Context, *MsgUpdateClassFees) (*MsgUpdateClassFeesResponse, error)
	mustEmbedUnimplementedMsgServer()
}

// UnimplementedMsgServer must be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (UnimplementedMsgServer) CreateClass(context.Context, *MsgCreateClass) (*MsgCreateClassResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateClass not implemented")
}
func (UnimplementedMsgServer) CreateProject(context.Context, *MsgCreateProject) (*MsgCreateProjectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateProject not implemented")
}
func (UnimplementedMsgServer) CreateBatch(context.Context, *MsgCreateBatch) (*MsgCreateBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBatch not implemented")
}
func (UnimplementedMsgServer) MintBatchCredits(context.Context, *MsgMintBatchCredits) (*MsgMintBatchCreditsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MintBatchCredits not implemented")
}
func (UnimplementedMsgServer) SealBatch(context.Context, *MsgSealBatch) (*MsgSealBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SealBatch not implemented")
}
func (UnimplementedMsgServer) Send(context.Context, *MsgSend) (*MsgSendResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Send not implemented")
}
func (UnimplementedMsgServer) Retire(context.Context, *MsgRetire) (*MsgRetireResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Retire not implemented")
}
func (UnimplementedMsgServer) Cancel(context.Context, *MsgCancel) (*MsgCancelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Cancel not implemented")
}
func (UnimplementedMsgServer) UpdateClassAdmin(context.Context, *MsgUpdateClassAdmin) (*MsgUpdateClassAdminResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateClassAdmin not implemented")
}
func (UnimplementedMsgServer) UpdateClassIssuers(context.Context, *MsgUpdateClassIssuers) (*MsgUpdateClassIssuersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateClassIssuers not implemented")
}
func (UnimplementedMsgServer) UpdateClassMetadata(context.Context, *MsgUpdateClassMetadata) (*MsgUpdateClassMetadataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateClassMetadata not implemented")
}
func (UnimplementedMsgServer) UpdateProjectAdmin(context.Context, *MsgUpdateProjectAdmin) (*MsgUpdateProjectAdminResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateProjectAdmin not implemented")
}
func (UnimplementedMsgServer) UpdateProjectMetadata(context.Context, *MsgUpdateProjectMetadata) (*MsgUpdateProjectMetadataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateProjectMetadata not implemented")
}
func (UnimplementedMsgServer) Bridge(context.Context, *MsgBridge) (*MsgBridgeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Bridge not implemented")
}
func (UnimplementedMsgServer) BridgeReceive(context.Context, *MsgBridgeReceive) (*MsgBridgeReceiveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BridgeReceive not implemented")
}
func (UnimplementedMsgServer) AddCreditType(context.Context, *MsgAddCreditType) (*MsgAddCreditTypeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddCreditType not implemented")
}
func (UnimplementedMsgServer) SetClassCreatorAllowlist(context.Context, *MsgSetClassCreatorAllowlist) (*MsgSetClassCreatorAllowlistResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetClassCreatorAllowlist not implemented")
}
func (UnimplementedMsgServer) AddClassCreator(context.Context, *MsgAddClassCreator) (*MsgAddClassCreatorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddClassCreator not implemented")
}
func (UnimplementedMsgServer) RemoveClassCreator(context.Context, *MsgRemoveClassCreator) (*MsgRemoveClassCreatorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveClassCreator not implemented")
}
func (UnimplementedMsgServer) UpdateClassFees(context.Context, *MsgUpdateClassFees) (*MsgUpdateClassFeesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateClassFees not implemented")
}
func (UnimplementedMsgServer) mustEmbedUnimplementedMsgServer() {}

// UnsafeMsgServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MsgServer will
// result in compilation errors.
type UnsafeMsgServer interface {
	mustEmbedUnimplementedMsgServer()
}

func RegisterMsgServer(s grpc.ServiceRegistrar, srv MsgServer) {
	s.RegisterService(&Msg_ServiceDesc, srv)
}

func _Msg_CreateClass_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateClass)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateClass(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.v1.Msg/CreateClass",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateClass(ctx, req.(*MsgCreateClass))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateProject)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.v1.Msg/CreateProject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateProject(ctx, req.(*MsgCreateProject))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateBatch)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.v1.Msg/CreateBatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateBatch(ctx, req.(*MsgCreateBatch))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_MintBatchCredits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgMintBatchCredits)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).MintBatchCredits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.v1.Msg/MintBatchCredits",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).MintBatchCredits(ctx, req.(*MsgMintBatchCredits))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SealBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSealBatch)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SealBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.v1.Msg/SealBatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SealBatch(ctx, req.(*MsgSealBatch))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Send_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSend)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Send(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.v1.Msg/Send",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Send(ctx, req.(*MsgSend))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Retire_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRetire)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Retire(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.v1.Msg/Retire",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Retire(ctx, req.(*MsgRetire))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Cancel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCancel)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Cancel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.v1.Msg/Cancel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Cancel(ctx, req.(*MsgCancel))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateClassAdmin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateClassAdmin)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateClassAdmin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.v1.Msg/UpdateClassAdmin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateClassAdmin(ctx, req.(*MsgUpdateClassAdmin))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateClassIssuers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateClassIssuers)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateClassIssuers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.v1.Msg/UpdateClassIssuers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateClassIssuers(ctx, req.(*MsgUpdateClassIssuers))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateClassMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateClassMetadata)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateClassMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.v1.Msg/UpdateClassMetadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateClassMetadata(ctx, req.(*MsgUpdateClassMetadata))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateProjectAdmin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateProjectAdmin)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateProjectAdmin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.v1.Msg/UpdateProjectAdmin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateProjectAdmin(ctx, req.(*MsgUpdateProjectAdmin))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateProjectMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateProjectMetadata)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateProjectMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.v1.Msg/UpdateProjectMetadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateProjectMetadata(ctx, req.(*MsgUpdateProjectMetadata))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Bridge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBridge)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Bridge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.v1.Msg/Bridge",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Bridge(ctx, req.(*MsgBridge))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_BridgeReceive_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBridgeReceive)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).BridgeReceive(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.v1.Msg/BridgeReceive",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).BridgeReceive(ctx, req.(*MsgBridgeReceive))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_AddCreditType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgAddCreditType)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).AddCreditType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.v1.Msg/AddCreditType",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).AddCreditType(ctx, req.(*MsgAddCreditType))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetClassCreatorAllowlist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetClassCreatorAllowlist)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetClassCreatorAllowlist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.v1.Msg/SetClassCreatorAllowlist",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetClassCreatorAllowlist(ctx, req.(*MsgSetClassCreatorAllowlist))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_AddClassCreator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgAddClassCreator)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).AddClassCreator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.v1.Msg/AddClassCreator",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).AddClassCreator(ctx, req.(*MsgAddClassCreator))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RemoveClassCreator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRemoveClassCreator)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RemoveClassCreator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.v1.Msg/RemoveClassCreator",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RemoveClassCreator(ctx, req.(*MsgRemoveClassCreator))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateClassFees_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateClassFees)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateClassFees(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.v1.Msg/UpdateClassFees",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateClassFees(ctx, req.(*MsgUpdateClassFees))
	}
	return interceptor(ctx, in, info, handler)
}

// Msg_ServiceDesc is the grpc.ServiceDesc for Msg service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Msg_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "regen.ecocredit.v1.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateClass",
			Handler:    _Msg_CreateClass_Handler,
		},
		{
			MethodName: "CreateProject",
			Handler:    _Msg_CreateProject_Handler,
		},
		{
			MethodName: "CreateBatch",
			Handler:    _Msg_CreateBatch_Handler,
		},
		{
			MethodName: "MintBatchCredits",
			Handler:    _Msg_MintBatchCredits_Handler,
		},
		{
			MethodName: "SealBatch",
			Handler:    _Msg_SealBatch_Handler,
		},
		{
			MethodName: "Send",
			Handler:    _Msg_Send_Handler,
		},
		{
			MethodName: "Retire",
			Handler:    _Msg_Retire_Handler,
		},
		{
			MethodName: "Cancel",
			Handler:    _Msg_Cancel_Handler,
		},
		{
			MethodName: "UpdateClassAdmin",
			Handler:    _Msg_UpdateClassAdmin_Handler,
		},
		{
			MethodName: "UpdateClassIssuers",
			Handler:    _Msg_UpdateClassIssuers_Handler,
		},
		{
			MethodName: "UpdateClassMetadata",
			Handler:    _Msg_UpdateClassMetadata_Handler,
		},
		{
			MethodName: "UpdateProjectAdmin",
			Handler:    _Msg_UpdateProjectAdmin_Handler,
		},
		{
			MethodName: "UpdateProjectMetadata",
			Handler:    _Msg_UpdateProjectMetadata_Handler,
		},
		{
			MethodName: "Bridge",
			Handler:    _Msg_Bridge_Handler,
		},
		{
			MethodName: "BridgeReceive",
			Handler:    _Msg_BridgeReceive_Handler,
		},
		{
			MethodName: "AddCreditType",
			Handler:    _Msg_AddCreditType_Handler,
		},
		{
			MethodName: "SetClassCreatorAllowlist",
			Handler:    _Msg_SetClassCreatorAllowlist_Handler,
		},
		{
			MethodName: "AddClassCreator",
			Handler:    _Msg_AddClassCreator_Handler,
		},
		{
			MethodName: "RemoveClassCreator",
			Handler:    _Msg_RemoveClassCreator_Handler,
		},
		{
			MethodName: "UpdateClassFees",
			Handler:    _Msg_UpdateClassFees_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "regen/ecocredit/v1/tx.proto",
}
