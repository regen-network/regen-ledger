// Code generated by protoc-gen-go-cosmos-orm. DO NOT EDIT.

package ecocreditv1beta1

import (
	context "context"
	ormlist "github.com/cosmos/cosmos-sdk/orm/model/ormlist"
	ormtable "github.com/cosmos/cosmos-sdk/orm/model/ormtable"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

type StateStore interface {
	ClassInfo() ClassInfoStore
	ClassIssuer() ClassIssuerStore
	ProjectInfo() ProjectInfoStore
	BatchInfo() BatchInfoStore
	CreditType() CreditTypeStore
	ProjectSequence() ProjectSequenceStore
	EcocreditBalance() EcocreditBalanceStore
	BatchSequence() BatchSequenceStore
	BatchSupply() BatchSupplyStore
}

type ClassInfoStore interface {
	Insert(ctx context.Context, classInfo *ClassInfo) error
	Update(ctx context.Context, classInfo *ClassInfo) error
	Save(ctx context.Context, classInfo *ClassInfo) error
	Delete(ctx context.Context, classInfo *ClassInfo) error
	Has(ctx context.Context, class_id string) (found bool, err error)
	Get(ctx context.Context, class_id string) (*ClassInfo, error)
	List(ctx context.Context, prefixKey ClassInfoIndexKey, opts ...ormlist.Option) (ClassInfoIterator, error)
	ListRange(ctx context.Context, from, to ClassInfoIndexKey, opts ...ormlist.Option) (ClassInfoIterator, error)
}

type ClassInfoIterator struct {
	ormtable.Iterator
}

func (i ClassInfoIterator) Value() (*ClassInfo, error) {
	var classInfo ClassInfo
	err := i.UnmarshalMessage(&classInfo)
	return &classInfo, err
}

type ClassInfoIndexKey interface {
	id() uint32
	values() []interface{}
	classInfoIndexKey()
}

type ClassInfoClassIdIndexKey struct {
	vs []interface{}
}

func (x ClassInfoClassIdIndexKey) id() uint32            { return 1 /* primary key */ }
func (x ClassInfoClassIdIndexKey) values() []interface{} { return x.vs }
func (x ClassInfoClassIdIndexKey) classInfoIndexKey()    {}

var _ ClassInfoIndexKey = ClassInfoClassIdIndexKey{}

func (x ClassInfoClassIdIndexKey) WithClassId(class_id string) ClassInfoClassIdIndexKey {
	x.vs = []interface{}{class_id}
	return x
}

type ClassInfoAdminClassIdIndexKey struct {
	vs []interface{}
}

func (x ClassInfoAdminClassIdIndexKey) id() uint32            { return 1 /* primary key */ }
func (x ClassInfoAdminClassIdIndexKey) values() []interface{} { return x.vs }
func (x ClassInfoAdminClassIdIndexKey) classInfoIndexKey()    {}

var _ ClassInfoIndexKey = ClassInfoAdminClassIdIndexKey{}

func (x ClassInfoAdminClassIdIndexKey) WithAdmin(admin string) ClassInfoAdminClassIdIndexKey {
	x.vs = []interface{}{admin}
	return x
}
func (x ClassInfoAdminClassIdIndexKey) WithAdminClassId(admin string, class_id string) ClassInfoAdminClassIdIndexKey {
	x.vs = []interface{}{admin, class_id}
	return x
}

type ClassInfoCreditTypeClassIdIndexKey struct {
	vs []interface{}
}

func (x ClassInfoCreditTypeClassIdIndexKey) id() uint32            { return 1 /* primary key */ }
func (x ClassInfoCreditTypeClassIdIndexKey) values() []interface{} { return x.vs }
func (x ClassInfoCreditTypeClassIdIndexKey) classInfoIndexKey()    {}

var _ ClassInfoIndexKey = ClassInfoCreditTypeClassIdIndexKey{}

func (x ClassInfoCreditTypeClassIdIndexKey) WithCreditType(credit_type string) ClassInfoCreditTypeClassIdIndexKey {
	x.vs = []interface{}{credit_type}
	return x
}
func (x ClassInfoCreditTypeClassIdIndexKey) WithCreditTypeClassId(credit_type string, class_id string) ClassInfoCreditTypeClassIdIndexKey {
	x.vs = []interface{}{credit_type, class_id}
	return x
}

type classInfoStore struct {
	table ormtable.Table
}

func (x classInfoStore) Insert(ctx context.Context, classInfo *ClassInfo) error {
	return x.table.Insert(ctx, classInfo)
}
func (x classInfoStore) Update(ctx context.Context, classInfo *ClassInfo) error {
	return x.table.Update(ctx, classInfo)
}
func (x classInfoStore) Save(ctx context.Context, classInfo *ClassInfo) error {
	return x.table.Save(ctx, classInfo)
}
func (x classInfoStore) Delete(ctx context.Context, classInfo *ClassInfo) error {
	return x.table.Delete(ctx, classInfo)
}
func (x classInfoStore) Has(ctx context.Context, class_id string) (found bool, err error) {
	return x.table.PrimaryKey().Has(ctx, class_id)
}
func (x classInfoStore) Get(ctx context.Context, class_id string) (*ClassInfo, error) {
	var classInfo ClassInfo
	found, err := x.table.PrimaryKey().Get(ctx, &classInfo, class_id)
	if !found {
		return nil, err
	}
	return &classInfo, err
}
func (x classInfoStore) List(ctx context.Context, prefixKey ClassInfoIndexKey, opts ...ormlist.Option) (ClassInfoIterator, error) {
	opts = append(opts, ormlist.Prefix(prefixKey.values()))
	it, err := x.table.GetIndexByID(prefixKey.id()).Iterator(ctx, opts...)
	return ClassInfoIterator{it}, err
}
func (x classInfoStore) ListRange(ctx context.Context, from, to ClassInfoIndexKey, opts ...ormlist.Option) (ClassInfoIterator, error) {
	opts = append(opts, ormlist.Start(from.values()), ormlist.End(to))
	it, err := x.table.GetIndexByID(from.id()).Iterator(ctx, opts...)
	return ClassInfoIterator{it}, err
}

var _ ClassInfoStore = classInfoStore{}

type ClassIssuerStore interface {
	Insert(ctx context.Context, classIssuer *ClassIssuer) error
	Update(ctx context.Context, classIssuer *ClassIssuer) error
	Save(ctx context.Context, classIssuer *ClassIssuer) error
	Delete(ctx context.Context, classIssuer *ClassIssuer) error
	Has(ctx context.Context, class_id string, issuer string) (found bool, err error)
	Get(ctx context.Context, class_id string, issuer string) (*ClassIssuer, error)
	List(ctx context.Context, prefixKey ClassIssuerIndexKey, opts ...ormlist.Option) (ClassIssuerIterator, error)
	ListRange(ctx context.Context, from, to ClassIssuerIndexKey, opts ...ormlist.Option) (ClassIssuerIterator, error)
}

type ClassIssuerIterator struct {
	ormtable.Iterator
}

func (i ClassIssuerIterator) Value() (*ClassIssuer, error) {
	var classIssuer ClassIssuer
	err := i.UnmarshalMessage(&classIssuer)
	return &classIssuer, err
}

type ClassIssuerIndexKey interface {
	id() uint32
	values() []interface{}
	classIssuerIndexKey()
}

type ClassIssuerClassIdIssuerIndexKey struct {
	vs []interface{}
}

func (x ClassIssuerClassIdIssuerIndexKey) id() uint32            { return 2 /* primary key */ }
func (x ClassIssuerClassIdIssuerIndexKey) values() []interface{} { return x.vs }
func (x ClassIssuerClassIdIssuerIndexKey) classIssuerIndexKey()  {}

var _ ClassIssuerIndexKey = ClassIssuerClassIdIssuerIndexKey{}

func (x ClassIssuerClassIdIssuerIndexKey) WithClassId(class_id string) ClassIssuerClassIdIssuerIndexKey {
	x.vs = []interface{}{class_id}
	return x
}
func (x ClassIssuerClassIdIssuerIndexKey) WithClassIdIssuer(class_id string, issuer string) ClassIssuerClassIdIssuerIndexKey {
	x.vs = []interface{}{class_id, issuer}
	return x
}

type classIssuerStore struct {
	table ormtable.Table
}

func (x classIssuerStore) Insert(ctx context.Context, classIssuer *ClassIssuer) error {
	return x.table.Insert(ctx, classIssuer)
}
func (x classIssuerStore) Update(ctx context.Context, classIssuer *ClassIssuer) error {
	return x.table.Update(ctx, classIssuer)
}
func (x classIssuerStore) Save(ctx context.Context, classIssuer *ClassIssuer) error {
	return x.table.Save(ctx, classIssuer)
}
func (x classIssuerStore) Delete(ctx context.Context, classIssuer *ClassIssuer) error {
	return x.table.Delete(ctx, classIssuer)
}
func (x classIssuerStore) Has(ctx context.Context, class_id string, issuer string) (found bool, err error) {
	return x.table.PrimaryKey().Has(ctx, class_id, issuer)
}
func (x classIssuerStore) Get(ctx context.Context, class_id string, issuer string) (*ClassIssuer, error) {
	var classIssuer ClassIssuer
	found, err := x.table.PrimaryKey().Get(ctx, &classIssuer, class_id, issuer)
	if !found {
		return nil, err
	}
	return &classIssuer, err
}
func (x classIssuerStore) List(ctx context.Context, prefixKey ClassIssuerIndexKey, opts ...ormlist.Option) (ClassIssuerIterator, error) {
	opts = append(opts, ormlist.Prefix(prefixKey.values()))
	it, err := x.table.GetIndexByID(prefixKey.id()).Iterator(ctx, opts...)
	return ClassIssuerIterator{it}, err
}
func (x classIssuerStore) ListRange(ctx context.Context, from, to ClassIssuerIndexKey, opts ...ormlist.Option) (ClassIssuerIterator, error) {
	opts = append(opts, ormlist.Start(from.values()), ormlist.End(to))
	it, err := x.table.GetIndexByID(from.id()).Iterator(ctx, opts...)
	return ClassIssuerIterator{it}, err
}

var _ ClassIssuerStore = classIssuerStore{}

type ProjectInfoStore interface {
	Insert(ctx context.Context, projectInfo *ProjectInfo) error
	Update(ctx context.Context, projectInfo *ProjectInfo) error
	Save(ctx context.Context, projectInfo *ProjectInfo) error
	Delete(ctx context.Context, projectInfo *ProjectInfo) error
	Has(ctx context.Context, project_id string) (found bool, err error)
	Get(ctx context.Context, project_id string) (*ProjectInfo, error)
	List(ctx context.Context, prefixKey ProjectInfoIndexKey, opts ...ormlist.Option) (ProjectInfoIterator, error)
	ListRange(ctx context.Context, from, to ProjectInfoIndexKey, opts ...ormlist.Option) (ProjectInfoIterator, error)
}

type ProjectInfoIterator struct {
	ormtable.Iterator
}

func (i ProjectInfoIterator) Value() (*ProjectInfo, error) {
	var projectInfo ProjectInfo
	err := i.UnmarshalMessage(&projectInfo)
	return &projectInfo, err
}

type ProjectInfoIndexKey interface {
	id() uint32
	values() []interface{}
	projectInfoIndexKey()
}

type ProjectInfoProjectIdIndexKey struct {
	vs []interface{}
}

func (x ProjectInfoProjectIdIndexKey) id() uint32            { return 3 /* primary key */ }
func (x ProjectInfoProjectIdIndexKey) values() []interface{} { return x.vs }
func (x ProjectInfoProjectIdIndexKey) projectInfoIndexKey()  {}

var _ ProjectInfoIndexKey = ProjectInfoProjectIdIndexKey{}

func (x ProjectInfoProjectIdIndexKey) WithProjectId(project_id string) ProjectInfoProjectIdIndexKey {
	x.vs = []interface{}{project_id}
	return x
}

type ProjectInfoIssuerProjectIdIndexKey struct {
	vs []interface{}
}

func (x ProjectInfoIssuerProjectIdIndexKey) id() uint32            { return 3 /* primary key */ }
func (x ProjectInfoIssuerProjectIdIndexKey) values() []interface{} { return x.vs }
func (x ProjectInfoIssuerProjectIdIndexKey) projectInfoIndexKey()  {}

var _ ProjectInfoIndexKey = ProjectInfoIssuerProjectIdIndexKey{}

func (x ProjectInfoIssuerProjectIdIndexKey) WithIssuer(issuer string) ProjectInfoIssuerProjectIdIndexKey {
	x.vs = []interface{}{issuer}
	return x
}
func (x ProjectInfoIssuerProjectIdIndexKey) WithIssuerProjectId(issuer string, project_id string) ProjectInfoIssuerProjectIdIndexKey {
	x.vs = []interface{}{issuer, project_id}
	return x
}

type ProjectInfoClassIdProjectIdIndexKey struct {
	vs []interface{}
}

func (x ProjectInfoClassIdProjectIdIndexKey) id() uint32            { return 3 /* primary key */ }
func (x ProjectInfoClassIdProjectIdIndexKey) values() []interface{} { return x.vs }
func (x ProjectInfoClassIdProjectIdIndexKey) projectInfoIndexKey()  {}

var _ ProjectInfoIndexKey = ProjectInfoClassIdProjectIdIndexKey{}

func (x ProjectInfoClassIdProjectIdIndexKey) WithClassId(class_id string) ProjectInfoClassIdProjectIdIndexKey {
	x.vs = []interface{}{class_id}
	return x
}
func (x ProjectInfoClassIdProjectIdIndexKey) WithClassIdProjectId(class_id string, project_id string) ProjectInfoClassIdProjectIdIndexKey {
	x.vs = []interface{}{class_id, project_id}
	return x
}

type projectInfoStore struct {
	table ormtable.Table
}

func (x projectInfoStore) Insert(ctx context.Context, projectInfo *ProjectInfo) error {
	return x.table.Insert(ctx, projectInfo)
}
func (x projectInfoStore) Update(ctx context.Context, projectInfo *ProjectInfo) error {
	return x.table.Update(ctx, projectInfo)
}
func (x projectInfoStore) Save(ctx context.Context, projectInfo *ProjectInfo) error {
	return x.table.Save(ctx, projectInfo)
}
func (x projectInfoStore) Delete(ctx context.Context, projectInfo *ProjectInfo) error {
	return x.table.Delete(ctx, projectInfo)
}
func (x projectInfoStore) Has(ctx context.Context, project_id string) (found bool, err error) {
	return x.table.PrimaryKey().Has(ctx, project_id)
}
func (x projectInfoStore) Get(ctx context.Context, project_id string) (*ProjectInfo, error) {
	var projectInfo ProjectInfo
	found, err := x.table.PrimaryKey().Get(ctx, &projectInfo, project_id)
	if !found {
		return nil, err
	}
	return &projectInfo, err
}
func (x projectInfoStore) List(ctx context.Context, prefixKey ProjectInfoIndexKey, opts ...ormlist.Option) (ProjectInfoIterator, error) {
	opts = append(opts, ormlist.Prefix(prefixKey.values()))
	it, err := x.table.GetIndexByID(prefixKey.id()).Iterator(ctx, opts...)
	return ProjectInfoIterator{it}, err
}
func (x projectInfoStore) ListRange(ctx context.Context, from, to ProjectInfoIndexKey, opts ...ormlist.Option) (ProjectInfoIterator, error) {
	opts = append(opts, ormlist.Start(from.values()), ormlist.End(to))
	it, err := x.table.GetIndexByID(from.id()).Iterator(ctx, opts...)
	return ProjectInfoIterator{it}, err
}

var _ ProjectInfoStore = projectInfoStore{}

type BatchInfoStore interface {
	Insert(ctx context.Context, batchInfo *BatchInfo) error
	Update(ctx context.Context, batchInfo *BatchInfo) error
	Save(ctx context.Context, batchInfo *BatchInfo) error
	Delete(ctx context.Context, batchInfo *BatchInfo) error
	Has(ctx context.Context, id uint64) (found bool, err error)
	Get(ctx context.Context, id uint64) (*BatchInfo, error)
	List(ctx context.Context, prefixKey BatchInfoIndexKey, opts ...ormlist.Option) (BatchInfoIterator, error)
	ListRange(ctx context.Context, from, to BatchInfoIndexKey, opts ...ormlist.Option) (BatchInfoIterator, error)
}

type BatchInfoIterator struct {
	ormtable.Iterator
}

func (i BatchInfoIterator) Value() (*BatchInfo, error) {
	var batchInfo BatchInfo
	err := i.UnmarshalMessage(&batchInfo)
	return &batchInfo, err
}

type BatchInfoIndexKey interface {
	id() uint32
	values() []interface{}
	batchInfoIndexKey()
}

type BatchInfoIdIndexKey struct {
	vs []interface{}
}

func (x BatchInfoIdIndexKey) id() uint32            { return 4 /* primary key */ }
func (x BatchInfoIdIndexKey) values() []interface{} { return x.vs }
func (x BatchInfoIdIndexKey) batchInfoIndexKey()    {}

var _ BatchInfoIndexKey = BatchInfoIdIndexKey{}

func (x BatchInfoIdIndexKey) WithId(id uint64) BatchInfoIdIndexKey {
	x.vs = []interface{}{id}
	return x
}

type BatchInfoBatchDenomIndexKey struct {
	vs []interface{}
}

func (x BatchInfoBatchDenomIndexKey) id() uint32            { return 4 /* primary key */ }
func (x BatchInfoBatchDenomIndexKey) values() []interface{} { return x.vs }
func (x BatchInfoBatchDenomIndexKey) batchInfoIndexKey()    {}

var _ BatchInfoIndexKey = BatchInfoBatchDenomIndexKey{}

func (x BatchInfoBatchDenomIndexKey) WithBatchDenom(batch_denom string) BatchInfoBatchDenomIndexKey {
	x.vs = []interface{}{batch_denom}
	return x
}

type BatchInfoProjectIdIdIndexKey struct {
	vs []interface{}
}

func (x BatchInfoProjectIdIdIndexKey) id() uint32            { return 4 /* primary key */ }
func (x BatchInfoProjectIdIdIndexKey) values() []interface{} { return x.vs }
func (x BatchInfoProjectIdIdIndexKey) batchInfoIndexKey()    {}

var _ BatchInfoIndexKey = BatchInfoProjectIdIdIndexKey{}

func (x BatchInfoProjectIdIdIndexKey) WithProjectId(project_id string) BatchInfoProjectIdIdIndexKey {
	x.vs = []interface{}{project_id}
	return x
}
func (x BatchInfoProjectIdIdIndexKey) WithProjectIdId(project_id string, id uint64) BatchInfoProjectIdIdIndexKey {
	x.vs = []interface{}{project_id, id}
	return x
}

type BatchInfoStartDateIdIndexKey struct {
	vs []interface{}
}

func (x BatchInfoStartDateIdIndexKey) id() uint32            { return 4 /* primary key */ }
func (x BatchInfoStartDateIdIndexKey) values() []interface{} { return x.vs }
func (x BatchInfoStartDateIdIndexKey) batchInfoIndexKey()    {}

var _ BatchInfoIndexKey = BatchInfoStartDateIdIndexKey{}

func (x BatchInfoStartDateIdIndexKey) WithStartDate(start_date *timestamppb.Timestamp) BatchInfoStartDateIdIndexKey {
	x.vs = []interface{}{start_date}
	return x
}
func (x BatchInfoStartDateIdIndexKey) WithStartDateId(start_date *timestamppb.Timestamp, id uint64) BatchInfoStartDateIdIndexKey {
	x.vs = []interface{}{start_date, id}
	return x
}

type batchInfoStore struct {
	table ormtable.Table
}

func (x batchInfoStore) Insert(ctx context.Context, batchInfo *BatchInfo) error {
	return x.table.Insert(ctx, batchInfo)
}
func (x batchInfoStore) Update(ctx context.Context, batchInfo *BatchInfo) error {
	return x.table.Update(ctx, batchInfo)
}
func (x batchInfoStore) Save(ctx context.Context, batchInfo *BatchInfo) error {
	return x.table.Save(ctx, batchInfo)
}
func (x batchInfoStore) Delete(ctx context.Context, batchInfo *BatchInfo) error {
	return x.table.Delete(ctx, batchInfo)
}
func (x batchInfoStore) Has(ctx context.Context, id uint64) (found bool, err error) {
	return x.table.PrimaryKey().Has(ctx, id)
}
func (x batchInfoStore) Get(ctx context.Context, id uint64) (*BatchInfo, error) {
	var batchInfo BatchInfo
	found, err := x.table.PrimaryKey().Get(ctx, &batchInfo, id)
	if !found {
		return nil, err
	}
	return &batchInfo, err
}
func (x batchInfoStore) List(ctx context.Context, prefixKey BatchInfoIndexKey, opts ...ormlist.Option) (BatchInfoIterator, error) {
	opts = append(opts, ormlist.Prefix(prefixKey.values()))
	it, err := x.table.GetIndexByID(prefixKey.id()).Iterator(ctx, opts...)
	return BatchInfoIterator{it}, err
}
func (x batchInfoStore) ListRange(ctx context.Context, from, to BatchInfoIndexKey, opts ...ormlist.Option) (BatchInfoIterator, error) {
	opts = append(opts, ormlist.Start(from.values()), ormlist.End(to))
	it, err := x.table.GetIndexByID(from.id()).Iterator(ctx, opts...)
	return BatchInfoIterator{it}, err
}

var _ BatchInfoStore = batchInfoStore{}

type CreditTypeStore interface {
	Insert(ctx context.Context, creditType *CreditType) error
	Update(ctx context.Context, creditType *CreditType) error
	Save(ctx context.Context, creditType *CreditType) error
	Delete(ctx context.Context, creditType *CreditType) error
	Has(ctx context.Context, abbreviation string) (found bool, err error)
	Get(ctx context.Context, abbreviation string) (*CreditType, error)
	List(ctx context.Context, prefixKey CreditTypeIndexKey, opts ...ormlist.Option) (CreditTypeIterator, error)
	ListRange(ctx context.Context, from, to CreditTypeIndexKey, opts ...ormlist.Option) (CreditTypeIterator, error)
}

type CreditTypeIterator struct {
	ormtable.Iterator
}

func (i CreditTypeIterator) Value() (*CreditType, error) {
	var creditType CreditType
	err := i.UnmarshalMessage(&creditType)
	return &creditType, err
}

type CreditTypeIndexKey interface {
	id() uint32
	values() []interface{}
	creditTypeIndexKey()
}

type CreditTypeAbbreviationIndexKey struct {
	vs []interface{}
}

func (x CreditTypeAbbreviationIndexKey) id() uint32            { return 5 /* primary key */ }
func (x CreditTypeAbbreviationIndexKey) values() []interface{} { return x.vs }
func (x CreditTypeAbbreviationIndexKey) creditTypeIndexKey()   {}

var _ CreditTypeIndexKey = CreditTypeAbbreviationIndexKey{}

func (x CreditTypeAbbreviationIndexKey) WithAbbreviation(abbreviation string) CreditTypeAbbreviationIndexKey {
	x.vs = []interface{}{abbreviation}
	return x
}

type creditTypeStore struct {
	table ormtable.Table
}

func (x creditTypeStore) Insert(ctx context.Context, creditType *CreditType) error {
	return x.table.Insert(ctx, creditType)
}
func (x creditTypeStore) Update(ctx context.Context, creditType *CreditType) error {
	return x.table.Update(ctx, creditType)
}
func (x creditTypeStore) Save(ctx context.Context, creditType *CreditType) error {
	return x.table.Save(ctx, creditType)
}
func (x creditTypeStore) Delete(ctx context.Context, creditType *CreditType) error {
	return x.table.Delete(ctx, creditType)
}
func (x creditTypeStore) Has(ctx context.Context, abbreviation string) (found bool, err error) {
	return x.table.PrimaryKey().Has(ctx, abbreviation)
}
func (x creditTypeStore) Get(ctx context.Context, abbreviation string) (*CreditType, error) {
	var creditType CreditType
	found, err := x.table.PrimaryKey().Get(ctx, &creditType, abbreviation)
	if !found {
		return nil, err
	}
	return &creditType, err
}
func (x creditTypeStore) List(ctx context.Context, prefixKey CreditTypeIndexKey, opts ...ormlist.Option) (CreditTypeIterator, error) {
	opts = append(opts, ormlist.Prefix(prefixKey.values()))
	it, err := x.table.GetIndexByID(prefixKey.id()).Iterator(ctx, opts...)
	return CreditTypeIterator{it}, err
}
func (x creditTypeStore) ListRange(ctx context.Context, from, to CreditTypeIndexKey, opts ...ormlist.Option) (CreditTypeIterator, error) {
	opts = append(opts, ormlist.Start(from.values()), ormlist.End(to))
	it, err := x.table.GetIndexByID(from.id()).Iterator(ctx, opts...)
	return CreditTypeIterator{it}, err
}

var _ CreditTypeStore = creditTypeStore{}

type ProjectSequenceStore interface {
	Insert(ctx context.Context, projectSequence *ProjectSequence) error
	Update(ctx context.Context, projectSequence *ProjectSequence) error
	Save(ctx context.Context, projectSequence *ProjectSequence) error
	Delete(ctx context.Context, projectSequence *ProjectSequence) error
	Has(ctx context.Context, project_id string) (found bool, err error)
	Get(ctx context.Context, project_id string) (*ProjectSequence, error)
	List(ctx context.Context, prefixKey ProjectSequenceIndexKey, opts ...ormlist.Option) (ProjectSequenceIterator, error)
	ListRange(ctx context.Context, from, to ProjectSequenceIndexKey, opts ...ormlist.Option) (ProjectSequenceIterator, error)
}

type ProjectSequenceIterator struct {
	ormtable.Iterator
}

func (i ProjectSequenceIterator) Value() (*ProjectSequence, error) {
	var projectSequence ProjectSequence
	err := i.UnmarshalMessage(&projectSequence)
	return &projectSequence, err
}

type ProjectSequenceIndexKey interface {
	id() uint32
	values() []interface{}
	projectSequenceIndexKey()
}

type ProjectSequenceProjectIdIndexKey struct {
	vs []interface{}
}

func (x ProjectSequenceProjectIdIndexKey) id() uint32               { return 7 /* primary key */ }
func (x ProjectSequenceProjectIdIndexKey) values() []interface{}    { return x.vs }
func (x ProjectSequenceProjectIdIndexKey) projectSequenceIndexKey() {}

var _ ProjectSequenceIndexKey = ProjectSequenceProjectIdIndexKey{}

func (x ProjectSequenceProjectIdIndexKey) WithProjectId(project_id string) ProjectSequenceProjectIdIndexKey {
	x.vs = []interface{}{project_id}
	return x
}

type projectSequenceStore struct {
	table ormtable.Table
}

func (x projectSequenceStore) Insert(ctx context.Context, projectSequence *ProjectSequence) error {
	return x.table.Insert(ctx, projectSequence)
}
func (x projectSequenceStore) Update(ctx context.Context, projectSequence *ProjectSequence) error {
	return x.table.Update(ctx, projectSequence)
}
func (x projectSequenceStore) Save(ctx context.Context, projectSequence *ProjectSequence) error {
	return x.table.Save(ctx, projectSequence)
}
func (x projectSequenceStore) Delete(ctx context.Context, projectSequence *ProjectSequence) error {
	return x.table.Delete(ctx, projectSequence)
}
func (x projectSequenceStore) Has(ctx context.Context, project_id string) (found bool, err error) {
	return x.table.PrimaryKey().Has(ctx, project_id)
}
func (x projectSequenceStore) Get(ctx context.Context, project_id string) (*ProjectSequence, error) {
	var projectSequence ProjectSequence
	found, err := x.table.PrimaryKey().Get(ctx, &projectSequence, project_id)
	if !found {
		return nil, err
	}
	return &projectSequence, err
}
func (x projectSequenceStore) List(ctx context.Context, prefixKey ProjectSequenceIndexKey, opts ...ormlist.Option) (ProjectSequenceIterator, error) {
	opts = append(opts, ormlist.Prefix(prefixKey.values()))
	it, err := x.table.GetIndexByID(prefixKey.id()).Iterator(ctx, opts...)
	return ProjectSequenceIterator{it}, err
}
func (x projectSequenceStore) ListRange(ctx context.Context, from, to ProjectSequenceIndexKey, opts ...ormlist.Option) (ProjectSequenceIterator, error) {
	opts = append(opts, ormlist.Start(from.values()), ormlist.End(to))
	it, err := x.table.GetIndexByID(from.id()).Iterator(ctx, opts...)
	return ProjectSequenceIterator{it}, err
}

var _ ProjectSequenceStore = projectSequenceStore{}

type EcocreditBalanceStore interface {
	Insert(ctx context.Context, ecocreditBalance *EcocreditBalance) error
	Update(ctx context.Context, ecocreditBalance *EcocreditBalance) error
	Save(ctx context.Context, ecocreditBalance *EcocreditBalance) error
	Delete(ctx context.Context, ecocreditBalance *EcocreditBalance) error
	Has(ctx context.Context, address []byte, batch_id uint64) (found bool, err error)
	Get(ctx context.Context, address []byte, batch_id uint64) (*EcocreditBalance, error)
	List(ctx context.Context, prefixKey EcocreditBalanceIndexKey, opts ...ormlist.Option) (EcocreditBalanceIterator, error)
	ListRange(ctx context.Context, from, to EcocreditBalanceIndexKey, opts ...ormlist.Option) (EcocreditBalanceIterator, error)
}

type EcocreditBalanceIterator struct {
	ormtable.Iterator
}

func (i EcocreditBalanceIterator) Value() (*EcocreditBalance, error) {
	var ecocreditBalance EcocreditBalance
	err := i.UnmarshalMessage(&ecocreditBalance)
	return &ecocreditBalance, err
}

type EcocreditBalanceIndexKey interface {
	id() uint32
	values() []interface{}
	ecocreditBalanceIndexKey()
}

type EcocreditBalanceAddressBatchIdIndexKey struct {
	vs []interface{}
}

func (x EcocreditBalanceAddressBatchIdIndexKey) id() uint32                { return 8 /* primary key */ }
func (x EcocreditBalanceAddressBatchIdIndexKey) values() []interface{}     { return x.vs }
func (x EcocreditBalanceAddressBatchIdIndexKey) ecocreditBalanceIndexKey() {}

var _ EcocreditBalanceIndexKey = EcocreditBalanceAddressBatchIdIndexKey{}

func (x EcocreditBalanceAddressBatchIdIndexKey) WithAddress(address []byte) EcocreditBalanceAddressBatchIdIndexKey {
	x.vs = []interface{}{address}
	return x
}
func (x EcocreditBalanceAddressBatchIdIndexKey) WithAddressBatchId(address []byte, batch_id uint64) EcocreditBalanceAddressBatchIdIndexKey {
	x.vs = []interface{}{address, batch_id}
	return x
}

type EcocreditBalanceBatchIdAddressIndexKey struct {
	vs []interface{}
}

func (x EcocreditBalanceBatchIdAddressIndexKey) id() uint32                { return 8 /* primary key */ }
func (x EcocreditBalanceBatchIdAddressIndexKey) values() []interface{}     { return x.vs }
func (x EcocreditBalanceBatchIdAddressIndexKey) ecocreditBalanceIndexKey() {}

var _ EcocreditBalanceIndexKey = EcocreditBalanceBatchIdAddressIndexKey{}

func (x EcocreditBalanceBatchIdAddressIndexKey) WithBatchId(batch_id uint64) EcocreditBalanceBatchIdAddressIndexKey {
	x.vs = []interface{}{batch_id}
	return x
}
func (x EcocreditBalanceBatchIdAddressIndexKey) WithBatchIdAddress(batch_id uint64, address []byte) EcocreditBalanceBatchIdAddressIndexKey {
	x.vs = []interface{}{batch_id, address}
	return x
}

type ecocreditBalanceStore struct {
	table ormtable.Table
}

func (x ecocreditBalanceStore) Insert(ctx context.Context, ecocreditBalance *EcocreditBalance) error {
	return x.table.Insert(ctx, ecocreditBalance)
}
func (x ecocreditBalanceStore) Update(ctx context.Context, ecocreditBalance *EcocreditBalance) error {
	return x.table.Update(ctx, ecocreditBalance)
}
func (x ecocreditBalanceStore) Save(ctx context.Context, ecocreditBalance *EcocreditBalance) error {
	return x.table.Save(ctx, ecocreditBalance)
}
func (x ecocreditBalanceStore) Delete(ctx context.Context, ecocreditBalance *EcocreditBalance) error {
	return x.table.Delete(ctx, ecocreditBalance)
}
func (x ecocreditBalanceStore) Has(ctx context.Context, address []byte, batch_id uint64) (found bool, err error) {
	return x.table.PrimaryKey().Has(ctx, address, batch_id)
}
func (x ecocreditBalanceStore) Get(ctx context.Context, address []byte, batch_id uint64) (*EcocreditBalance, error) {
	var ecocreditBalance EcocreditBalance
	found, err := x.table.PrimaryKey().Get(ctx, &ecocreditBalance, address, batch_id)
	if !found {
		return nil, err
	}
	return &ecocreditBalance, err
}
func (x ecocreditBalanceStore) List(ctx context.Context, prefixKey EcocreditBalanceIndexKey, opts ...ormlist.Option) (EcocreditBalanceIterator, error) {
	opts = append(opts, ormlist.Prefix(prefixKey.values()))
	it, err := x.table.GetIndexByID(prefixKey.id()).Iterator(ctx, opts...)
	return EcocreditBalanceIterator{it}, err
}
func (x ecocreditBalanceStore) ListRange(ctx context.Context, from, to EcocreditBalanceIndexKey, opts ...ormlist.Option) (EcocreditBalanceIterator, error) {
	opts = append(opts, ormlist.Start(from.values()), ormlist.End(to))
	it, err := x.table.GetIndexByID(from.id()).Iterator(ctx, opts...)
	return EcocreditBalanceIterator{it}, err
}

var _ EcocreditBalanceStore = ecocreditBalanceStore{}

type BatchSequenceStore interface {
	Insert(ctx context.Context, batchSequence *BatchSequence) error
	Update(ctx context.Context, batchSequence *BatchSequence) error
	Save(ctx context.Context, batchSequence *BatchSequence) error
	Delete(ctx context.Context, batchSequence *BatchSequence) error
	Has(ctx context.Context, project_id string) (found bool, err error)
	Get(ctx context.Context, project_id string) (*BatchSequence, error)
	List(ctx context.Context, prefixKey BatchSequenceIndexKey, opts ...ormlist.Option) (BatchSequenceIterator, error)
	ListRange(ctx context.Context, from, to BatchSequenceIndexKey, opts ...ormlist.Option) (BatchSequenceIterator, error)
}

type BatchSequenceIterator struct {
	ormtable.Iterator
}

func (i BatchSequenceIterator) Value() (*BatchSequence, error) {
	var batchSequence BatchSequence
	err := i.UnmarshalMessage(&batchSequence)
	return &batchSequence, err
}

type BatchSequenceIndexKey interface {
	id() uint32
	values() []interface{}
	batchSequenceIndexKey()
}

type BatchSequenceProjectIdIndexKey struct {
	vs []interface{}
}

func (x BatchSequenceProjectIdIndexKey) id() uint32             { return 9 /* primary key */ }
func (x BatchSequenceProjectIdIndexKey) values() []interface{}  { return x.vs }
func (x BatchSequenceProjectIdIndexKey) batchSequenceIndexKey() {}

var _ BatchSequenceIndexKey = BatchSequenceProjectIdIndexKey{}

func (x BatchSequenceProjectIdIndexKey) WithProjectId(project_id string) BatchSequenceProjectIdIndexKey {
	x.vs = []interface{}{project_id}
	return x
}

type batchSequenceStore struct {
	table ormtable.Table
}

func (x batchSequenceStore) Insert(ctx context.Context, batchSequence *BatchSequence) error {
	return x.table.Insert(ctx, batchSequence)
}
func (x batchSequenceStore) Update(ctx context.Context, batchSequence *BatchSequence) error {
	return x.table.Update(ctx, batchSequence)
}
func (x batchSequenceStore) Save(ctx context.Context, batchSequence *BatchSequence) error {
	return x.table.Save(ctx, batchSequence)
}
func (x batchSequenceStore) Delete(ctx context.Context, batchSequence *BatchSequence) error {
	return x.table.Delete(ctx, batchSequence)
}
func (x batchSequenceStore) Has(ctx context.Context, project_id string) (found bool, err error) {
	return x.table.PrimaryKey().Has(ctx, project_id)
}
func (x batchSequenceStore) Get(ctx context.Context, project_id string) (*BatchSequence, error) {
	var batchSequence BatchSequence
	found, err := x.table.PrimaryKey().Get(ctx, &batchSequence, project_id)
	if !found {
		return nil, err
	}
	return &batchSequence, err
}
func (x batchSequenceStore) List(ctx context.Context, prefixKey BatchSequenceIndexKey, opts ...ormlist.Option) (BatchSequenceIterator, error) {
	opts = append(opts, ormlist.Prefix(prefixKey.values()))
	it, err := x.table.GetIndexByID(prefixKey.id()).Iterator(ctx, opts...)
	return BatchSequenceIterator{it}, err
}
func (x batchSequenceStore) ListRange(ctx context.Context, from, to BatchSequenceIndexKey, opts ...ormlist.Option) (BatchSequenceIterator, error) {
	opts = append(opts, ormlist.Start(from.values()), ormlist.End(to))
	it, err := x.table.GetIndexByID(from.id()).Iterator(ctx, opts...)
	return BatchSequenceIterator{it}, err
}

var _ BatchSequenceStore = batchSequenceStore{}

type BatchSupplyStore interface {
	Insert(ctx context.Context, batchSupply *BatchSupply) error
	Update(ctx context.Context, batchSupply *BatchSupply) error
	Save(ctx context.Context, batchSupply *BatchSupply) error
	Delete(ctx context.Context, batchSupply *BatchSupply) error
	Has(ctx context.Context, id uint64) (found bool, err error)
	Get(ctx context.Context, id uint64) (*BatchSupply, error)
	List(ctx context.Context, prefixKey BatchSupplyIndexKey, opts ...ormlist.Option) (BatchSupplyIterator, error)
	ListRange(ctx context.Context, from, to BatchSupplyIndexKey, opts ...ormlist.Option) (BatchSupplyIterator, error)
}

type BatchSupplyIterator struct {
	ormtable.Iterator
}

func (i BatchSupplyIterator) Value() (*BatchSupply, error) {
	var batchSupply BatchSupply
	err := i.UnmarshalMessage(&batchSupply)
	return &batchSupply, err
}

type BatchSupplyIndexKey interface {
	id() uint32
	values() []interface{}
	batchSupplyIndexKey()
}

type BatchSupplyIdIndexKey struct {
	vs []interface{}
}

func (x BatchSupplyIdIndexKey) id() uint32            { return 10 /* primary key */ }
func (x BatchSupplyIdIndexKey) values() []interface{} { return x.vs }
func (x BatchSupplyIdIndexKey) batchSupplyIndexKey()  {}

var _ BatchSupplyIndexKey = BatchSupplyIdIndexKey{}

func (x BatchSupplyIdIndexKey) WithId(id uint64) BatchSupplyIdIndexKey {
	x.vs = []interface{}{id}
	return x
}

type batchSupplyStore struct {
	table ormtable.Table
}

func (x batchSupplyStore) Insert(ctx context.Context, batchSupply *BatchSupply) error {
	return x.table.Insert(ctx, batchSupply)
}
func (x batchSupplyStore) Update(ctx context.Context, batchSupply *BatchSupply) error {
	return x.table.Update(ctx, batchSupply)
}
func (x batchSupplyStore) Save(ctx context.Context, batchSupply *BatchSupply) error {
	return x.table.Save(ctx, batchSupply)
}
func (x batchSupplyStore) Delete(ctx context.Context, batchSupply *BatchSupply) error {
	return x.table.Delete(ctx, batchSupply)
}
func (x batchSupplyStore) Has(ctx context.Context, id uint64) (found bool, err error) {
	return x.table.PrimaryKey().Has(ctx, id)
}
func (x batchSupplyStore) Get(ctx context.Context, id uint64) (*BatchSupply, error) {
	var batchSupply BatchSupply
	found, err := x.table.PrimaryKey().Get(ctx, &batchSupply, id)
	if !found {
		return nil, err
	}
	return &batchSupply, err
}
func (x batchSupplyStore) List(ctx context.Context, prefixKey BatchSupplyIndexKey, opts ...ormlist.Option) (BatchSupplyIterator, error) {
	opts = append(opts, ormlist.Prefix(prefixKey.values()))
	it, err := x.table.GetIndexByID(prefixKey.id()).Iterator(ctx, opts...)
	return BatchSupplyIterator{it}, err
}
func (x batchSupplyStore) ListRange(ctx context.Context, from, to BatchSupplyIndexKey, opts ...ormlist.Option) (BatchSupplyIterator, error) {
	opts = append(opts, ormlist.Start(from.values()), ormlist.End(to))
	it, err := x.table.GetIndexByID(from.id()).Iterator(ctx, opts...)
	return BatchSupplyIterator{it}, err
}

var _ BatchSupplyStore = batchSupplyStore{}

type stateStore struct {
	classInfo        *classInfoStore
	classIssuer      *classIssuerStore
	projectInfo      *projectInfoStore
	batchInfo        *batchInfoStore
	creditType       *creditTypeStore
	projectSequence  *projectSequenceStore
	ecocreditBalance *ecocreditBalanceStore
	batchSequence    *batchSequenceStore
	batchSupply      *batchSupplyStore
}

func (x stateStore) ClassInfo() ClassInfoStore {
	return x.classInfo
}
func (x stateStore) ClassIssuer() ClassIssuerStore {
	return x.classIssuer
}
func (x stateStore) ProjectInfo() ProjectInfoStore {
	return x.projectInfo
}
func (x stateStore) BatchInfo() BatchInfoStore {
	return x.batchInfo
}
func (x stateStore) CreditType() CreditTypeStore {
	return x.creditType
}
func (x stateStore) ProjectSequence() ProjectSequenceStore {
	return x.projectSequence
}
func (x stateStore) EcocreditBalance() EcocreditBalanceStore {
	return x.ecocreditBalance
}
func (x stateStore) BatchSequence() BatchSequenceStore {
	return x.batchSequence
}
func (x stateStore) BatchSupply() BatchSupplyStore {
	return x.batchSupply
}

var _ StateStore = stateStore{}
