// Code generated by protoc-gen-go-cosmos-orm. DO NOT EDIT.

package ecocreditv1beta1

import (
	context "context"
	ormlist "github.com/cosmos/cosmos-sdk/orm/model/ormlist"
	ormtable "github.com/cosmos/cosmos-sdk/orm/model/ormtable"
	ormerrors "github.com/cosmos/cosmos-sdk/orm/types/ormerrors"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

type CreditTypeStore interface {
	Insert(ctx context.Context, creditType *CreditType) error
	Update(ctx context.Context, creditType *CreditType) error
	Save(ctx context.Context, creditType *CreditType) error
	Delete(ctx context.Context, creditType *CreditType) error
	Has(ctx context.Context, abbreviation string) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, abbreviation string) (*CreditType, error)
	HasByName(ctx context.Context, name string) (found bool, err error)
	// GetByName returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	GetByName(ctx context.Context, name string) (*CreditType, error)
	List(ctx context.Context, prefixKey CreditTypeIndexKey, opts ...ormlist.Option) (CreditTypeIterator, error)
	ListRange(ctx context.Context, from, to CreditTypeIndexKey, opts ...ormlist.Option) (CreditTypeIterator, error)
	DeleteBy(ctx context.Context, prefixKey CreditTypeIndexKey) error
	DeleteRange(ctx context.Context, from, to CreditTypeIndexKey) error

	doNotImplement()
}

type CreditTypeIterator struct {
	ormtable.Iterator
}

func (i CreditTypeIterator) Value() (*CreditType, error) {
	var creditType CreditType
	err := i.UnmarshalMessage(&creditType)
	return &creditType, err
}

type CreditTypeIndexKey interface {
	id() uint32
	values() []interface{}
	creditTypeIndexKey()
}

// primary key starting index..
type CreditTypePrimaryKey = CreditTypeAbbreviationIndexKey

type CreditTypeAbbreviationIndexKey struct {
	vs []interface{}
}

func (x CreditTypeAbbreviationIndexKey) id() uint32            { return 0 }
func (x CreditTypeAbbreviationIndexKey) values() []interface{} { return x.vs }
func (x CreditTypeAbbreviationIndexKey) creditTypeIndexKey()   {}

func (this CreditTypeAbbreviationIndexKey) WithAbbreviation(abbreviation string) CreditTypeAbbreviationIndexKey {
	this.vs = []interface{}{abbreviation}
	return this
}

type CreditTypeNameIndexKey struct {
	vs []interface{}
}

func (x CreditTypeNameIndexKey) id() uint32            { return 1 }
func (x CreditTypeNameIndexKey) values() []interface{} { return x.vs }
func (x CreditTypeNameIndexKey) creditTypeIndexKey()   {}

func (this CreditTypeNameIndexKey) WithName(name string) CreditTypeNameIndexKey {
	this.vs = []interface{}{name}
	return this
}

type creditTypeStore struct {
	table ormtable.Table
}

func (this creditTypeStore) Insert(ctx context.Context, creditType *CreditType) error {
	return this.table.Insert(ctx, creditType)
}

func (this creditTypeStore) Update(ctx context.Context, creditType *CreditType) error {
	return this.table.Update(ctx, creditType)
}

func (this creditTypeStore) Save(ctx context.Context, creditType *CreditType) error {
	return this.table.Save(ctx, creditType)
}

func (this creditTypeStore) Delete(ctx context.Context, creditType *CreditType) error {
	return this.table.Delete(ctx, creditType)
}

func (this creditTypeStore) Has(ctx context.Context, abbreviation string) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, abbreviation)
}

func (this creditTypeStore) Get(ctx context.Context, abbreviation string) (*CreditType, error) {
	var creditType CreditType
	found, err := this.table.PrimaryKey().Get(ctx, &creditType, abbreviation)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &creditType, nil
}

func (this creditTypeStore) HasByName(ctx context.Context, name string) (found bool, err error) {
	return this.table.GetIndexByID(1).(ormtable.UniqueIndex).Has(ctx,
		name,
	)
}

func (this creditTypeStore) GetByName(ctx context.Context, name string) (*CreditType, error) {
	var creditType CreditType
	found, err := this.table.GetIndexByID(1).(ormtable.UniqueIndex).Get(ctx, &creditType,
		name,
	)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &creditType, nil
}

func (this creditTypeStore) List(ctx context.Context, prefixKey CreditTypeIndexKey, opts ...ormlist.Option) (CreditTypeIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return CreditTypeIterator{it}, err
}

func (this creditTypeStore) ListRange(ctx context.Context, from, to CreditTypeIndexKey, opts ...ormlist.Option) (CreditTypeIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return CreditTypeIterator{it}, err
}

func (this creditTypeStore) DeleteBy(ctx context.Context, prefixKey CreditTypeIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this creditTypeStore) DeleteRange(ctx context.Context, from, to CreditTypeIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this creditTypeStore) doNotImplement() {}

var _ CreditTypeStore = creditTypeStore{}

func NewCreditTypeStore(db ormtable.Schema) (CreditTypeStore, error) {
	table := db.GetTable(&CreditType{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&CreditType{}).ProtoReflect().Descriptor().FullName()))
	}
	return creditTypeStore{table}, nil
}

type ClassInfoStore interface {
	Insert(ctx context.Context, classInfo *ClassInfo) error
	InsertReturningID(ctx context.Context, classInfo *ClassInfo) (uint64, error)
	Update(ctx context.Context, classInfo *ClassInfo) error
	Save(ctx context.Context, classInfo *ClassInfo) error
	Delete(ctx context.Context, classInfo *ClassInfo) error
	Has(ctx context.Context, id uint64) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, id uint64) (*ClassInfo, error)
	HasByName(ctx context.Context, name string) (found bool, err error)
	// GetByName returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	GetByName(ctx context.Context, name string) (*ClassInfo, error)
	List(ctx context.Context, prefixKey ClassInfoIndexKey, opts ...ormlist.Option) (ClassInfoIterator, error)
	ListRange(ctx context.Context, from, to ClassInfoIndexKey, opts ...ormlist.Option) (ClassInfoIterator, error)
	DeleteBy(ctx context.Context, prefixKey ClassInfoIndexKey) error
	DeleteRange(ctx context.Context, from, to ClassInfoIndexKey) error

	doNotImplement()
}

type ClassInfoIterator struct {
	ormtable.Iterator
}

func (i ClassInfoIterator) Value() (*ClassInfo, error) {
	var classInfo ClassInfo
	err := i.UnmarshalMessage(&classInfo)
	return &classInfo, err
}

type ClassInfoIndexKey interface {
	id() uint32
	values() []interface{}
	classInfoIndexKey()
}

// primary key starting index..
type ClassInfoPrimaryKey = ClassInfoIdIndexKey

type ClassInfoIdIndexKey struct {
	vs []interface{}
}

func (x ClassInfoIdIndexKey) id() uint32            { return 0 }
func (x ClassInfoIdIndexKey) values() []interface{} { return x.vs }
func (x ClassInfoIdIndexKey) classInfoIndexKey()    {}

func (this ClassInfoIdIndexKey) WithId(id uint64) ClassInfoIdIndexKey {
	this.vs = []interface{}{id}
	return this
}

type ClassInfoNameIndexKey struct {
	vs []interface{}
}

func (x ClassInfoNameIndexKey) id() uint32            { return 1 }
func (x ClassInfoNameIndexKey) values() []interface{} { return x.vs }
func (x ClassInfoNameIndexKey) classInfoIndexKey()    {}

func (this ClassInfoNameIndexKey) WithName(name string) ClassInfoNameIndexKey {
	this.vs = []interface{}{name}
	return this
}

type ClassInfoAdminIndexKey struct {
	vs []interface{}
}

func (x ClassInfoAdminIndexKey) id() uint32            { return 2 }
func (x ClassInfoAdminIndexKey) values() []interface{} { return x.vs }
func (x ClassInfoAdminIndexKey) classInfoIndexKey()    {}

func (this ClassInfoAdminIndexKey) WithAdmin(admin []byte) ClassInfoAdminIndexKey {
	this.vs = []interface{}{admin}
	return this
}

type ClassInfoCreditTypeIndexKey struct {
	vs []interface{}
}

func (x ClassInfoCreditTypeIndexKey) id() uint32            { return 3 }
func (x ClassInfoCreditTypeIndexKey) values() []interface{} { return x.vs }
func (x ClassInfoCreditTypeIndexKey) classInfoIndexKey()    {}

func (this ClassInfoCreditTypeIndexKey) WithCreditType(credit_type string) ClassInfoCreditTypeIndexKey {
	this.vs = []interface{}{credit_type}
	return this
}

type classInfoStore struct {
	table ormtable.AutoIncrementTable
}

func (this classInfoStore) Insert(ctx context.Context, classInfo *ClassInfo) error {
	return this.table.Insert(ctx, classInfo)
}

func (this classInfoStore) Update(ctx context.Context, classInfo *ClassInfo) error {
	return this.table.Update(ctx, classInfo)
}

func (this classInfoStore) Save(ctx context.Context, classInfo *ClassInfo) error {
	return this.table.Save(ctx, classInfo)
}

func (this classInfoStore) Delete(ctx context.Context, classInfo *ClassInfo) error {
	return this.table.Delete(ctx, classInfo)
}

func (this classInfoStore) InsertReturningID(ctx context.Context, classInfo *ClassInfo) (uint64, error) {
	return this.table.InsertReturningID(ctx, classInfo)
}

func (this classInfoStore) Has(ctx context.Context, id uint64) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, id)
}

func (this classInfoStore) Get(ctx context.Context, id uint64) (*ClassInfo, error) {
	var classInfo ClassInfo
	found, err := this.table.PrimaryKey().Get(ctx, &classInfo, id)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &classInfo, nil
}

func (this classInfoStore) HasByName(ctx context.Context, name string) (found bool, err error) {
	return this.table.GetIndexByID(1).(ormtable.UniqueIndex).Has(ctx,
		name,
	)
}

func (this classInfoStore) GetByName(ctx context.Context, name string) (*ClassInfo, error) {
	var classInfo ClassInfo
	found, err := this.table.GetIndexByID(1).(ormtable.UniqueIndex).Get(ctx, &classInfo,
		name,
	)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &classInfo, nil
}

func (this classInfoStore) List(ctx context.Context, prefixKey ClassInfoIndexKey, opts ...ormlist.Option) (ClassInfoIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return ClassInfoIterator{it}, err
}

func (this classInfoStore) ListRange(ctx context.Context, from, to ClassInfoIndexKey, opts ...ormlist.Option) (ClassInfoIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return ClassInfoIterator{it}, err
}

func (this classInfoStore) DeleteBy(ctx context.Context, prefixKey ClassInfoIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this classInfoStore) DeleteRange(ctx context.Context, from, to ClassInfoIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this classInfoStore) doNotImplement() {}

var _ ClassInfoStore = classInfoStore{}

func NewClassInfoStore(db ormtable.Schema) (ClassInfoStore, error) {
	table := db.GetTable(&ClassInfo{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&ClassInfo{}).ProtoReflect().Descriptor().FullName()))
	}
	return classInfoStore{table.(ormtable.AutoIncrementTable)}, nil
}

type ClassIssuerStore interface {
	Insert(ctx context.Context, classIssuer *ClassIssuer) error
	Update(ctx context.Context, classIssuer *ClassIssuer) error
	Save(ctx context.Context, classIssuer *ClassIssuer) error
	Delete(ctx context.Context, classIssuer *ClassIssuer) error
	Has(ctx context.Context, class_id uint64, issuer []byte) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, class_id uint64, issuer []byte) (*ClassIssuer, error)
	List(ctx context.Context, prefixKey ClassIssuerIndexKey, opts ...ormlist.Option) (ClassIssuerIterator, error)
	ListRange(ctx context.Context, from, to ClassIssuerIndexKey, opts ...ormlist.Option) (ClassIssuerIterator, error)
	DeleteBy(ctx context.Context, prefixKey ClassIssuerIndexKey) error
	DeleteRange(ctx context.Context, from, to ClassIssuerIndexKey) error

	doNotImplement()
}

type ClassIssuerIterator struct {
	ormtable.Iterator
}

func (i ClassIssuerIterator) Value() (*ClassIssuer, error) {
	var classIssuer ClassIssuer
	err := i.UnmarshalMessage(&classIssuer)
	return &classIssuer, err
}

type ClassIssuerIndexKey interface {
	id() uint32
	values() []interface{}
	classIssuerIndexKey()
}

// primary key starting index..
type ClassIssuerPrimaryKey = ClassIssuerClassIdIssuerIndexKey

type ClassIssuerClassIdIssuerIndexKey struct {
	vs []interface{}
}

func (x ClassIssuerClassIdIssuerIndexKey) id() uint32            { return 0 }
func (x ClassIssuerClassIdIssuerIndexKey) values() []interface{} { return x.vs }
func (x ClassIssuerClassIdIssuerIndexKey) classIssuerIndexKey()  {}

func (this ClassIssuerClassIdIssuerIndexKey) WithClassId(class_id uint64) ClassIssuerClassIdIssuerIndexKey {
	this.vs = []interface{}{class_id}
	return this
}

func (this ClassIssuerClassIdIssuerIndexKey) WithClassIdIssuer(class_id uint64, issuer []byte) ClassIssuerClassIdIssuerIndexKey {
	this.vs = []interface{}{class_id, issuer}
	return this
}

type classIssuerStore struct {
	table ormtable.Table
}

func (this classIssuerStore) Insert(ctx context.Context, classIssuer *ClassIssuer) error {
	return this.table.Insert(ctx, classIssuer)
}

func (this classIssuerStore) Update(ctx context.Context, classIssuer *ClassIssuer) error {
	return this.table.Update(ctx, classIssuer)
}

func (this classIssuerStore) Save(ctx context.Context, classIssuer *ClassIssuer) error {
	return this.table.Save(ctx, classIssuer)
}

func (this classIssuerStore) Delete(ctx context.Context, classIssuer *ClassIssuer) error {
	return this.table.Delete(ctx, classIssuer)
}

func (this classIssuerStore) Has(ctx context.Context, class_id uint64, issuer []byte) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, class_id, issuer)
}

func (this classIssuerStore) Get(ctx context.Context, class_id uint64, issuer []byte) (*ClassIssuer, error) {
	var classIssuer ClassIssuer
	found, err := this.table.PrimaryKey().Get(ctx, &classIssuer, class_id, issuer)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &classIssuer, nil
}

func (this classIssuerStore) List(ctx context.Context, prefixKey ClassIssuerIndexKey, opts ...ormlist.Option) (ClassIssuerIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return ClassIssuerIterator{it}, err
}

func (this classIssuerStore) ListRange(ctx context.Context, from, to ClassIssuerIndexKey, opts ...ormlist.Option) (ClassIssuerIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return ClassIssuerIterator{it}, err
}

func (this classIssuerStore) DeleteBy(ctx context.Context, prefixKey ClassIssuerIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this classIssuerStore) DeleteRange(ctx context.Context, from, to ClassIssuerIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this classIssuerStore) doNotImplement() {}

var _ ClassIssuerStore = classIssuerStore{}

func NewClassIssuerStore(db ormtable.Schema) (ClassIssuerStore, error) {
	table := db.GetTable(&ClassIssuer{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&ClassIssuer{}).ProtoReflect().Descriptor().FullName()))
	}
	return classIssuerStore{table}, nil
}

type ProjectInfoStore interface {
	Insert(ctx context.Context, projectInfo *ProjectInfo) error
	InsertReturningID(ctx context.Context, projectInfo *ProjectInfo) (uint64, error)
	Update(ctx context.Context, projectInfo *ProjectInfo) error
	Save(ctx context.Context, projectInfo *ProjectInfo) error
	Delete(ctx context.Context, projectInfo *ProjectInfo) error
	Has(ctx context.Context, id uint64) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, id uint64) (*ProjectInfo, error)
	HasByName(ctx context.Context, name string) (found bool, err error)
	// GetByName returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	GetByName(ctx context.Context, name string) (*ProjectInfo, error)
	HasByClassIdName(ctx context.Context, class_id uint64, name string) (found bool, err error)
	// GetByClassIdName returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	GetByClassIdName(ctx context.Context, class_id uint64, name string) (*ProjectInfo, error)
	List(ctx context.Context, prefixKey ProjectInfoIndexKey, opts ...ormlist.Option) (ProjectInfoIterator, error)
	ListRange(ctx context.Context, from, to ProjectInfoIndexKey, opts ...ormlist.Option) (ProjectInfoIterator, error)
	DeleteBy(ctx context.Context, prefixKey ProjectInfoIndexKey) error
	DeleteRange(ctx context.Context, from, to ProjectInfoIndexKey) error

	doNotImplement()
}

type ProjectInfoIterator struct {
	ormtable.Iterator
}

func (i ProjectInfoIterator) Value() (*ProjectInfo, error) {
	var projectInfo ProjectInfo
	err := i.UnmarshalMessage(&projectInfo)
	return &projectInfo, err
}

type ProjectInfoIndexKey interface {
	id() uint32
	values() []interface{}
	projectInfoIndexKey()
}

// primary key starting index..
type ProjectInfoPrimaryKey = ProjectInfoIdIndexKey

type ProjectInfoIdIndexKey struct {
	vs []interface{}
}

func (x ProjectInfoIdIndexKey) id() uint32            { return 0 }
func (x ProjectInfoIdIndexKey) values() []interface{} { return x.vs }
func (x ProjectInfoIdIndexKey) projectInfoIndexKey()  {}

func (this ProjectInfoIdIndexKey) WithId(id uint64) ProjectInfoIdIndexKey {
	this.vs = []interface{}{id}
	return this
}

type ProjectInfoNameIndexKey struct {
	vs []interface{}
}

func (x ProjectInfoNameIndexKey) id() uint32            { return 1 }
func (x ProjectInfoNameIndexKey) values() []interface{} { return x.vs }
func (x ProjectInfoNameIndexKey) projectInfoIndexKey()  {}

func (this ProjectInfoNameIndexKey) WithName(name string) ProjectInfoNameIndexKey {
	this.vs = []interface{}{name}
	return this
}

type ProjectInfoClassIdNameIndexKey struct {
	vs []interface{}
}

func (x ProjectInfoClassIdNameIndexKey) id() uint32            { return 2 }
func (x ProjectInfoClassIdNameIndexKey) values() []interface{} { return x.vs }
func (x ProjectInfoClassIdNameIndexKey) projectInfoIndexKey()  {}

func (this ProjectInfoClassIdNameIndexKey) WithClassId(class_id uint64) ProjectInfoClassIdNameIndexKey {
	this.vs = []interface{}{class_id}
	return this
}

func (this ProjectInfoClassIdNameIndexKey) WithClassIdName(class_id uint64, name string) ProjectInfoClassIdNameIndexKey {
	this.vs = []interface{}{class_id, name}
	return this
}

type projectInfoStore struct {
	table ormtable.AutoIncrementTable
}

func (this projectInfoStore) Insert(ctx context.Context, projectInfo *ProjectInfo) error {
	return this.table.Insert(ctx, projectInfo)
}

func (this projectInfoStore) Update(ctx context.Context, projectInfo *ProjectInfo) error {
	return this.table.Update(ctx, projectInfo)
}

func (this projectInfoStore) Save(ctx context.Context, projectInfo *ProjectInfo) error {
	return this.table.Save(ctx, projectInfo)
}

func (this projectInfoStore) Delete(ctx context.Context, projectInfo *ProjectInfo) error {
	return this.table.Delete(ctx, projectInfo)
}

func (this projectInfoStore) InsertReturningID(ctx context.Context, projectInfo *ProjectInfo) (uint64, error) {
	return this.table.InsertReturningID(ctx, projectInfo)
}

func (this projectInfoStore) Has(ctx context.Context, id uint64) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, id)
}

func (this projectInfoStore) Get(ctx context.Context, id uint64) (*ProjectInfo, error) {
	var projectInfo ProjectInfo
	found, err := this.table.PrimaryKey().Get(ctx, &projectInfo, id)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &projectInfo, nil
}

func (this projectInfoStore) HasByName(ctx context.Context, name string) (found bool, err error) {
	return this.table.GetIndexByID(1).(ormtable.UniqueIndex).Has(ctx,
		name,
	)
}

func (this projectInfoStore) GetByName(ctx context.Context, name string) (*ProjectInfo, error) {
	var projectInfo ProjectInfo
	found, err := this.table.GetIndexByID(1).(ormtable.UniqueIndex).Get(ctx, &projectInfo,
		name,
	)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &projectInfo, nil
}

func (this projectInfoStore) HasByClassIdName(ctx context.Context, class_id uint64, name string) (found bool, err error) {
	return this.table.GetIndexByID(2).(ormtable.UniqueIndex).Has(ctx,
		class_id,
		name,
	)
}

func (this projectInfoStore) GetByClassIdName(ctx context.Context, class_id uint64, name string) (*ProjectInfo, error) {
	var projectInfo ProjectInfo
	found, err := this.table.GetIndexByID(2).(ormtable.UniqueIndex).Get(ctx, &projectInfo,
		class_id,
		name,
	)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &projectInfo, nil
}

func (this projectInfoStore) List(ctx context.Context, prefixKey ProjectInfoIndexKey, opts ...ormlist.Option) (ProjectInfoIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return ProjectInfoIterator{it}, err
}

func (this projectInfoStore) ListRange(ctx context.Context, from, to ProjectInfoIndexKey, opts ...ormlist.Option) (ProjectInfoIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return ProjectInfoIterator{it}, err
}

func (this projectInfoStore) DeleteBy(ctx context.Context, prefixKey ProjectInfoIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this projectInfoStore) DeleteRange(ctx context.Context, from, to ProjectInfoIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this projectInfoStore) doNotImplement() {}

var _ ProjectInfoStore = projectInfoStore{}

func NewProjectInfoStore(db ormtable.Schema) (ProjectInfoStore, error) {
	table := db.GetTable(&ProjectInfo{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&ProjectInfo{}).ProtoReflect().Descriptor().FullName()))
	}
	return projectInfoStore{table.(ormtable.AutoIncrementTable)}, nil
}

type BatchInfoStore interface {
	Insert(ctx context.Context, batchInfo *BatchInfo) error
	InsertReturningID(ctx context.Context, batchInfo *BatchInfo) (uint64, error)
	Update(ctx context.Context, batchInfo *BatchInfo) error
	Save(ctx context.Context, batchInfo *BatchInfo) error
	Delete(ctx context.Context, batchInfo *BatchInfo) error
	Has(ctx context.Context, id uint64) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, id uint64) (*BatchInfo, error)
	HasByBatchDenom(ctx context.Context, batch_denom string) (found bool, err error)
	// GetByBatchDenom returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	GetByBatchDenom(ctx context.Context, batch_denom string) (*BatchInfo, error)
	List(ctx context.Context, prefixKey BatchInfoIndexKey, opts ...ormlist.Option) (BatchInfoIterator, error)
	ListRange(ctx context.Context, from, to BatchInfoIndexKey, opts ...ormlist.Option) (BatchInfoIterator, error)
	DeleteBy(ctx context.Context, prefixKey BatchInfoIndexKey) error
	DeleteRange(ctx context.Context, from, to BatchInfoIndexKey) error

	doNotImplement()
}

type BatchInfoIterator struct {
	ormtable.Iterator
}

func (i BatchInfoIterator) Value() (*BatchInfo, error) {
	var batchInfo BatchInfo
	err := i.UnmarshalMessage(&batchInfo)
	return &batchInfo, err
}

type BatchInfoIndexKey interface {
	id() uint32
	values() []interface{}
	batchInfoIndexKey()
}

// primary key starting index..
type BatchInfoPrimaryKey = BatchInfoIdIndexKey

type BatchInfoIdIndexKey struct {
	vs []interface{}
}

func (x BatchInfoIdIndexKey) id() uint32            { return 0 }
func (x BatchInfoIdIndexKey) values() []interface{} { return x.vs }
func (x BatchInfoIdIndexKey) batchInfoIndexKey()    {}

func (this BatchInfoIdIndexKey) WithId(id uint64) BatchInfoIdIndexKey {
	this.vs = []interface{}{id}
	return this
}

type BatchInfoBatchDenomIndexKey struct {
	vs []interface{}
}

func (x BatchInfoBatchDenomIndexKey) id() uint32            { return 1 }
func (x BatchInfoBatchDenomIndexKey) values() []interface{} { return x.vs }
func (x BatchInfoBatchDenomIndexKey) batchInfoIndexKey()    {}

func (this BatchInfoBatchDenomIndexKey) WithBatchDenom(batch_denom string) BatchInfoBatchDenomIndexKey {
	this.vs = []interface{}{batch_denom}
	return this
}

type BatchInfoProjectIdIndexKey struct {
	vs []interface{}
}

func (x BatchInfoProjectIdIndexKey) id() uint32            { return 2 }
func (x BatchInfoProjectIdIndexKey) values() []interface{} { return x.vs }
func (x BatchInfoProjectIdIndexKey) batchInfoIndexKey()    {}

func (this BatchInfoProjectIdIndexKey) WithProjectId(project_id uint64) BatchInfoProjectIdIndexKey {
	this.vs = []interface{}{project_id}
	return this
}

type BatchInfoStartDateIndexKey struct {
	vs []interface{}
}

func (x BatchInfoStartDateIndexKey) id() uint32            { return 3 }
func (x BatchInfoStartDateIndexKey) values() []interface{} { return x.vs }
func (x BatchInfoStartDateIndexKey) batchInfoIndexKey()    {}

func (this BatchInfoStartDateIndexKey) WithStartDate(start_date *timestamppb.Timestamp) BatchInfoStartDateIndexKey {
	this.vs = []interface{}{start_date}
	return this
}

type batchInfoStore struct {
	table ormtable.AutoIncrementTable
}

func (this batchInfoStore) Insert(ctx context.Context, batchInfo *BatchInfo) error {
	return this.table.Insert(ctx, batchInfo)
}

func (this batchInfoStore) Update(ctx context.Context, batchInfo *BatchInfo) error {
	return this.table.Update(ctx, batchInfo)
}

func (this batchInfoStore) Save(ctx context.Context, batchInfo *BatchInfo) error {
	return this.table.Save(ctx, batchInfo)
}

func (this batchInfoStore) Delete(ctx context.Context, batchInfo *BatchInfo) error {
	return this.table.Delete(ctx, batchInfo)
}

func (this batchInfoStore) InsertReturningID(ctx context.Context, batchInfo *BatchInfo) (uint64, error) {
	return this.table.InsertReturningID(ctx, batchInfo)
}

func (this batchInfoStore) Has(ctx context.Context, id uint64) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, id)
}

func (this batchInfoStore) Get(ctx context.Context, id uint64) (*BatchInfo, error) {
	var batchInfo BatchInfo
	found, err := this.table.PrimaryKey().Get(ctx, &batchInfo, id)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &batchInfo, nil
}

func (this batchInfoStore) HasByBatchDenom(ctx context.Context, batch_denom string) (found bool, err error) {
	return this.table.GetIndexByID(1).(ormtable.UniqueIndex).Has(ctx,
		batch_denom,
	)
}

func (this batchInfoStore) GetByBatchDenom(ctx context.Context, batch_denom string) (*BatchInfo, error) {
	var batchInfo BatchInfo
	found, err := this.table.GetIndexByID(1).(ormtable.UniqueIndex).Get(ctx, &batchInfo,
		batch_denom,
	)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &batchInfo, nil
}

func (this batchInfoStore) List(ctx context.Context, prefixKey BatchInfoIndexKey, opts ...ormlist.Option) (BatchInfoIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return BatchInfoIterator{it}, err
}

func (this batchInfoStore) ListRange(ctx context.Context, from, to BatchInfoIndexKey, opts ...ormlist.Option) (BatchInfoIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return BatchInfoIterator{it}, err
}

func (this batchInfoStore) DeleteBy(ctx context.Context, prefixKey BatchInfoIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this batchInfoStore) DeleteRange(ctx context.Context, from, to BatchInfoIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this batchInfoStore) doNotImplement() {}

var _ BatchInfoStore = batchInfoStore{}

func NewBatchInfoStore(db ormtable.Schema) (BatchInfoStore, error) {
	table := db.GetTable(&BatchInfo{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&BatchInfo{}).ProtoReflect().Descriptor().FullName()))
	}
	return batchInfoStore{table.(ormtable.AutoIncrementTable)}, nil
}

type ClassSequenceStore interface {
	Insert(ctx context.Context, classSequence *ClassSequence) error
	Update(ctx context.Context, classSequence *ClassSequence) error
	Save(ctx context.Context, classSequence *ClassSequence) error
	Delete(ctx context.Context, classSequence *ClassSequence) error
	Has(ctx context.Context, credit_type string) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, credit_type string) (*ClassSequence, error)
	List(ctx context.Context, prefixKey ClassSequenceIndexKey, opts ...ormlist.Option) (ClassSequenceIterator, error)
	ListRange(ctx context.Context, from, to ClassSequenceIndexKey, opts ...ormlist.Option) (ClassSequenceIterator, error)
	DeleteBy(ctx context.Context, prefixKey ClassSequenceIndexKey) error
	DeleteRange(ctx context.Context, from, to ClassSequenceIndexKey) error

	doNotImplement()
}

type ClassSequenceIterator struct {
	ormtable.Iterator
}

func (i ClassSequenceIterator) Value() (*ClassSequence, error) {
	var classSequence ClassSequence
	err := i.UnmarshalMessage(&classSequence)
	return &classSequence, err
}

type ClassSequenceIndexKey interface {
	id() uint32
	values() []interface{}
	classSequenceIndexKey()
}

// primary key starting index..
type ClassSequencePrimaryKey = ClassSequenceCreditTypeIndexKey

type ClassSequenceCreditTypeIndexKey struct {
	vs []interface{}
}

func (x ClassSequenceCreditTypeIndexKey) id() uint32             { return 0 }
func (x ClassSequenceCreditTypeIndexKey) values() []interface{}  { return x.vs }
func (x ClassSequenceCreditTypeIndexKey) classSequenceIndexKey() {}

func (this ClassSequenceCreditTypeIndexKey) WithCreditType(credit_type string) ClassSequenceCreditTypeIndexKey {
	this.vs = []interface{}{credit_type}
	return this
}

type classSequenceStore struct {
	table ormtable.Table
}

func (this classSequenceStore) Insert(ctx context.Context, classSequence *ClassSequence) error {
	return this.table.Insert(ctx, classSequence)
}

func (this classSequenceStore) Update(ctx context.Context, classSequence *ClassSequence) error {
	return this.table.Update(ctx, classSequence)
}

func (this classSequenceStore) Save(ctx context.Context, classSequence *ClassSequence) error {
	return this.table.Save(ctx, classSequence)
}

func (this classSequenceStore) Delete(ctx context.Context, classSequence *ClassSequence) error {
	return this.table.Delete(ctx, classSequence)
}

func (this classSequenceStore) Has(ctx context.Context, credit_type string) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, credit_type)
}

func (this classSequenceStore) Get(ctx context.Context, credit_type string) (*ClassSequence, error) {
	var classSequence ClassSequence
	found, err := this.table.PrimaryKey().Get(ctx, &classSequence, credit_type)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &classSequence, nil
}

func (this classSequenceStore) List(ctx context.Context, prefixKey ClassSequenceIndexKey, opts ...ormlist.Option) (ClassSequenceIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return ClassSequenceIterator{it}, err
}

func (this classSequenceStore) ListRange(ctx context.Context, from, to ClassSequenceIndexKey, opts ...ormlist.Option) (ClassSequenceIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return ClassSequenceIterator{it}, err
}

func (this classSequenceStore) DeleteBy(ctx context.Context, prefixKey ClassSequenceIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this classSequenceStore) DeleteRange(ctx context.Context, from, to ClassSequenceIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this classSequenceStore) doNotImplement() {}

var _ ClassSequenceStore = classSequenceStore{}

func NewClassSequenceStore(db ormtable.Schema) (ClassSequenceStore, error) {
	table := db.GetTable(&ClassSequence{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&ClassSequence{}).ProtoReflect().Descriptor().FullName()))
	}
	return classSequenceStore{table}, nil
}

type ProjectSequenceStore interface {
	Insert(ctx context.Context, projectSequence *ProjectSequence) error
	Update(ctx context.Context, projectSequence *ProjectSequence) error
	Save(ctx context.Context, projectSequence *ProjectSequence) error
	Delete(ctx context.Context, projectSequence *ProjectSequence) error
	Has(ctx context.Context, class_id uint64) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, class_id uint64) (*ProjectSequence, error)
	List(ctx context.Context, prefixKey ProjectSequenceIndexKey, opts ...ormlist.Option) (ProjectSequenceIterator, error)
	ListRange(ctx context.Context, from, to ProjectSequenceIndexKey, opts ...ormlist.Option) (ProjectSequenceIterator, error)
	DeleteBy(ctx context.Context, prefixKey ProjectSequenceIndexKey) error
	DeleteRange(ctx context.Context, from, to ProjectSequenceIndexKey) error

	doNotImplement()
}

type ProjectSequenceIterator struct {
	ormtable.Iterator
}

func (i ProjectSequenceIterator) Value() (*ProjectSequence, error) {
	var projectSequence ProjectSequence
	err := i.UnmarshalMessage(&projectSequence)
	return &projectSequence, err
}

type ProjectSequenceIndexKey interface {
	id() uint32
	values() []interface{}
	projectSequenceIndexKey()
}

// primary key starting index..
type ProjectSequencePrimaryKey = ProjectSequenceClassIdIndexKey

type ProjectSequenceClassIdIndexKey struct {
	vs []interface{}
}

func (x ProjectSequenceClassIdIndexKey) id() uint32               { return 0 }
func (x ProjectSequenceClassIdIndexKey) values() []interface{}    { return x.vs }
func (x ProjectSequenceClassIdIndexKey) projectSequenceIndexKey() {}

func (this ProjectSequenceClassIdIndexKey) WithClassId(class_id uint64) ProjectSequenceClassIdIndexKey {
	this.vs = []interface{}{class_id}
	return this
}

type projectSequenceStore struct {
	table ormtable.Table
}

func (this projectSequenceStore) Insert(ctx context.Context, projectSequence *ProjectSequence) error {
	return this.table.Insert(ctx, projectSequence)
}

func (this projectSequenceStore) Update(ctx context.Context, projectSequence *ProjectSequence) error {
	return this.table.Update(ctx, projectSequence)
}

func (this projectSequenceStore) Save(ctx context.Context, projectSequence *ProjectSequence) error {
	return this.table.Save(ctx, projectSequence)
}

func (this projectSequenceStore) Delete(ctx context.Context, projectSequence *ProjectSequence) error {
	return this.table.Delete(ctx, projectSequence)
}

func (this projectSequenceStore) Has(ctx context.Context, class_id uint64) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, class_id)
}

func (this projectSequenceStore) Get(ctx context.Context, class_id uint64) (*ProjectSequence, error) {
	var projectSequence ProjectSequence
	found, err := this.table.PrimaryKey().Get(ctx, &projectSequence, class_id)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &projectSequence, nil
}

func (this projectSequenceStore) List(ctx context.Context, prefixKey ProjectSequenceIndexKey, opts ...ormlist.Option) (ProjectSequenceIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return ProjectSequenceIterator{it}, err
}

func (this projectSequenceStore) ListRange(ctx context.Context, from, to ProjectSequenceIndexKey, opts ...ormlist.Option) (ProjectSequenceIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return ProjectSequenceIterator{it}, err
}

func (this projectSequenceStore) DeleteBy(ctx context.Context, prefixKey ProjectSequenceIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this projectSequenceStore) DeleteRange(ctx context.Context, from, to ProjectSequenceIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this projectSequenceStore) doNotImplement() {}

var _ ProjectSequenceStore = projectSequenceStore{}

func NewProjectSequenceStore(db ormtable.Schema) (ProjectSequenceStore, error) {
	table := db.GetTable(&ProjectSequence{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&ProjectSequence{}).ProtoReflect().Descriptor().FullName()))
	}
	return projectSequenceStore{table}, nil
}

type BatchSequenceStore interface {
	Insert(ctx context.Context, batchSequence *BatchSequence) error
	Update(ctx context.Context, batchSequence *BatchSequence) error
	Save(ctx context.Context, batchSequence *BatchSequence) error
	Delete(ctx context.Context, batchSequence *BatchSequence) error
	Has(ctx context.Context, project_id string) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, project_id string) (*BatchSequence, error)
	List(ctx context.Context, prefixKey BatchSequenceIndexKey, opts ...ormlist.Option) (BatchSequenceIterator, error)
	ListRange(ctx context.Context, from, to BatchSequenceIndexKey, opts ...ormlist.Option) (BatchSequenceIterator, error)
	DeleteBy(ctx context.Context, prefixKey BatchSequenceIndexKey) error
	DeleteRange(ctx context.Context, from, to BatchSequenceIndexKey) error

	doNotImplement()
}

type BatchSequenceIterator struct {
	ormtable.Iterator
}

func (i BatchSequenceIterator) Value() (*BatchSequence, error) {
	var batchSequence BatchSequence
	err := i.UnmarshalMessage(&batchSequence)
	return &batchSequence, err
}

type BatchSequenceIndexKey interface {
	id() uint32
	values() []interface{}
	batchSequenceIndexKey()
}

// primary key starting index..
type BatchSequencePrimaryKey = BatchSequenceProjectIdIndexKey

type BatchSequenceProjectIdIndexKey struct {
	vs []interface{}
}

func (x BatchSequenceProjectIdIndexKey) id() uint32             { return 0 }
func (x BatchSequenceProjectIdIndexKey) values() []interface{}  { return x.vs }
func (x BatchSequenceProjectIdIndexKey) batchSequenceIndexKey() {}

func (this BatchSequenceProjectIdIndexKey) WithProjectId(project_id string) BatchSequenceProjectIdIndexKey {
	this.vs = []interface{}{project_id}
	return this
}

type batchSequenceStore struct {
	table ormtable.Table
}

func (this batchSequenceStore) Insert(ctx context.Context, batchSequence *BatchSequence) error {
	return this.table.Insert(ctx, batchSequence)
}

func (this batchSequenceStore) Update(ctx context.Context, batchSequence *BatchSequence) error {
	return this.table.Update(ctx, batchSequence)
}

func (this batchSequenceStore) Save(ctx context.Context, batchSequence *BatchSequence) error {
	return this.table.Save(ctx, batchSequence)
}

func (this batchSequenceStore) Delete(ctx context.Context, batchSequence *BatchSequence) error {
	return this.table.Delete(ctx, batchSequence)
}

func (this batchSequenceStore) Has(ctx context.Context, project_id string) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, project_id)
}

func (this batchSequenceStore) Get(ctx context.Context, project_id string) (*BatchSequence, error) {
	var batchSequence BatchSequence
	found, err := this.table.PrimaryKey().Get(ctx, &batchSequence, project_id)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &batchSequence, nil
}

func (this batchSequenceStore) List(ctx context.Context, prefixKey BatchSequenceIndexKey, opts ...ormlist.Option) (BatchSequenceIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return BatchSequenceIterator{it}, err
}

func (this batchSequenceStore) ListRange(ctx context.Context, from, to BatchSequenceIndexKey, opts ...ormlist.Option) (BatchSequenceIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return BatchSequenceIterator{it}, err
}

func (this batchSequenceStore) DeleteBy(ctx context.Context, prefixKey BatchSequenceIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this batchSequenceStore) DeleteRange(ctx context.Context, from, to BatchSequenceIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this batchSequenceStore) doNotImplement() {}

var _ BatchSequenceStore = batchSequenceStore{}

func NewBatchSequenceStore(db ormtable.Schema) (BatchSequenceStore, error) {
	table := db.GetTable(&BatchSequence{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&BatchSequence{}).ProtoReflect().Descriptor().FullName()))
	}
	return batchSequenceStore{table}, nil
}

type BatchBalanceStore interface {
	Insert(ctx context.Context, batchBalance *BatchBalance) error
	Update(ctx context.Context, batchBalance *BatchBalance) error
	Save(ctx context.Context, batchBalance *BatchBalance) error
	Delete(ctx context.Context, batchBalance *BatchBalance) error
	Has(ctx context.Context, address []byte, batch_id uint64) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, address []byte, batch_id uint64) (*BatchBalance, error)
	List(ctx context.Context, prefixKey BatchBalanceIndexKey, opts ...ormlist.Option) (BatchBalanceIterator, error)
	ListRange(ctx context.Context, from, to BatchBalanceIndexKey, opts ...ormlist.Option) (BatchBalanceIterator, error)
	DeleteBy(ctx context.Context, prefixKey BatchBalanceIndexKey) error
	DeleteRange(ctx context.Context, from, to BatchBalanceIndexKey) error

	doNotImplement()
}

type BatchBalanceIterator struct {
	ormtable.Iterator
}

func (i BatchBalanceIterator) Value() (*BatchBalance, error) {
	var batchBalance BatchBalance
	err := i.UnmarshalMessage(&batchBalance)
	return &batchBalance, err
}

type BatchBalanceIndexKey interface {
	id() uint32
	values() []interface{}
	batchBalanceIndexKey()
}

// primary key starting index..
type BatchBalancePrimaryKey = BatchBalanceAddressBatchIdIndexKey

type BatchBalanceAddressBatchIdIndexKey struct {
	vs []interface{}
}

func (x BatchBalanceAddressBatchIdIndexKey) id() uint32            { return 0 }
func (x BatchBalanceAddressBatchIdIndexKey) values() []interface{} { return x.vs }
func (x BatchBalanceAddressBatchIdIndexKey) batchBalanceIndexKey() {}

func (this BatchBalanceAddressBatchIdIndexKey) WithAddress(address []byte) BatchBalanceAddressBatchIdIndexKey {
	this.vs = []interface{}{address}
	return this
}

func (this BatchBalanceAddressBatchIdIndexKey) WithAddressBatchId(address []byte, batch_id uint64) BatchBalanceAddressBatchIdIndexKey {
	this.vs = []interface{}{address, batch_id}
	return this
}

type BatchBalanceBatchIdAddressIndexKey struct {
	vs []interface{}
}

func (x BatchBalanceBatchIdAddressIndexKey) id() uint32            { return 1 }
func (x BatchBalanceBatchIdAddressIndexKey) values() []interface{} { return x.vs }
func (x BatchBalanceBatchIdAddressIndexKey) batchBalanceIndexKey() {}

func (this BatchBalanceBatchIdAddressIndexKey) WithBatchId(batch_id uint64) BatchBalanceBatchIdAddressIndexKey {
	this.vs = []interface{}{batch_id}
	return this
}

func (this BatchBalanceBatchIdAddressIndexKey) WithBatchIdAddress(batch_id uint64, address []byte) BatchBalanceBatchIdAddressIndexKey {
	this.vs = []interface{}{batch_id, address}
	return this
}

type batchBalanceStore struct {
	table ormtable.Table
}

func (this batchBalanceStore) Insert(ctx context.Context, batchBalance *BatchBalance) error {
	return this.table.Insert(ctx, batchBalance)
}

func (this batchBalanceStore) Update(ctx context.Context, batchBalance *BatchBalance) error {
	return this.table.Update(ctx, batchBalance)
}

func (this batchBalanceStore) Save(ctx context.Context, batchBalance *BatchBalance) error {
	return this.table.Save(ctx, batchBalance)
}

func (this batchBalanceStore) Delete(ctx context.Context, batchBalance *BatchBalance) error {
	return this.table.Delete(ctx, batchBalance)
}

func (this batchBalanceStore) Has(ctx context.Context, address []byte, batch_id uint64) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, address, batch_id)
}

func (this batchBalanceStore) Get(ctx context.Context, address []byte, batch_id uint64) (*BatchBalance, error) {
	var batchBalance BatchBalance
	found, err := this.table.PrimaryKey().Get(ctx, &batchBalance, address, batch_id)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &batchBalance, nil
}

func (this batchBalanceStore) List(ctx context.Context, prefixKey BatchBalanceIndexKey, opts ...ormlist.Option) (BatchBalanceIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return BatchBalanceIterator{it}, err
}

func (this batchBalanceStore) ListRange(ctx context.Context, from, to BatchBalanceIndexKey, opts ...ormlist.Option) (BatchBalanceIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return BatchBalanceIterator{it}, err
}

func (this batchBalanceStore) DeleteBy(ctx context.Context, prefixKey BatchBalanceIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this batchBalanceStore) DeleteRange(ctx context.Context, from, to BatchBalanceIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this batchBalanceStore) doNotImplement() {}

var _ BatchBalanceStore = batchBalanceStore{}

func NewBatchBalanceStore(db ormtable.Schema) (BatchBalanceStore, error) {
	table := db.GetTable(&BatchBalance{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&BatchBalance{}).ProtoReflect().Descriptor().FullName()))
	}
	return batchBalanceStore{table}, nil
}

type BatchSupplyStore interface {
	Insert(ctx context.Context, batchSupply *BatchSupply) error
	Update(ctx context.Context, batchSupply *BatchSupply) error
	Save(ctx context.Context, batchSupply *BatchSupply) error
	Delete(ctx context.Context, batchSupply *BatchSupply) error
	Has(ctx context.Context, batch_id uint64) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, batch_id uint64) (*BatchSupply, error)
	List(ctx context.Context, prefixKey BatchSupplyIndexKey, opts ...ormlist.Option) (BatchSupplyIterator, error)
	ListRange(ctx context.Context, from, to BatchSupplyIndexKey, opts ...ormlist.Option) (BatchSupplyIterator, error)
	DeleteBy(ctx context.Context, prefixKey BatchSupplyIndexKey) error
	DeleteRange(ctx context.Context, from, to BatchSupplyIndexKey) error

	doNotImplement()
}

type BatchSupplyIterator struct {
	ormtable.Iterator
}

func (i BatchSupplyIterator) Value() (*BatchSupply, error) {
	var batchSupply BatchSupply
	err := i.UnmarshalMessage(&batchSupply)
	return &batchSupply, err
}

type BatchSupplyIndexKey interface {
	id() uint32
	values() []interface{}
	batchSupplyIndexKey()
}

// primary key starting index..
type BatchSupplyPrimaryKey = BatchSupplyBatchIdIndexKey

type BatchSupplyBatchIdIndexKey struct {
	vs []interface{}
}

func (x BatchSupplyBatchIdIndexKey) id() uint32            { return 0 }
func (x BatchSupplyBatchIdIndexKey) values() []interface{} { return x.vs }
func (x BatchSupplyBatchIdIndexKey) batchSupplyIndexKey()  {}

func (this BatchSupplyBatchIdIndexKey) WithBatchId(batch_id uint64) BatchSupplyBatchIdIndexKey {
	this.vs = []interface{}{batch_id}
	return this
}

type batchSupplyStore struct {
	table ormtable.Table
}

func (this batchSupplyStore) Insert(ctx context.Context, batchSupply *BatchSupply) error {
	return this.table.Insert(ctx, batchSupply)
}

func (this batchSupplyStore) Update(ctx context.Context, batchSupply *BatchSupply) error {
	return this.table.Update(ctx, batchSupply)
}

func (this batchSupplyStore) Save(ctx context.Context, batchSupply *BatchSupply) error {
	return this.table.Save(ctx, batchSupply)
}

func (this batchSupplyStore) Delete(ctx context.Context, batchSupply *BatchSupply) error {
	return this.table.Delete(ctx, batchSupply)
}

func (this batchSupplyStore) Has(ctx context.Context, batch_id uint64) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, batch_id)
}

func (this batchSupplyStore) Get(ctx context.Context, batch_id uint64) (*BatchSupply, error) {
	var batchSupply BatchSupply
	found, err := this.table.PrimaryKey().Get(ctx, &batchSupply, batch_id)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &batchSupply, nil
}

func (this batchSupplyStore) List(ctx context.Context, prefixKey BatchSupplyIndexKey, opts ...ormlist.Option) (BatchSupplyIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return BatchSupplyIterator{it}, err
}

func (this batchSupplyStore) ListRange(ctx context.Context, from, to BatchSupplyIndexKey, opts ...ormlist.Option) (BatchSupplyIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return BatchSupplyIterator{it}, err
}

func (this batchSupplyStore) DeleteBy(ctx context.Context, prefixKey BatchSupplyIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this batchSupplyStore) DeleteRange(ctx context.Context, from, to BatchSupplyIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this batchSupplyStore) doNotImplement() {}

var _ BatchSupplyStore = batchSupplyStore{}

func NewBatchSupplyStore(db ormtable.Schema) (BatchSupplyStore, error) {
	table := db.GetTable(&BatchSupply{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&BatchSupply{}).ProtoReflect().Descriptor().FullName()))
	}
	return batchSupplyStore{table}, nil
}

type StateStore interface {
	CreditTypeStore() CreditTypeStore
	ClassInfoStore() ClassInfoStore
	ClassIssuerStore() ClassIssuerStore
	ProjectInfoStore() ProjectInfoStore
	BatchInfoStore() BatchInfoStore
	ClassSequenceStore() ClassSequenceStore
	ProjectSequenceStore() ProjectSequenceStore
	BatchSequenceStore() BatchSequenceStore
	BatchBalanceStore() BatchBalanceStore
	BatchSupplyStore() BatchSupplyStore

	doNotImplement()
}

type stateStore struct {
	creditType      CreditTypeStore
	classInfo       ClassInfoStore
	classIssuer     ClassIssuerStore
	projectInfo     ProjectInfoStore
	batchInfo       BatchInfoStore
	classSequence   ClassSequenceStore
	projectSequence ProjectSequenceStore
	batchSequence   BatchSequenceStore
	batchBalance    BatchBalanceStore
	batchSupply     BatchSupplyStore
}

func (x stateStore) CreditTypeStore() CreditTypeStore {
	return x.creditType
}

func (x stateStore) ClassInfoStore() ClassInfoStore {
	return x.classInfo
}

func (x stateStore) ClassIssuerStore() ClassIssuerStore {
	return x.classIssuer
}

func (x stateStore) ProjectInfoStore() ProjectInfoStore {
	return x.projectInfo
}

func (x stateStore) BatchInfoStore() BatchInfoStore {
	return x.batchInfo
}

func (x stateStore) ClassSequenceStore() ClassSequenceStore {
	return x.classSequence
}

func (x stateStore) ProjectSequenceStore() ProjectSequenceStore {
	return x.projectSequence
}

func (x stateStore) BatchSequenceStore() BatchSequenceStore {
	return x.batchSequence
}

func (x stateStore) BatchBalanceStore() BatchBalanceStore {
	return x.batchBalance
}

func (x stateStore) BatchSupplyStore() BatchSupplyStore {
	return x.batchSupply
}

func (stateStore) doNotImplement() {}

var _ StateStore = stateStore{}

func NewStateStore(db ormtable.Schema) (StateStore, error) {
	creditTypeStore, err := NewCreditTypeStore(db)
	if err != nil {
		return nil, err
	}

	classInfoStore, err := NewClassInfoStore(db)
	if err != nil {
		return nil, err
	}

	classIssuerStore, err := NewClassIssuerStore(db)
	if err != nil {
		return nil, err
	}

	projectInfoStore, err := NewProjectInfoStore(db)
	if err != nil {
		return nil, err
	}

	batchInfoStore, err := NewBatchInfoStore(db)
	if err != nil {
		return nil, err
	}

	classSequenceStore, err := NewClassSequenceStore(db)
	if err != nil {
		return nil, err
	}

	projectSequenceStore, err := NewProjectSequenceStore(db)
	if err != nil {
		return nil, err
	}

	batchSequenceStore, err := NewBatchSequenceStore(db)
	if err != nil {
		return nil, err
	}

	batchBalanceStore, err := NewBatchBalanceStore(db)
	if err != nil {
		return nil, err
	}

	batchSupplyStore, err := NewBatchSupplyStore(db)
	if err != nil {
		return nil, err
	}

	return stateStore{
		creditTypeStore,
		classInfoStore,
		classIssuerStore,
		projectInfoStore,
		batchInfoStore,
		classSequenceStore,
		projectSequenceStore,
		batchSequenceStore,
		batchBalanceStore,
		batchSupplyStore,
	}, nil
}
